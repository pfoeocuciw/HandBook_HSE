<!DOCTYPE html>
<html lang="ru" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Hack&display=swap" rel="stylesheet">
    <title>Хендбук</title>
    <link rel="stylesheet" href="chapter_1.css">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/pyodide"></script>
    <script src="libs/prism.js"></script>

</head>
<div class="horizontal-accordion-wrapper">
    <div class="accordion-left">
        <button id="toggleNav" class="accordion-button-left" style="color: white; border-color: white;">☰</button>
    </div>
    <div id="sideNav" class="accordion-panel-right_2">
        <a href="#chapter1"><strong>Глава 1</strong></a>
        <a href="#chapter1-1">1.1 Знакомство с Pandas</a>
        <a href="#chapter1-2">1.2 Структуры данных</a>
        <a href="#chapter1-3">1.3 Элементы DataFrame</a>
        <a href="#chapter1-4">1.4 Открытие таблиц</a>
        <a href="#chapter1-5">1.5 Информация о DataFrame</a>
        <a href="#chapter1-6">1.6 Типы данных в анализе</a>

        <div style="height: 0px; padding: 10px;"></div>

        <a href="#chapter2"><strong>Глава 2</strong></a>
        <a href="#chapter2-1">2.1 Фильтрация в DataFrame</a>
        <a href="#chapter2-2">2.2 Сортировку в DataFrame</a>
        <a href="#chapter2-3">2.3 Разница между .loc[] и .iloc[]</a>
        <a href="#chapter2-4">2.4 Фильтрация или сортировка в Series</a>

        <div style="height: 0px; padding: 10px;"></div>

        <a href="#chapter3"><strong>Глава 3</strong></a>
        <a href="#chapter3-1">3.1 Создание признака</a>
        <a href="#chapter3-2">3.2 Именованная функция</a>
        <a href="#chapter3-3">3.3 Анонимная функция</a>
        
        <div style="height: 0px; padding: 10px;"></div>

        <a href="#chapter4"><strong>Глава 4</strong></a>
        <a href="#chapter4-1">4.1 Частотная таблица</a>
        <a href="#chapter4-2">4.2 Визуализация</a>
        
        <div style="height: 0px; padding: 10px;"></div>

        <a href="#chapter5"><strong>Глава 5</strong></a>
        <a href="#chapter5-1">5.1 Агрегирование данных</a>
        <a href="#chapter5-2">5.2 Сводная таблица</a>
        
        <div style="height: 0px; padding: 10px;"></div>

        <a href="#chapter6"><strong>Глава 6</strong></a>
        <a href="#chapter6-1">6.1 Описательные статистики</a>
        <a href="#chapter6-2">6.2 МЦТ</a>
        <a href="#chapter6-3">6.3 Квартили</a>
        <a href="#chapter6-4">6.4 Меры вариативности</a>
        <a href="#chapter6-5">6.5 Выбросы</a>
        <a href="#chapter6-6">6.6 Пропуски в данных</a>

        <div style="height: 0px; padding: 10px;"></div>

        <a href="#chapter7"><strong>Глава 7</strong></a>
        <a href="#chapter7-1">7.1 Пирсон и Спирмен</a>
        <a href="#chapter7-2">7.2 Рассчет корреляции</a>

        <div style="height: 0px; padding: 10px;"></div>

        <a href="#chapter8"><strong>Глава 8</strong></a>
        <a href="#chapter8-1">8.1 Термины линейной регрессии</a>
        <a href="#chapter8-2">8.2 Обучение линейной регрессии</a>
        <a href="#chapter8-3">8.3 Интерпретация линейной регрессии</a>
        <a href="#chapter8-4">8.4 Оценка линейной регрессии</a>
    </div>
    <div class="main-content" style="padding-top: 10px;">
        <div class="logo-wrapper">
            <img src="picture/logo.svg" class="logo-top-right" alt="Логотип">
        </div>
        <section>
            <h1 style="font-size: 30px;color:#1e01da; ">Хендбук. Анализ данных. Начальный уровень</h1>
            <p>Автор: Перевышина Татьяна<br>
            Верстка: Шарифулин Максим, Безносенкова Софья<br>
            Дизайн: Бутусова Катерина
            </p>
            <h1 style="font-size: 30px;">Предисловие</h1>
            <p>Представьте, что вы собираете пазл. В начале у вас есть множество разрозненных кусочков информации,
                которые сами по себе не дают полной картины. Каждый кусочек — это отдельный фрагмент данных,
                который может быть числом, текстом или другим типом информации. Ваша задача — собрать эти
                кусочки вместе, чтобы увидеть общую картину. Сначала вы сортируете кусочки пазла по цвету
                или форме, чтобы облегчить задачу. В анализе данных это соответствует очистке и подготовке
                данных — удалению ненужных элементов, заполнению пропусков и приведению данных к нужному
                формату. Затем вы начинаете искать кусочки, которые подходят друг к другу, соединяя их в
                небольшие группы. В анализе данных это может быть поиск закономерностей между различными
                переменными. Постепенно, соединяя маленькие группы в большие, вы начинаете видеть общую
                картину. В анализе данных это означает, что вы находите ключевые инсайты, которые помогают
                понять, что происходит в данных. Когда пазл собран, вы видите полную картину — красивую
                сцену или изображение. В анализе данных это момент, когда вы понимаете, какие выводы можно
                сделать из данных и как их можно использовать для принятия решений.</p>

            <div class="definition-card">
                <div class="definition-text">
                    <strong>Анализ данных</strong> — это процесс превращения больших объемов информации в понятные выводы и идеи.
                </div>
            </div>

            <p>
                В рамках этого курса вы освоите навыки анализа табличных данных, что позволит вам извлекать
                ценные инсайты, выявлять закономерности и принимать обоснованные решения на основе фактов.
                Например, компании собирают данные о продажах, чтобы понять, какие товары популярны, а какие
                нет, и как лучше планировать производство и рекламу. В результате анализа данных можно
                принимать более разумные решения, основываясь на фактах, а не на догадках.
            </p>
</section>

<div style="height: 0px; padding: 20px;"></div>
<div> <!-- ГЛАВА 1 -->

<section>
    <h1 style="font-size: 30px; color:#1e01da;" id="chapter1">Глава 1. Знакомство с библиотекой Pandas. Типы данных в анализе.</h1>
    <div style="height: 10px;"></div>
    <h2 id="chapter1-1">1.1 Что такое библиотека Pandas?</h2>
    <p>Представьте себе большую коробку с инструментами: там есть молоток, отвертка,
        пила и другие полезные вещи. Когда мы строим дом, нам не нужно изобретать эти
        инструменты заново — мы просто берем их из коробки и используем. Так и с
        библиотеками: когда программисту нужно сделать что-то сложное, например, обработать
        данные или нарисовать график, он берет готовую библиотеку, подключает её к своему
        проекту и пользуется уже написанным кодом.</p>
    <div class="definition-card">
        <div class="definition-text">
            <strong>Библиотека</strong> — это набор готовых функций и инструментов, который программисты могут использовать в своих проектах, чтобы не писать код с нуля каждый раз.
        </div>
    </div>

</section>


<section>
    <p>Готовые инструменты для работы с табличными данными хранятся в библиотеке Pandas.
        Эта библиотека позволяет быстро загружать, сортировать, фильтровать и анализировать
        большие объемы данных, как если бы мы работали с электронными таблицами, такими как Excel.
        Однако Pandas имеет ряд объективных преимуществ перед Excel:</p>
    <ul>
        <li>
            <strong>Excel ограничен количеством строк (~1 млн строк максимум).</strong> Библиотека Pandas
            способна эффективно обрабатывать миллионы и даже миллиарды строк благодаря
            оптимизации вычислительных процессов внутри Python.
        </li>
        <li>
            <strong>Производительность Excel резко падает при увеличении объема обрабатываемых данных.</strong>
            Формулы, сводные таблицы и фильтры начинают тормозить, особенно если файл занимает
            много места в оперативной памяти. Библиотека Pandas способна намного эффективнее
            справляться со сложными операциями и расчетами на больших объемах.
        </li>
        <li>
            <strong>Работа в Excel зачастую связана с ручным редактированием формул и визуальным
            управлением данными, что делает процесс более трудоемким.</strong> В Python можно написать
            программу один раз, а потом многократно запускать её снова и снова, каждый раз получая
            стабильный и точный результат
        </li>
        <li>
            <strong>Эффективное использование Excel для анализа больших данных требует знания VBA-макросов,
            настройки Power Query и понимания тонкостей работы со сводными таблицами.</strong> Для решения
            аналогичных задач на Python достаточно базовых навыков программирования и умения пользоваться
            библиотеками Pandas.
        </li>
    </ul>

    <p>
        Excel отлично подходит для небольших отчетов и простого анализа. Когда дело доходит до
        крупных проектов и регулярного обновления данных, профессиональные инструменты, такие как
        библиотека Pandas, становятся незаменимыми.
    </p>
    <p>
        Чтобы начать использовать инструменты библиотеки Pandas, необходимо сделать импорт
        библиотеки в среду выполнения:
    </p>
    <pre class="line-numbers"><code class="language-python">import pandas as pd</code></pre>
</section>

<section>
     <ul>
         <li>
             <span class="code-chip">import</span>&nbsp;– оператор, который подключает библиотеку в среду выполнения
         </li>
         <li>
             <span class="code-chip">pandas</span>&nbsp; - название импортируемой библиотеки
         </li>
         <li>
             <span class="code-chip">as</span>&nbsp; - оператор, с помощью которого задается псевдоним библиотеки
         </li>
         <li>
             <span class="code-chip">pd</span>&nbsp; - псевдоним, который позволяет обращаться к функциям библиотеки Pandas через сокращение pd. Это делается для удобства и сокращения кода.
         </li>
     </ul>
        <div class="accordion-container">
            <div class="accordion-item">
                <button class="accordion-button" style="width: 800px;">Ошибка <span class="code-chip" style="color: black;">ModuleNotFoundError: No module named 'pandas'</span>&nbsp;</button>
                <div class="accordion-content">
                    <p>Если при запуске кода вышла такая ошибка, это значит, что модуль
                        Pandas еще не установлен на вашем компьютере. Чтобы его установить,
                        нужно перед импортом добавить строку:
                    </p>
                    <pre class="line-numbers"><code class="language-python">!pip install pandas</code></pre>
                </div>
            </div>
        </div>


</section>

<section>
    <div style="height: 10px;"></div>
    <h2 id="chapter1-2">
        1.2 Какие существуют структуры данных Pandas?
    </h2>
    <p>
        В библиотеке Pandas есть два основных способа хранения табличных данных: датафрейм <span class="code-chip">DataFrame</span>&nbsp; и серия <span class="code-chip">Series</span>.&nbsp;
    </p>
    <p style="font-size: 25px;"><strong>DataFrame</strong></p>
    <p>Представьте себе электронную таблицу, такую как Excel. У неё есть строки и столбцы, и в каждой
        ячейке хранится информация. Датафрейм в Pandas — это такая же таблица, только для программирования.
        Он состоит из строк и столбцов, и каждая ячейка содержит данные.
    </p>
    <p>
        Чтобы создать датафрейм, необходимо воспользоваться функцией <span class="code-chip">pd.DataFrame()</span>&nbsp; из библиотеки <span class="code-chip">Pandas</span>&nbsp;:
    </p>
    <p class="fake-code"><span class="code-line">переменная = pd.DataFrame()</span></p>

    <p>Для добавления столбцов мы указываем название <span class="code-chip">переменной</span>&nbsp;, в которой лежит датафрейм,
        затем в квадратных скобках указываем <span class="code-chip">'название столбца'</span>&nbsp; и в него передаем список значений:
    </p>
    <p class="fake-code"><span class="code-line">переменная['название столбца'] = [значение 1, значение 2, ...]</span></p>
    <p>Столбцы могут иметь разные типы данных: числа, тексты, даты и т.д.</p>
    <p>Предположим, мы хотим создать датафрейм с информацией про трех студентов.
        Чтобы его создать, нужно написать следующий код:
    </p>
    <pre class="line-numbers"><code class="language-python">students = pd.DataFrame()  # cоздаем пустой датафрейм
students['Имя'] = ['Иван', 'Ольга', 'Сергей']  # добавляем столбец с именами
students['Возраст'] = [20, 22, 21]  # добавляем столбец с возрастом
students['Город'] = ['Москва', 'Казань', 'Новосибирск']  # добавляем столбец с городом
students  # выводим датафрейм на экран    </code></pre>
    <p>Результат работы программы:</p>

    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Имя</th>
            <th>Возраст</th>
            <th>Город</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>Иван</td>
            <td>20</td>
            <td>Москва</td>
        </tr>
        <tr>
            <th>1</th>
            <td>Ольга</td>
            <td>22</td>
            <td>Казань</td>
        </tr>
        <tr>
            <th>2</th>
            <td>Сергей</td>
            <td>21</td>
            <td>Новосибирск</td>
        </tr>
        </tbody>
    </table>
    <p>Первая колонка, выделенная жирным, — это <span class="code-chip">индексы</span>&nbsp; строк. Они служат уникальными
        номерами для каждой строки в датафрейме и позволяют быстро обращаться к нужной.
        Индексы создаются автоматически и начинаются с нуля.
    </p>
    <p>
        <span class="code-chip">Строку</span>&nbsp; также называют <span class="code-chip">наблюдением</span>&nbsp;. Наблюдением в наших данных является <em>студент.
        Например, мы видим, что Ольге 22 года и она из Казани.</em> Это одно наблюдение.
    </p>
    <p><span class="code-chip">Столбцы</span>&nbsp; — это <span class="code-chip">признаки</span>&nbsp;, которые описывают наши наблюдения. Мы описываем наблюдения
        тремя характеристиками – <em>именем, возрастом и городом.</em></p>
</section>



<!--&lt;!&ndash; ДАЛЕЕ ШАБЛОНЫ ПО СПИСКУ &ndash;&gt;-->
<!--&lt;!&ndash; Гиперссылки &ndash;&gt;-->
<!--<section><a href=" https://edu.hse.ru/mod/resource/view.php?id=1610897">https://edu.hse.ru/mod/resource/view.php?id=1610897 </a>-->
<!--</section>-->

<!--&lt;!&ndash; Картинка &ndash;&gt;-->
<!--<section><img src="picture/graph_1.png" alt="Описание картинки"></section>-->


<!--<section><button class="check">Практика</button> <button class="check_yourself">Самоопроверка</button> <button class="back_to_course">Вернуться к курсу</button></section>-->

<section>
    <p style="font-size: 25px;"><strong>Series</strong></p>
    <p>Каждый отдельный столбец датафрейма имеет формат серии (Series).
        <strong>Серия</strong> — это набор <strong>значений</strong> с уникальными метками (<strong>индексами</strong>). По сути,
        датафрейм состоит из множества серий, каждая из которых представляет собой
        колонку с индексами и колонку со значениями:</p>

    <img src="picture/0.svg" width="100%" alt="Рисунок 0">

    <p>
        Помимо этого, мы можем создать собственную серию, которая не будет частью датафрейма.
        Чтобы это сделать, нужно воспользоваться функцией <span class="code-chip">pd.Series()</span>&nbsp; из библиотеки Pandas,
        а внутрь функции передать параметр <span class="code-chip">data</span>&nbsp; со списком значений:
    </p>
    <p class="fake-code"><span class="code-line">переменная = pd.Series(data=[значение 1, значение 2, ...])</span></p>
    <p>Предположим, у нас есть <em>средний балл</em> трех студентов. Чтобы сохранить эту информацию в серию,
        нужно написать следующий код:</p>
    <pre class="line-numbers"><code class="language-python">gpa = pd.Series(data=[3.55, 8.24, 7.65])  # создаем серию
gpa  # выводим серию на экран</code></pre>
    <p>Результат работы программы:</p>

    <table border="1" class="dataframe" style="width: 150px;">
        <thead>
        <tr>
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>3.55</td>
        </tr>
        <tr>
            <th>1</th>
            <td>8.24</td>
        </tr>
        <tr>
            <th>2</th>
            <td>7.65</td>
        </tr>
        </tbody>
    </table>
    <p>Первый столбец, выделенный жирным, — <strong>индексы</strong>. Так же как и в датафрейме,
        они создаются автоматически и начинаются с нуля. С их помощью можно обратиться
        к любому значению в серии. Второй столбец — <strong>значения</strong>. В нашем случае это средний
        балл студентов.</p>
    <p>Можно задать свои кастомные индексы для строк серии – для этого при создании нужно передать
        второй список с индексами в параметре <span class="code-chip">index:</span>&nbsp;</p>
    <p class="fake-code">
<span class="code-line" style="color: black;">переменная = pd.Series(data=[значение 1, значения 2, ...],<br>
                       index=[индекс 1, индекс 2, ...])</span>
    </p>
    <p>Например, мы хотим создать серию, в которой <strong>значением</strong> останется <em>средний балл</em>, а <strong>индексами</strong> будут <em>имена студентов</em>:</p>
    <pre class="line-numbers"><code class="language-python">names_gpa = pd.Series(data=[3.55, 8.24, 7.65],           # значения
                     index=['Иван', 'Ольга', 'Сергей'])  # индексы
names_gpa  # выводим серию на экран</code></pre>
    <p>Результат работы программы:</p>
    <table border="1" class="dataframe" style="width: 150px;">
        <thead>
        <tr>
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>Иван</th>
            <td>3.55</td>
        </tr>
        <tr>
            <th>Ольга</th>
            <td>8.24</td>
        </tr>
        <tr>
            <th>Сергей</th>
            <td>7.65</td>
        </tr>
        </tbody>
    </table>
    <p>Имена здесь не полноценная колонка, они лишь уникальные идентификаторы среднего балла.</p>
    <div class="important-card">
        <div class="important-text">
            Cтолбец со значениями в серии может быть только один, а вот в датафрейме их может быть больше одного
        </div>
    </div>
</section>



<section>
    <div style="height: 50px;"></div>
    <h2 id="chapter1-3">1.3 Как извлекать основные элементы DataFrame?</h2>
    <p>В прошлом разделе мы создали датафрейм <span class="code-chip">students</span>&nbsp;. Сейчас мы научимся обращаться к его основным элементам:
        <strong>столбцам</strong>, <strong>строкам</strong> и конкретным <strong>значениям</strong>.</p>
    <pre class="line-numbers"><code class="language-python">students  # выводим датафрейм на экран</code></pre>
    <p>Результат работы программы:</p>
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Имя</th>
            <th>Возраст</th>
            <th>Город</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>Иван</td>
            <td>20</td>
            <td>Москва</td>
        </tr>
        <tr>
            <th>1</th>
            <td>Ольга</td>
            <td>22</td>
            <td>Казань</td>
        </tr>
        <tr>
            <th>2</th>
            <td>Сергей</td>
            <td>21</td>
            <td>Новосибирск</td>
        </tr>
        </tbody>
    </table>

    <p style="font-size: 25px;"><strong>ОБРАЩЕНИЕ К СТОЛБЦУ</strong></p>
    <p>Если мы хотим извлечь столбец из данных, нужно указать сначала
        название переменной, в которой лежит <span class="code-chip">датафрейм</span>&nbsp;, а затем в квадартных
        скобках и кавычках указать <span class="code-chip">название столбца</span>&nbsp;, который требуется извлечь:</p>
    <p class="fake-code">
<span class="code-line" style="color: black;">датафрейм['название столбца']</span>
    <p>Например, мы хотим извлечь столбец Возраст – для этого пишем следующий код:</p>
    <pre class="line-numbers"><code class="language-python">students['Возраст']</code></pre>

    <table border="1" class="dataframe" style="width: 150px;">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Возраст</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>20</td>
        </tr>
        <tr>
            <th>1</th>
            <td>22</td>
        </tr>
        <tr>
            <th>2</th>
            <td>21</td>
        </tr>
        </tbody>
    </table>
    <p>Как мы уже говорили, каждый отдельный столбец датафрейма имеет формат серии <strong>(Series)</strong>.</p>

    <p style="font-size: 25px;"><strong>ОБРАЩЕНИЕ К СТРОКЕ</strong></p>
    <p>Для обращения к строке используется атрибут <span class="code-chip">.loc[]</span>&nbsp;:</p>
    <p class="fake-code">
<span class="code-line" style="color: black;">датафрейм.loc[индекс]</span>
    </p>
    <p>Если нам нужно извлечь информацию про <em>Ольгу</em> (информация про нее записана в строке под индексом <em>1</em>) — пишем следующий код:</p>
    <pre class="line-numbers"><code class="language-python">students.loc[1]</code></pre>
    <table border="1" class="dataframe" style="width: 150px;">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>1</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>Имя</th>
            <td>Ольга</td>
        </tr>
        <tr>
            <th>Возраст</th>
            <td>22</td>
        </tr>
        <tr>
            <th>Город</th>
            <td>Казань</td>
        </tr>
        </tbody>
    </table>
    <p style="font-size: 25px;"><strong>ОБРАЩЕНИЕ К ЗНАЧЕНИЮ</strong></p>
    <p>К значению мы обращаемся по <strong>индексу</strong> строки и <strong>названию</strong> столбца одновременно:</p>
    <p class="fake-code">
<span class="code-line" style="color: black;">датафрейм.loc[индекс]['название столбца']</span>
    </p>
    <p>или</p>
    <p class="fake-code">
<span class="code-line" style="color: black;">датафрейм.loc[индекс, 'название столбца']</span>
    </p>
    <p>Если нам нужен <strong>Возраст</strong> <em>Ольги</em> (у нее индекс 1):</p>
    <pre class="line-numbers"><code class="language-python">students.loc[1]['Возраст']</code></pre>
    <p>Результат работы программы:</p>
    <p class="print_result">22</p>
    <p>или</p>
    <pre class="line-numbers"><code class="language-python">students.loc[1, 'Возраст']</code></pre>
    <p>Результат работы программы:</p>
    <p class="print_result">22</p>
    <div style="height: 50px;"></div>

    <h2 id="chapter1-4">1.4 Как открывать уже готовые таблицы?</h2>
    <p>Библиотека Pandas позволяет открывать уже готовые файлы с различными расширениями.
        Одним из наиболее распространенных форматов является <strong>.csv</strong> (Comma Separated Values),
        который широко используется для хранения табличных данных. Если вам необходимо открыть файл с расширением <strong>.csv:</strong></p>
    <p class="fake-code">
<span class="code-line" style="color: black;">переменная = pd.read_csv('путь к файлу')</span>
    </p>
    <p>Другой популярный формат — это <strong>.xlsx</strong>, применяемый в Microsoft Excel. Если вам необходимо открыть файл с расширением <strong>.xlsx</strong>:</p>
    <p class="fake-code">
<span class="code-line" style="color: black;">переменная = pd.read_excel('путь к файлу')</span>
    </p>
    <p>Еще одно расширение, удобное для хранения табличных данных - это <strong>.pkl</strong> (Pickle). Чтобы открыть такой файл, используйте следующий код:</p>
    <p class="fake-code">
<span class="code-line" style="color: black;">переменная = pd.read_pickle('путь к файлу')</span>
    </p>
    <div class="important-card">
        <div class="important-text">
            Когда вы открываете файл с данными в Pandas, он автоматически сохраняется в формате DataFrame
        </div>
    </div>
</section>

<section>
    <p>
        Давайте попробуем открыть файл <a href=" https://edu.hse.ru/mod/resource/view.php?id=1610897" target="_blank" rel="noopener noreferrer">oscar.pkl</a>. Скачайте его, а затем введите следующий код:
    </p>
    <pre class="line-numbers"><code class="language-python">import pandas as pd
df = pd.read_pickle('путь к файлу/oscar.pkl')  # открываем файл oscar.pkl
df  # выводим датафрейм на экран</code></pre>
    <p>Вместо <span class="code-chip">путь к файлу</span>&nbsp; укажите путь к файлу oscra.pkl на вашем компьютере.</p>
    <div class="accordion-container">
        <div class="accordion-item">
            <button class="accordion-button" style="width: 800px;">КАК НАЙТИ ПУТЬ К ФАЙЛУ?</button>
            <div class="accordion-content" style="padding-left: 20px;">
                <p><strong>macOS</strong></p>
                <ul style="list-style-type: none; padding-left: 0;">
                    <li>
                        1. Найдите файл на компьютере
                    </li>
                    <li>
                        2. Нажмите на него правой кнопкой мыши -> Свойства -> Основные -> Где: путь к файлу
                    </li>
                    <li>
                        3. Нажмите на путь к файлу правой кнопкой мыши -> Скопировать как путь
                    </li>
                    <li>
                        4. Указывая путь в функции, не забудьте дописать название файла с расширением: /название.расширение
                    </li>
                </ul>
                <p><strong>Windows</strong></p>
                <ul style="list-style-type: none; padding-left: 0;">
                    <li>
                        1. Найдите файл на компьютере
                    </li>
                    <li>
                        2. Нажмите на него правой кнопкой мыши -> Свойства -> Расположение: путь к файлу
                    </li>
                    <li>
                        3. Скопируйте путь к файлу
                    </li>
                    <li>
                        4. Указывая путь в функции, не забудьте дописать название файла с расширением: /название.расширение
                    </li>
                </ul>
                <p><strong>Windows 10 и позднее</strong></p>
                <ul style="list-style-type: none; padding-left: 0;">
                    <li>
                        1. Найдите файл на компьютере
                    </li>
                    <li>
                        2. Нажмите на него правой кнопкой мыши -> Копировать как путь
                    </li>
                </ul>
            </div>
        </div>
    </div>
    <div class="accordion-container">
        <div class="accordion-item">
            <button class="accordion-button" style="width: 800px;">ОШИБКИ ПРИ ОТКРЫТИЕ ФАЙЛА</button>
            <div class="accordion-content" style="padding-left: 20px;">
                <p><span class="code-chip">FileNotFoundError</span>&nbsp;</p>
                <p>Вы неправильно указали путь к файлу. Попробуйте еще раз проделать все шаги
                    в инструкции <strong>КАК НАЙТИ ПУТЬ К ФАЙЛУ?</strong></p>
                <p><span class="code-chip">SyntaxError: invalid syntax</span>&nbsp;</p>
                <p>Вы допустили синтаксическую ошибку: например, забыли закрыть
                    скобку или кавычку, или сделали лишний отступ. Проверьте код еще раз.</p>
                <p><span class="code-chip">SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \UXXXXXXXX escape</span></p>
                <p>Такая ошибка возникает, когда Python пытается интерпретировать строку, содержащую обратный слеш, как экранированную последовательность Unicode. Эта ошибка часто
                    встречается при попытке использовать пути к файлам в Windows. Её можно легко исправить, добавив r перед путем к файлу:</p>
                <pre class="line-numbers"><code class="language-python">df = pd.read_pickle(r'путь к файлу/oscar.pkl')</code></pre>
            </div>
        </div>
    </div>
    <p>Если вы все сделали верно, откроется следующая таблица:</p>
    <table border="1" class="dataframe" style="width: 100%;">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Film</th>
            <th>Award</th>
            <th>Rating</th>
            <th>Votes</th>
            <th>Content Rating</th>
            <th>Release Date</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>Wings</td>
            <td>True</td>
            <td>7.5</td>
            <td>12221</td>
            <td>PG-13</td>
            <td>1927-08-12</td>
        </tr>
        <tr>
            <th>1</th>
            <td>7th Heaven</td>
            <td>False</td>
            <td>7.7</td>
            <td>3439</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>2</th>
            <td>The Racket</td>
            <td>False</td>
            <td>6.7</td>
            <td>1257</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>3</th>
            <td>The Broadway Melody</td>
            <td>True</td>
            <td>5.7</td>
            <td>6890</td>
            <td>NaN</td>
            <td>1929-02-01</td>
        </tr>
        <tr>
            <th>4</th>
            <td>Alibi</td>
            <td>False</td>
            <td>5.8</td>
            <td>765</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>...</th>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
        </tr>
        <tr>
            <th>566</th>
            <td>Mank</td>
            <td>False</td>
            <td>6.9</td>
            <td>65380</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>567</th>
            <td>Minari</td>
            <td>False</td>
            <td>7.5</td>
            <td>57976</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>568</th>
            <td>Promising Young Woman</td>
            <td>False</td>
            <td>7.5</td>
            <td>122269</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>569</th>
            <td>Sound of Metal</td>
            <td>False</td>
            <td>7.8</td>
            <td>102807</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>570</th>
            <td>The Trial of the Chicago 7</td>
            <td>False</td>
            <td>7.8</td>
            <td>156283</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        </tbody>
    </table>
    <p style="font-size: 25px;"><strong>ПРОСМОТР ДАННЫХ</strong></p>
    <p>У нас есть три основных способа посмотреть на наши данные.</p>
    <p>Первый – написать название переменной, в которой лежит датафрейм (как мы сделали в коде выше):</p>

    <pre class="line-numbers"><code class="language-python">df</code></pre>
    <p>В этом случае выводится все содержимое датафрейма. Если данных очень много, выведутся первые и последние 5 строчек таблицы – это как раз наш случай.</p>
    <p>Второй варинт — это метод <span class="code-chip">.head()</span>&nbsp;, который выводит первые 5 строчек таблицы:</p>
    <pre class="line-numbers"><code class="language-python">df.head()</code></pre>
    <table border="1" class="dataframe" style="width: 100%;">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Film</th>
            <th>Award</th>
            <th>Rating</th>
            <th>Votes</th>
            <th>Content Rating</th>
            <th>Release Date</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>Wings</td>
            <td>True</td>
            <td>7.5</td>
            <td>12221</td>
            <td>PG-13</td>
            <td>1927-08-12</td>
        </tr>
        <tr>
            <th>1</th>
            <td>7th Heaven</td>
            <td>False</td>
            <td>7.7</td>
            <td>3439</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>2</th>
            <td>The Racket</td>
            <td>False</td>
            <td>6.7</td>
            <td>1257</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>3</th>
            <td>The Broadway Melody</td>
            <td>True</td>
            <td>5.7</td>
            <td>6890</td>
            <td>NaN</td>
            <td>1929-02-01</td>
        </tr>
        <tr>
            <th>4</th>
            <td>Alibi</td>
            <td>False</td>
            <td>5.8</td>
            <td>765</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        </tbody>
    </table>
    <p>На самом деле, с помощью него можно вывести любое количество первых строк; достаточно указать
        это количество в круглых скобках. Например, если хочется вывести 7 первых строк, нужно написать следующий код:</p>
    <pre class="line-numbers"><code class="language-python">df.head(7)</code></pre>
    <table border="1" class="dataframe" style="width: 100%;">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Film</th>
            <th>Award</th>
            <th>Rating</th>
            <th>Votes</th>
            <th>Content Rating</th>
            <th>Release Date</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>Wings</td>
            <td>True</td>
            <td>7.5</td>
            <td>12221</td>
            <td>PG-13</td>
            <td>1927-08-12</td>
        </tr>
        <tr>
            <th>1</th>
            <td>7th Heaven</td>
            <td>False</td>
            <td>7.7</td>
            <td>3439</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>2</th>
            <td>The Racket</td>
            <td>False</td>
            <td>6.7</td>
            <td>1257</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>3</th>
            <td>The Broadway Melody</td>
            <td>True</td>
            <td>5.7</td>
            <td>6890</td>
            <td>NaN</td>
            <td>1929-02-01</td>
        </tr>
        <tr>
            <th>4</th>
            <td>Alibi</td>
            <td>False</td>
            <td>5.8</td>
            <td>765</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>5</th>
            <td>Hollywood Revue</td>
            <td>False</td>
            <td>5.7</td>
            <td>2004</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>6</th>
            <td>In Old Arizona</td>
            <td>False</td>
            <td>5.6</td>
            <td>1019</td>
            <td>NaN</td>
            <td>1928-12-25</td>
        </tr>
        </tbody>
    </table>
    <p>Если нужно вывести последние 5 строчек таблицы, можно воспользоваться методом <span class="code-chip">.tail()</span>&nbsp;:</p>
    <pre class="line-numbers"><code class="language-python">df.tail()</code></pre>
    <table border="1" class="dataframe" style="width: 100%;">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Film</th>
            <th>Award</th>
            <th>Rating</th>
            <th>Votes</th>
            <th>Content Rating</th>
            <th>Release Date</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>566</th>
            <td>Mank</td>
            <td>False</td>
            <td>6.9</td>
            <td>65380</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>567</th>
            <td>Minari</td>
            <td>False</td>
            <td>7.5</td>
            <td>57976</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>568</th>
            <td>Promising Young Woman</td>
            <td>False</td>
            <td>7.5</td>
            <td>122269</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>569</th>
            <td>Sound of Metal</td>
            <td>False</td>
            <td>7.8</td>
            <td>102807</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>570</th>
            <td>The Trial of the Chicago 7</td>
            <td>False</td>
            <td>7.8</td>
            <td>156283</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        </tbody>
    </table>
    <p>Аналогично методу <span class="code-chip">.head()</span>&nbsp;, <span class="code-chip">.tail()</span>&nbsp; может вывести любое количество последних строк;
        достаточно указать это количество в круглых скобках. Например, если требуется вывести
        3 последние строки, нужно написать следующий код:</p>
    <pre class="line-numbers"><code class="language-python">df.tail(3)</code></pre>
    <table border="1" class="dataframe" style="width: 100%;">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Film</th>
            <th>Award</th>
            <th>Rating</th>
            <th>Votes</th>
            <th>Content Rating</th>
            <th>Release Date</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>568</th>
            <td>Promising Young Woman</td>
            <td>False</td>
            <td>7.5</td>
            <td>122269</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>569</th>
            <td>Sound of Metal</td>
            <td>False</td>
            <td>7.8</td>
            <td>102807</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>570</th>
            <td>The Trial of the Chicago 7</td>
            <td>False</td>
            <td>7.8</td>
            <td>156283</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        </tbody>
    </table>
    <div style="height: 50px;"></div>
    <h2 id="chapter1-5">1.5 Как получить основную информацию про DataFrame?</h2>
    <p>Пришло время познакомиться с нашими данными (<a href=" https://edu.hse.ru/mod/resource/view.php?id=1610897" target="_blank" rel="noopener noreferrer">oscar.pkl</a>).
        Этот датасет содержит информацию о фильмах, номинированных на Оскар, и
        про каждый фильм нам известны следующие характеристики:</p>
    <table border="1" class="dataframe_new" style="width: 100%;">
        <thead>
        <tr style="text-align: right; width: 100%">
            <th>Признак</th>
            <th>Описание</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>Film</th>
            <td>название фильма</td>
        </tr>
        <tr>
            <th>Award</th>
            <td>получил ли фильм Оскар (True — получил, False — не получил)</td>
        </tr>
        <tr>
            <th>Rating</th>
            <td>средний рейтинг фильма на портале IMDB</td>
        </tr>
        <tr>
            <th>Votes</th>
            <td>количество пользователей, поставивших оценку фильму на портале IMDB</td>
        </tr>
        <tr>
            <th>Content Rating</th>
            <td>возрастные ограничения:<br>
                G — для всех возрастных категорий<br>
                PG — для детей в сопровождении родителей<br>
                PG-13 — для детей старше 13 лет<br>
                R — лица, не достигшие 17-летнего возраста, допускаются на фильм только в сопровождении взрослых<br>
                NC-17 — для лиц старше 17 лет</td>
        </tr>
        <tr>
            <th>Release Date</th>
            <td>дата выхода фильма</td>
        </tr>
        </tbody>
    </table>
    <p style="font-size: 25px;"><strong>РАЗМЕР ДАТАФРЕЙМА</strong></p>
    <p>Чтобы узнать количество строк и столбцов в датафрейме, можно воспользоваться свойством <span class="code-chip">.shape</span>&nbsp;:</p>
    <pre class="line-numbers"><code class="language-python">df.shape</code></pre>
    <p>Результат работы программы:</p>
    <p class="print_result">(571, 6)</p>
    <p>Эта команда возвращает кортеж (tuple). Первое число - это количество строк (571 фильм), второе - количество столбцов (6 признаков, описывающих фильм).</p>
    <div class="important-card">
        <div class="important-text" >
            К элементам кортежа можно обращаться по индексу. Если требуется извлечь только количество строк, нужно написать <span class="code-chip">датафрейм.shape[0]</span>&nbsp;, а если мы хотим узнать количество колонок, то <span class="code-chip">датафрейм.shape[1]</span>&nbsp;
        </div>
    </div>
</section>

<section>
    <p style="font-size: 25px;"><strong>ТИП ДАННЫХ СТОЛБЦОВ</strong></p>
    <p>Чтобы узнать, какие форматы данных лежат в каждой из колонок, воспользуйтесь свойством <span class="code-chip">.dtypes</span>&nbsp;:</p>

    <pre class="line-numbers"><code class="language-python">df.dtypes</code></pre>
    <p>Результат работы программы:</p>
    <table border="1" class="dataframe" style="width: 100%;">
        <thead>
        <tr style="text-align: right; width: 100%">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>Film</th>
            <td>object</td>
        </tr>
        <tr>
            <th>Award</th>
            <td>bool</td>
        </tr>
        <tr>
            <th>Rating</th>
            <td>float64</td>
        </tr>
        <tr>
            <th>Votes</th>
            <td>int64</td>
        </tr>
        <tr>
            <th>Content Rating</th>
            <td>object</td>
        </tr>
        <tr>
            <th>Release Date</th>
            <td>datetime64[ns]</td>
        </tr>
        </tbody>
    </table>

    <p>Разберемся, что представляет из себя каждый из форматов.</p>
    <ul>
        <li>
            <strong>bool</strong> (признак <strong>Award</strong>): логический тип данных, значит в признаке может быть только два варианта значений (<span class="code-chip">True</span>&nbsp; или <span class="code-chip">False</span>&nbsp;).
        </li>
        <li>
            <strong>int64</strong> (признак <strong>Votes</strong>): признак содержит только целые числа. 64 - это количество битов, которое отводится под хранение одного числа.
        </li>
        <li>
            <strong>float64</strong> (признак <strong>Rating</strong>): в столбце такого формата хранятся числа с плавающей точкой. У них есть дробная часть. Она может быть равна 0 (например 5.0), но тем не менее она есть.
        </li>
        <li>
            <strong>datetime64[ns</strong>] (признак <strong>Release Data</strong>): специальный формат данных в библиотеке Pandas, предназначенный для хранения даты и времени. Дата, в целом, может храниться в формате object, а признак с информацией о годе – в формате int64
        </li>
        <li>
            <strong>object</strong> (признак <strong>Film</strong> , <strong>Content Rating</strong> ): как правило, хранит текстовую информация (строки (str)), но может хранить и смешанные типы данных.
        </li>
    </ul>
    <p style="font-size: 25px;"><strong>ОСНОВНАЯ ИНФОРМАЦИЯ</strong></p>
    <p>Для вывода сводной информации о структуре датафрейма используется метод
        <span class="code-chip">.info()</span>&nbsp;. Этот метод покажет количество строк и столбцов, типы данных для каждого столбца, наличие пропущенных значений и другие сведения.</p>

    <pre class="line-numbers"><code class="language-python">df.info()</code></pre>
    <img src="picture/1.svg" width="100%" alt="Рисунок 1">
    <p>Давайте обратим внимание на столбец <span class="code-chip">Non-Null Count</span>&nbsp;.
        Он показывает количество не пропущенных значений в каждом из признаков.
        Всего в датафрейме 571 фильм. По таблице <span class="code-chip">.info()</span>&nbsp; мы видим, что в признаках <strong>Film</strong>,
            <strong>Award</strong>, <strong>Rating</strong>, <strong>Votes</strong> - 571 не пропущенное значение (то есть в этих столбцах нет пропусков).
        Однако в столбце <strong>Content Rating</strong> и <strong>Release Date</strong> пропуски есть. Информацию про возрастные ограничения
        (<strong>Content Rating</strong>) имеют только 332 фильма, а про остальные 239 нам ничего не известно.
        Дата выхода фильма (<strong>Release Date</strong>) отсутствует у 132 фильмов.</p>
    <p>Пропуски в данных могут обозначаться как <em>NaN</em> или <em>NaT</em> (в столбцах формата <span class="code-chip">datetime64[ns]</span>&nbsp;). Можно увидеть пропуски в наших данных, даже выведя первые пять строк:</p>
    <pre class="line-numbers"><code class="language-python">df.head()</code></pre>
    <table border="1" class="dataframe" style="width: 100%;">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>Film</th>
            <th>Award</th>
            <th>Rating</th>
            <th>Votes</th>
            <th>Content Rating</th>
            <th>Release Date</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>Wings</td>
            <td>True</td>
            <td>7.5</td>
            <td>12221</td>
            <td>PG-13</td>
            <td>1927-08-12</td>
        </tr>
        <tr>
            <th>1</th>
            <td>7th Heaven</td>
            <td>False</td>
            <td>7.7</td>
            <td>3439</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>2</th>
            <td>The Racket</td>
            <td>False</td>
            <td>6.7</td>
            <td>1257</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        <tr>
            <th>3</th>
            <td>The Broadway Melody</td>
            <td>True</td>
            <td>5.7</td>
            <td>6890</td>
            <td>NaN</td>
            <td>1929-02-01</td>
        </tr>
        <tr>
            <th>4</th>
            <td>Alibi</td>
            <td>False</td>
            <td>5.8</td>
            <td>765</td>
            <td>NaN</td>
            <td>NaT</td>
        </tr>
        </tbody>
    </table>
    <div style="height: 50px;"></div>
    <h2 id="chapter1-6">1.6 Какие бывают типы данных в анализе?</h2>
    <p>В предыдущем разделе мы подробно разобрали технические типы данных в библиотеке Pandas (int64, float64, object и другие). Помимо технической стороны вопроса, важно понимать, какую именно информацию несут наши данные. Здесь технический взгляд уже не поможет — нужно обладать опытом и знаниями. Разделение признаков на виды позволит правильно выбрать для них подходящие методы анализа и способы визуализации.</p>
    <p>Все признаки с точки зрения анализа данных можно разделить на две группы:</p>
    <ul>
        <li>
            Количественные (числовые)
        </li>
        <li>
            Категориальные (качественные)
        </li>
    </ul>
    <p>Давайте теперь разберемся с каждым видом признака детальнее, включая их разновидности.</p>
    <img src="picture/1.svg" width="100%" alt="Рисунок 1">
    <p style="font-size: 25px;"><strong>КОЛИЧЕСТВЕННЫЕ ДАННЫЕ</strong></p>
    <div class="definition-card">
        <div class="definition-text">
            <strong>Количественные признаки </strong>- это численные измерения, которые характеризуют величину или количество некоторого объекта.<br>

            <strong>Примеры</strong>: количество детей в семье, рост<br>

            <strong>Контрольный вопрос для проверки:</strong> Признак измеряется численно? Да
        </div>
    </div>
</section>

<section>
    <p>Количественные данные делятся на два подтипа:</p>
    <ul>
        <li>
            Дискретные признаки
        </li>
    </ul>
    <p>Такие признаки могут принимают только целые значения. Например, если в данных есть столбец количество детей в семье. Такой признак может быть только дискретным, потому что в семье не может быть 1.5 ребенка: либо 1, либо 2.</p>

    <p><strong>Примеры</strong>: количество детей в семье, количество книг в библиотеке, количество посадочных мест в кинозале</p>
    <p><strong>Контрольный вопрос для проверки</strong>: Признак может быть только целым числом? Да</p>
    <ul>
        <li>
            Непрерывные признаки
        </li>
    </ul>
    <p>В отличии от дискретных данных, непрерывные признаки могут принимать дробные значения. Рост может быть посчитан с точностью до миллиметров (Например: Рост Кати 165.3 см).</p>
    <p><strong>Примеры</strong>: рост, вес, зарплата</p>
    <p><strong>Контрольный вопрос для проверки</strong>: Признак может быть дробным числом? Да</p>
    <p style="font-size: 25px"><strong>КАТЕГОРИАЛЬНЫЕ ДАННЫЕ</strong></p>
    <div class="definition-card">
        <div class="definition-text">
            <strong>Категориальные признаки</strong>- отражают принадлежность объектов к определенным категориям.<br>

            <strong>Примеры</strong>: уровень образования, пол<br>

            <strong>Контрольный вопрос для проверки:</strong> ризнак измеряется численно? Нет
        </div>
    </div>
</section>

<section>
    <p>Категориальные данные выражаются через названия, классы или состояния.
        Такие признаки нельзя упорядочить естественным образом или выразить числами,
        хотя <strong>их можно перекодировать числами</strong>. Например, если у нас есть признак уровень
        образования, который содержит следующие категории: начальное, среднее и высшее,
        мы можем перекодировать их следующим образом: <em>начальное - 1, среднее - 2 и высшее - 3</em>.
        От того, что мы их перекодировали, смысл признака не изменился, это все еще принадлежность
        объекта к группе людей с определенным уровнем образования. Только теперь они называются 1, 2 или 3,
        а не начальное, среднее, высшее.</p>
    <p>Категориальные данные делятся на два подтипа:</p>
    <ul>
        <li>
            Порядковые (ранговые) признаки
        </li>
    </ul>
    <p>У категорий такого признака <strong>есть порядок</strong>, но расстояния между ними не определены.
        То есть мы можем сказать, что одна категория больше/лучше/сильнее другой, но не знаем,
        насколько. Уровень образования, о котором мы говорили выше, это порядковый признак.
        Мы можем расставить уровни образования от самого высокого к самому низкому, то есть у них есть шкала.</p>
    <p><strong>Примеры</strong>: <em>уровень образования (начальное/среднее/высшее), оценка успеваемости (неудовлетворительно/удовлетворительно/хорошо/отлично)</em></p>
    <p><strong>Контрольный вопрос для проверки</strong>: <em>Категории в признаке можно упорядочить? Да</em></p>
    <ul>
        <li>
            Номинальные признаки
        </li>
    </ul>
    <p>Номинальный признак описывает <strong>различия</strong> между объектами <strong>без какого-либо порядка</strong>. Каждое значение
        номиналального признака относится к отдельной категории, которую невозможно упорядочить. Если мы
        работаем с данными по автомобилям, там может быть признак, описывающий их цвет. Автомобили могут
        быть красными, черными, зелеными и т.д. Мы не можем сказать, что один цвет лучше чем другой (только субъективно);
        такие категории нельзя упорядочить, значит признак является номинальным.</p>
    <p><strong>Примеры</strong> : <em>цвет автомобиля (красный/черный/зеленый и т.д.), имя человека (Таня/Саша/Коля и т.д.)</em></p>
    <p><strong> Контрольный вопрос для проверки</strong> : <em>Категории в признаке можно упорядочить? Нет</em></p>
    <ul>
        <li>
            Бинарные признаки
        </li>
    </ul>
    <p>Это подтип номинальных данных. Бинарные признаки могут содержать только две категории, например 1/0, True/False, да/нет и т.д.</p>
    <p><strong>Примеры</strong> : <em>наличие социальных сетей (да/нет), семейное положение (женат/не женат)</em></p>
    <p><strong> Контрольный вопрос для проверки</strong> : <em>У признака две категории? Да</em></p>
    <div class="important-card">
        <div class="important-text">
            Представление признака в данных влияет на его интерпретацию. Вернемся к <em>уровню образования</em> . Если он представлен категориями
            <em>начальное/среднее/высшее</em> , то такой признак будет <strong>категориальным порядковым.</strong>
            А если в данных будет только два уровня образования (<em>среднее/высшее</em>) – <strong>категориальным номинальным бинарным</strong>.
            Уровень образования может представлен и количеством лет: 9, 12, 20 и т.д. лет.,
            тогда это <strong>количественный дискретный признак</strong>.
        </div>
    </div>
</section>

<section><a href="https://edu.hse.ru/mod/quiz/view.php?id=1574422" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>&nbsp;<a href="https://edu.hse.ru/mod/quiz/view.php?id=1574583" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>
    <div style="height: 50px;"></div>
</section>
</div>

<div style="height: 0px; padding: 20px;"></div>
<div> <!-- ГЛАВА 2 -->
<section>
            <h1 style="font-size: 30px; color:#1e01da;" id="chapter2">Глава 2. Фильтрация и сортировка</h1>
            <h2 id="chapter2-1">2.1 Как сделать фильтрацию в DataFrame?</h2>
            <p>Часто при работе с большими наборами данных необходимо сконцентрировать внимание только на конкретных наблюдениях, обладающих определенными характеристиками. Такой инструмент анализа называется фильтрацией.</p>
            <div class="definition-card">
                <div class="definition-text">
                    <strong>Фильтрация данных</strong> — это процесс выбора нужных данных из большего объема по каким-то установленным правилам или условиям.
                </div>
            </div>
            <p>Рассмотрим, как работает фильтрация на данных по заказам пиццы в течение года:</p>
            <div class="scrollable-table">
            <table border="1" class="dataframe_new" style="width: 100%;">
                <thead>
                <tr>
                    <th>Признак</th>
                    <th>Описание</th>
                    <th>Формат данных(.dtypes)</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <th>order_date</th>
                    <td>дата заказа (день/месяц)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>order_hour</th>
                    <td>час дня, в который сделан заказ</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>pizza_name_id</th>
                    <td>вид пиццы (hawaiian, pepperoni и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>pizza_size</th>
                    <td>размер пиццы (S, M, L и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>pizza_category</th>
                    <td>описание пиццы (Classic, Veggie и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>quantity</th>
                    <td>количество пицц</td>
                    <td>float64</td>
                </tr>
                <tr>
                    <th>total_price</th>
                    <td>стоимость заказа ($)</td>
                    <td>float64</td>
                </tr>                <tr>
                    <th>pizza_ingredients</th>
                    <td>ингредиенты</td>
                    <td>object</td>
                </tr>                <tr>
                    <th>delivery_price</th>
                    <td>стоимость доставки</td>
                    <td>float64</td>
                </tr>
                </tbody>
            </table>
            </div>
            <p>Одно <strong>наблюдение</strong> - это один <strong>заказ</strong>.</p>
            <pre class="line-numbers"><code class="language-python">import pandas as pd
df = pd.read_csv('pizza.csv')
df.head()</code></pre>
            <p>Результат работы программы:</p>
            <div class="scrollable-table">
            <table border="1" class="dataframe">
                <thead>
                <tr>
                    <th></th>
                    <th>order_date</th>
                    <th>order_hour</th>
                    <th>pizza_name_id</th>
                    <th>pizza_size</th>
                    <th>pizza_category</th>
                    <th>quantity</th>
                    <th>total_price</th>
                    <th>pizza_ingredients</th>
                    <th>delivery_price</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <th>0</th>
                    <td>30/03</td>
                    <td>13</td>
                    <td>big</td>
                    <td>S</td>
                    <td>Classic</td>
                    <td>4.0</td>
                    <td>48.00</td>
                    <td>Bacon, Italian Sausage...</td>
                    <td>30.86</td>
                </tr>
                <tr>
                    <th>1</th>
                    <td>19/09</td>
                    <td>14</td>
                    <td>cali</td>
                    <td>L</td>
                    <td>Chicken</td>
                    <td>4.0</td>
                    <td>83.00</td>
                    <td>Chicken, Artichoke...</td>
                    <td>9.33</td>
                </tr>
                <tr>
                    <th>2</th>
                    <td>19/09</td>
                    <td>14</td>
                    <td>cali</td>
                    <td>L</td>
                    <td>Chicken</td>
                    <td>4.0</td>
                    <td>83.00</td>
                    <td>Chicken, Artichoke...</td>
                    <td>9.33</td>
                </tr>
                <tr>
                    <th>3</th>
                    <td>19/09</td>
                    <td>14</td>
                    <td>cali</td>
                    <td>L</td>
                    <td>Chicken</td>
                    <td>4.0</td>
                    <td>83.00</td>
                    <td>Chicken, Artichoke...</td>
                    <td>9.33</td>
                </tr>
                <tr>
                    <th>4</th>
                    <td>19/09</td>
                    <td>14</td>
                    <td>cali</td>
                    <td>L</td>
                    <td>Chicken</td>
                    <td>4.0</td>
                    <td>83.00</td>
                    <td>Chicken, Artichoke...</td>
                    <td>9.33</td>
                </tr>
                </tbody>
            </table>
            </div>
            <p style="font-size: 25px;"><strong>ФИЛЬТРАЦИЯ С ОДНИМ УСЛОВИЕМ</strong></p>
            <p class="fake-code">
<span class="code-line">датафрейм[условие фильтрации]</span>
            </p>
            <p>В датафрейме есть колонка <strong>pizza_name_id</strong>, в которой прописано, какую пиццу заказал клиент.
                Если нам нужно найти заказы только с гавайской пиццей (<em>hawaiian</em>; <strong>pizza_name_id</strong>), сделаем следующую фильтрацию:</p>
            <pre class="line-numbers"><code class="language-python">df[df['pizza_name_id'] == 'hawaiian']</code></pre>
            <p><span class="code-chip">df</span>&nbsp;- это датафрейм фильтрации</p>
            <p><span class="code-chip">df['pizza_name_id'] == 'hawaiian'</span>&nbsp;- это условие фильтрации:</p>
            <ul>
                <li>
                    <span class="code-chip">df['pizza_name_id']</span>&nbsp;- обращение к признаку <strong>pizza_name_id</strong>;
                </li>
                <li>
                    <span class="code-chip">== 'hawaiian'</span>&nbsp;-  соответствует гавайской пицце (<span class="code-chip">'hawaiian'</span>&nbsp; в кавычках, так как данные типа <span class="code-chip">object</span>&nbsp;)
                </li>
            </ul>
            <pre class="line-numbers"><code class="language-python">df[df['pizza_name_id'] == 'hawaiian']</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>20</th>
                        <td>03/10</td>
                        <td>21</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>3.0</td>
                        <td>49.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>30.31</td>
                    </tr>
                    <tr>
                        <th>38</th>
                        <td>07/07</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.00</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>44.61</td>
                    </tr>
                    <tr>
                        <th>46</th>
                        <td>29/11</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.00</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>37.14</td>
                    </tr>
                    <tr>
                        <th>48</th>
                        <td>11/02</td>
                        <td>11</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.00</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>46.42</td>
                    </tr>
                    <tr>
                        <th>61</th>
                        <td>20/04</td>
                        <td>13</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.00</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>44.50</td>
                    </tr>
                    <tr>
                        <th>...</th>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                    </tr>
                    <tr>
                        <th>48574</th>
                        <td>01/05</td>
                        <td>15</td>
                        <td>hawaiian</td>
                        <td>M</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>13.25</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>49.21</td>
                    </tr>
                    <tr>
                        <th>48588</th>
                        <td>01/05</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>M</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>13.25</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>52.92</td>
                    </tr>
                    <tr>
                        <th>48595</th>
                        <td>01/05</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>54.59</td>
                    </tr>
                    <tr>
                        <th>48615</th>
                        <td>01/05</td>
                        <td>14</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>55.76</td>
                    </tr>
                    <tr>
                        <th>48618</th>
                        <td>01/05</td>
                        <td>14</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>16.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>51.78</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Фильтрацию можно сделать по признакам типа
                <span class="code-chip">int64</span>&nbsp; и <span class="code-chip">float64</span>&nbsp;. Например, мы хотим найти заказы с более чем одной пиццей (<strong>quantity</strong>):</p>

            <pre class="line-numbers"><code class="language-python">df[df['quantity'] > 1]</code></pre>
            <p><span class="code-chip">df</span>&nbsp;- это датафрейм фильтрации</p>
            <p><span class="code-chip">df['quantity'] > 1</span>&nbsp;- это условие фильтрации:</p>
            <ul>
                <li>
                    <span class="code-chip">df['quantity']</span>&nbsp;- обращение к признаку <strong>quantity</strong>;
                </li>
                <li>
                    <span class="code-chip">> 1</span>&nbsp;- более чем одной (<span class="code-chip">1</span> без кавычек, так как данные типа <span class="code-chip">float64</span>)
                </li>
            </ul>
            <pre class="line-numbers"><code class="language-python">df[df['quantity'] > 1]</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>0</th>
                        <td>30/03</td>
                        <td>13</td>
                        <td>big</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>4.0</td>
                        <td>48.00</td>
                        <td>Bacon, Italian Sausage,</td>
                        <td>30.86</td>
                    </tr>
                    <tr>
                        <th>1</th>
                        <td>19/09</td>
                        <td>14</td>
                        <td>cali</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>4.0</td>
                        <td>83.00</td>
                        <td>Chicken, Artichoke...</td>
                        <td>9.33</td>
                    </tr>
                    <tr>
                        <th>2</th>
                        <td>19/05</td>
                        <td>12</td>
                        <td>big</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>4.0</td>
                        <td>48.00</td>
                        <td>Bacon, Pepperoni...</td>
                        <td>33.19</td>
                    </tr>
                    <tr>
                        <th>3</th>
                        <td>13/02</td>
                        <td>13</td>
                        <td>sicilian</td>
                        <td>M</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>48.75</td>
                        <td>Coarse Sicilian Salami...</td>
                        <td>31.06</td>
                    </tr>
                    <tr>
                        <th>4</th>
                        <td>01/06</td>
                        <td>12</td>
                        <td>spicy</td>
                        <td>S</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>37.50</td>
                        <td>Capocollo, Tomatoes...</td>
                        <td>34.19</td>
                    </tr>
                    <tr>
                        <th>...</th>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                    </tr>
                    <tr>
                        <th>922</th>
                        <td>14/02</td>
                        <td>14</td>
                        <td>spinach</td>
                        <td>M</td>
                        <td>Supreme</td>
                        <td>2.0</td>
                        <td>33.00</td>
                        <td>Spinach, Red Onions...</td>
                        <td>38.94</td>
                    </tr>
                    <tr>
                        <th>923</th>
                        <td>08/06</td>
                        <td>18</td>
                        <td>southw</td>
                        <td>M</td>
                        <td>Chicken</td>
                        <td>2.0</td>
                        <td>33.50</td>
                        <td>Chicken, Tomatoes...</td>
                        <td>38.40</td>
                    </tr>
                    <tr>
                        <th>924</th>
                        <td>31/12</td>
                        <td>19</td>
                        <td>bbq</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>2.0</td>
                        <td>41.50</td>
                        <td>Barbecued Chicken...</td>
                        <td>35.25</td>
                    </tr>
                    <tr>
                        <th>925</th>
                        <td>24/07</td>
                        <td>14</td>
                        <td>veggie</td>
                        <td>S</td>
                        <td>Veggie</td>
                        <td>2.0</td>
                        <td>24.00</td>
                        <td>Mushrooms, Tomatoes...</td>
                        <td>46.11</td>
                    </tr>
                    <tr>
                        <th>926</th>
                        <td>28/04</td>
                        <td>12</td>
                        <td>peppr</td>
                        <td>S</td>
                        <td>Supreme</td>
                        <td>2.0</td>
                        <td>25.00</td>
                        <td>Genoa Salami, Capocollo...</td>
                        <td>43.67</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Чтобы написать условия, вам понадобятся операторы сравнения:</p>
            <table border="1" class="dataframe_new" style="width: 100%;">
                <thead>
                <tr style="text-align: right; width: 100%">
                    <th>Оператор</th>
                    <th>Описание</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <th><span class="code-chip">==</span>&nbsp;</th>
                    <td>равно; соответствует</td>
                </tr>
                <tr>
                    <th><span class="code-chip">!=</span>&nbsp;</th>
                    <td>не равно</td>
                </tr>
                <tr>
                    <th><span class="code-chip">></span>&nbsp;</th>
                    <td>больше</td>
                </tr>
                <tr>
                    <th><span class="code-chip">>=</span>&nbsp;</th>
                    <td>больше или равно</td>
                </tr>
                <tr>
                    <th><span class="code-chip"><</span>&nbsp;</th>
                    <td>меньше</td>
                </tr>
                <tr>
                    <th><span class="code-chip"><=</span>&nbsp;</th>
                    <td>меньше или равно</td>
                </tr>
                </tbody>
            </table>
            <p style="font-size: 25px"><strong>ФИЛЬТРАЦИЯ ПО НЕСКОЛЬКИМ УСЛОВИЯМ</strong></p>
            <p>Довольно часто фильтрацию нужно сделать по нескольким признакам. Тогда каждое из условий нужно прописывать в круглых скобках, а между круглыми скобками должен стоять оператор:</p>
            <p class="fake-code">
<span class="code-line">датафрейм[(условие 1) оператор (условие 2) оператор ...]</span>
            <p>На месте <span class="code-chip">оператора</span>&nbsp; может стоять <span class="code-chip">&</span>&nbsp; или <span class="code-chip">|</span>&nbsp;:</p>
            <ul>
                <li>
                    <span class="code-chip">&</span>&nbsp; - оператор "И". Используйте его, если нужно, чтобы все прописанные условия выполнялись одновременно:
                    <p class="fake-code">
<span class="code-line">датафрейм[(условие 1)  & (условие 2) & ...] # одновременное выполнение всех условий</span>
                </li>
                <li>
                    <span class="code-chip">|</span>&nbsp; - оператор "ИЛИ". Его мы используем, когда хотим найти наблюдения, которые соответствуют хотя бы одному из прописанных условий.
                    <p class="fake-code">
<span class="code-line">датафрейм[(условие 1) | (условие 2) | ...] # выполняется хотя бы одно условие</span>
                </li>
            </ul>
            <img src="picture/3.svg" width="100%" alt="Рисунок 3">
            <p>Предположим, нам нужно найти заказы только с гавайской пиццей (<em>hawaiian</em>; <strong>pizza_name_id</strong>) и при этом количество пицц в заказе (<strong>quantity</strong>) должно быть больше одной.</p>
            <div style="display: flex; justify-content: center;">
            <img src="picture/4.svg" width="60%" alt="Рисунок 4">
            </div>
            <p>У нас два условия, которые должны выполняться одновременно, значит используем оператор <span class="code-chip">&</span>&nbsp;:</p>
            <pre class="line-numbers"><code class="language-python">df[(df['pizza_name_id'] == 'hawaiian') & (df['quantity'] > 1)]</code></pre>
            <p><span class="code-chip">df</span>&nbsp;- это датафрейм фильтрации</p>
            <p><span class="code-chip">(df['pizza_name_id']=='hawaiian')&(df['quantity'] > 1)</span>- это условие фильтрации:</p>
            <ul>
                <li>
                    <span class="code-chip">df['pizza_name_id'] == 'hawaiian']</span>&nbsp;- гавайские пиццы
                </li>
                <li>
                    <span class="code-chip">&</span>&nbsp;- и
                </li>
                <li>
                    <span class="code-chip">df['quantity'] > 1</span>&nbsp;- в заказе их больше 1
                </li>
            </ul>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>0</th>
                        <td>30/03</td>
                        <td>13</td>
                        <td>big</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>4.0</td>
                        <td>48.00</td>
                        <td>Bacon, Pepperoni...</td>
                        <td>30.86</td>
                    </tr>
                    <tr>
                        <th>1</th>
                        <td>19/09</td>
                        <td>14</td>
                        <td>cali</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>4.0</td>
                        <td>83.00</td>
                        <td>Chicken, Artichoke...</td>
                        <td>9.33</td>
                    </tr>
                    <tr>
                        <th>2</th>
                        <td>19/05</td>
                        <td>12</td>
                        <td>big</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>4.0</td>
                        <td>48.00</td>
                        <td>Bacon, Pepperoni...</td>
                        <td>33.19</td>
                    </tr>
                    <tr>
                        <th>3</th>
                        <td>13/02</td>
                        <td>13</td>
                        <td>sicilian</td>
                        <td>M</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>48.75</td>
                        <td>Coarse Sicilian Salami...</td>
                        <td>31.06</td>
                    </tr>
                    <tr>
                        <th>4</th>
                        <td>01/06</td>
                        <td>12</td>
                        <td>spicy</td>
                        <td>S</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>37.50</td>
                        <td>Capocollo, Tomatoes...</td>
                        <td>34.19</td>
                    </tr>
                    <tr>
                        <th>...</th>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                    </tr>
                    <tr>
                        <th>48574</th>
                        <td>01/05</td>
                        <td>15</td>
                        <td>hawaiian</td>
                        <td>M</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>13.25</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>49.21</td>
                    </tr>
                    <tr>
                        <th>48588</th>
                        <td>01/05</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>M</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>13.25</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>52.92</td>
                    </tr>
                    <tr>
                        <th>48595</th>
                        <td>01/05</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>54.59</td>
                    </tr>
                    <tr>
                        <th>48615</th>
                        <td>01/05</td>
                        <td>14</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>55.76</td>
                    </tr>
                    <tr>
                        <th>48618</th>
                        <td>01/05</td>
                        <td>14</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>16.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>51.78</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Поменяв <span class="code-chip">&</span>&nbsp; на <span class="code-chip">|</span>&nbsp;, мы получим уже другую фильтрацию. Будут выведены все заказы с гавайской пиццей (<em>hawaiian</em>; <strong>pizza_name_id</strong>) и все заказы, где количество пицц (<strong>quantity</strong>) больше одной, не обязательно с гавайской:</p>
            <div style="display: flex; justify-content: center;">
                <img src="picture/5.svg" width="60%" alt="Рисунок 5">
            </div>

            <pre class="line-numbers"><code class="language-python">df[(df['pizza_name_id'] == 'hawaiian') | (df['quantity'] > 1)]</code></pre>
            <p><span class="code-chip">df</span>&nbsp;- это датафрейм фильтрации</p>
            <p><span class="code-chip">(df['pizza_name_id'] == 'hawaiian')|(df['quantity']>1)</span>&nbsp;- это условие фильтрации:</p>
            <ul>
                <li>
                    <span class="code-chip">df['pizza_name_id'] == 'hawaiian']</span>&nbsp;- гавайские пиццы
                </li>
                <li>
                    <span class="code-chip">|</span>&nbsp;- или
                </li>
                <li>
                    <span class="code-chip">df['quantity'] > 1</span>&nbsp;- заказы, где пицц больше 1
                </li>
            </ul>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>0</th>
                        <td>03/10</td>
                        <td>21</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>3.0</td>
                        <td>49.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>30.31</td>
                    </tr>
                    <tr>
                        <th>38</th>
                        <td>07/07</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>44.61</td>
                    </tr>
                    <tr>
                        <th>46</th>
                        <td>29/11</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>37.14</td>
                    </tr>
                    <tr>
                        <th>48</th>
                        <td>11/02</td>
                        <td>11</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>46.42</td>
                    </tr>
                    <tr>
                        <th>61</th>
                        <td>20/04</td>
                        <td>13</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>44.50</td>
                    </tr>
                    <tr>
                        <th>...</th>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                    </tr>
                    <tr>
                        <th>835</th>
                        <td>17/11</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>M</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>26.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>44.90</td>
                    </tr>
                    <tr>
                        <th>841</th>
                        <td>30/03</td>
                        <td>13</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>39.14</td>
                    </tr>
                    <tr>
                        <th>846</th>
                        <td>02/01</td>
                        <td>18</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>49.39</td>
                    </tr>
                    <tr>
                        <th>888</th>
                        <td>11/11</td>
                        <td>19</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>39.97</td>
                    </tr>
                    <tr>
                        <th>914</th>
                        <td>25/10</td>
                        <td>17</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>46.77</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Для того чтобы сделать фильтрацию по нескольким значениям одного признака, удобно воспользоваться методом <span class="code-chip">.isin()</span>&nbsp;, внутрь которого можно передать <strong>список</strong> искомых категорий:</p>
            <p class="fake-code">
<span class="code-line">датафрейм[датафрейм['признак'].isin([значение 1, значение 2, ...])]</span>
            <p>Например, мы хотим найти <em>заказы</em> с гавайской пиццей (<em>hawaiian</em>; <strong>pizza_name_id</strong>) и пиццей пепперони (<em>pepperoni</em>; <strong>pizza_name_id</strong>):</p>
            <pre class="line-numbers"><code class="language-python">df[df['pizza_name_id'].isin(['hawaiian', 'pepperoni'])]</code></pre>
            <p><span class="code-chip">df</span>&nbsp;- это датафрейм фильтрации</p>
            <p><span class="code-chip">df['pizza_name_id'].isin(['hawaiian', 'pepperoni'])</span>&nbsp;- это условие фильтрации:</p>
            <ul>
                <li>
                    <span class="code-chip">df['pizza_name_id']</span>&nbsp;- обращаемся к признаку <strong>pizza_name_id</strong>
                </li>
                <li>
                    <span class="code-chip">.isin(['hawaiian', 'pepperoni'])</span>&nbsp;- берем из него только заказы с гавайской пиццей и пиццей пепперони
                </li>
            </ul>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>18</th>
                        <td>07/01</td>
                        <td>14</td>
                        <td>pepperoni</td>
                        <td>M</td>
                        <td>Classic</td>
                        <td>3.0</td>
                        <td>37.50</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>37.23</td>
                    </tr>
                    <tr>
                        <th>20</th>
                        <td>03/10</td>
                        <td>21</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>3.0</td>
                        <td>49.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>30.31</td>
                    </tr>
                    <tr>
                        <th>34</th>
                        <td>29/10</td>
                        <td>11</td>
                        <td>pepperoni</td>
                        <td>M</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>25.00</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>46.23</td>
                    </tr>
                    <tr>
                        <th>38</th>
                        <td>07/07</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>21.00</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>44.61</td>
                    </tr>
                    <tr>
                        <th>46</th>
                        <td>29/11</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.00</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>37.14</td>
                    </tr>
                    <tr>
                        <th>...</th>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                    </tr>
                    <tr>
                        <th>48588</th>
                        <td>01/05</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>M</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>13.25</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>52.92</td>
                    </tr>
                    <tr>
                        <th>48594</th>
                        <td>01/05</td>
                        <td>17</td>
                        <td>pepperoni</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>15.25</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>50.38</td>
                    </tr>
                    <tr>
                        <th>48595</th>
                        <td>01/05</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>54.59</td>
                    </tr>
                    <tr>
                        <th>48615</th>
                        <td>01/05</td>
                        <td>14</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>55.76</td>
                    </tr>
                    <tr>
                        <th>48618</th>
                        <td>01/05</td>
                        <td>14</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>16.50</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>51.78</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p style="font-size: 25px"><strong>ПОДСЧЕТ КОЛИЧЕСТВА НАБЛЮДЕНИЙ ПОСЛЕ ФИЛЬТРАЦИИ</strong></p>
            <p>Если мы хотим узнать, сколько строк соответсвует нашему условию
                фильтрации, можно воспользоваться свойством <span class="code-chip">.shape</span>&nbsp;, которое
                мы рассмотрели в прошлой главе. Свойство возвращает кортеж,
                первый элемент которого - количество строк, второй - количество
                столбцов. Добавляя <span class="code-chip">[0]</span>&nbsp;, мы извлекаем количество строк из
                отфильтрованных данных:</p>

            <p class="fake-code">
<span class="code-line">датафрейм[условие/я фильтрации].shape[0]</span>
            <p>Если мы хотим посчитать количество заказов с <em>гавайской</em> пиццей (hawaiian; pizza_name_id), то напишем:</p>
            <pre class="line-numbers"><code class="language-python">df[df['pizza_name_id'] == 'hawaiian'].shape[0]</code></pre>
            <div class="print_result">2370</div>
            <p>Получается, таких заказов было 2370.</p>
            <h2 id="chapter2-2">2.2 Как сделать сортировку в DataFrame?</h2>
            <p>Еще один полезный инструмент анализа - это сортировка.</p>
            <div class="definition-card">
                <div class="definition-text">
                    <strong>Сортировка данных</strong> — это процедура, позволяющая упорядочить информацию по возрастанию или убыванию какого-либо параметра.
                </div>
            </div>
            <p>Для сортировки в библиотеке Pandas используется метод <span class="code-chip">.sort_values()</span>&nbsp;:</p>
            <p class="fake-code">
<span class="code-line">датафрейм.sort_values('признак') # по возрастанию</span>
            <p>или</p>
            <p class="fake-code">
<span class="code-line">датафрейм.sort_values('признак', ascending=False) # по убыванию</span>
            <p>Если мы хотим отсортировать строки нашего датафрейма по возрастанию цены заказа (<strong>total_price</strong>):</p>
            <pre class="line-numbers"><code class="language-python">df.sort_values('total_price')</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>48468</th>
                        <td>29/12</td>
                        <td>22</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>55.12</td>
                    </tr>
                    <tr>
                        <th>16337</th>
                        <td>31/12</td>
                        <td>16</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>57.07</td>
                    </tr>
                    <tr>
                        <th>16610</th>
                        <td>31/12</td>
                        <td>14</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>54.55</td>
                    </tr>
                    <tr>
                        <th>16621</th>
                        <td>28/12</td>
                        <td>12</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>54.07</td>
                    </tr>
                    <tr>
                        <th>16385</th>
                        <td>28/12</td>
                        <td>12</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>54.07</td>
                    </tr>
                    <tr>
                        <th>...</th>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                    </tr>
                    <tr>
                        <th>9</th>
                        <td>02/01</td>
                        <td>12</td>
                        <td>hspicy</td>
                        <td>L</td>
                        <td>Supreme</td>
                        <td>1.0</td>
                        <td>62.25</td>
                        <td>Capocollo, Tomatoes...</td>
                        <td>24.38</td>
                    </tr>
                    <tr>
                        <th>17</th>
                        <td>17/10</td>
                        <td>12</td>
                        <td>bbq</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>3.0</td>
                        <td>62.25</td>
                        <td>Barbecued Chicken, Red Peppers...</td>
                        <td>21.06</td>
                    </tr>
                    <tr>
                        <th>16</th>
                        <td>15/05</td>
                        <td>14</td>
                        <td>thai</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>3.0</td>
                        <td>62.25</td>
                        <td>Chicken, Pineapple...</td>
                        <td>23.09</td>
                    </tr>
                    <tr>
                        <th>13</th>
                        <td>08/10</td>
                        <td>12</td>
                        <td>prsc</td>
                        <td>L</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>62.25</td>
                        <td>Prosciutto di San Daniele...</td>
                        <td>25.16</td>
                    </tr>
                    <tr>
                        <th>1</th>
                        <td>19/09</td>
                        <td>14</td>
                        <td>cali</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>4.0</td>
                        <td>83.00</td>
                        <td>SChicken, Artichoke...</td>
                        <td>9.33</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Первыми вывелись самые дешевые заказы, а в конце самые дорогие.</p>
            <p>Для сортировки в обратном порядке (от самых дорогих заказов к дешевым) нужно добавить параметр <span class="code-chip">ascending=False</span>&nbsp;:</p>
            <pre class="line-numbers"><code class="language-python">df.sort_values('total_price', ascending=False)</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>1</th>
                        <td>19/09</td>
                        <td>14</td>
                        <td>cali</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>4.0</td>
                        <td>83.00</td>
                        <td>Chicken, Artichoke...</td>
                        <td>9.33</td>
                    </tr>
                    <tr>
                        <th>9</th>
                        <td>02/01</td>
                        <td>12</td>
                        <td>spicy</td>
                        <td>L</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>62.25</td>
                        <td>Capocollo, Tomatoes...</td>
                        <td>24.38</td>
                    </tr>
                    <tr>
                        <th>16</th>
                        <td>15/05</td>
                        <td>14</td>
                        <td>thai</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>3.0</td>
                        <td>62.25</td>
                        <td>Chicken, Pineapple...</td>
                        <td>23.09</td>
                    </tr>
                    <tr>
                        <th>17</th>
                        <td>17/10</td>
                        <td>12</td>
                        <td>bbq</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>3.0</td>
                        <td>62.25</td>
                        <td>Barbecued Chicken...</td>
                        <td>21.06</td>
                    </tr>
                    <tr>
                        <th>13</th>
                        <td>08/10</td>
                        <td>12</td>
                        <td>prsc</td>
                        <td>L</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>62.25</td>
                        <td>Prosciutto di San Daniele...</td>
                        <td>25.16</td>
                    </tr>
                    <tr>
                        <th>36861</th>
                        <td>01/06</td>
                        <td>17</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>54.05</td>
                    </tr>
                    <tr>
                        <th>21892</th>
                        <td>08/11</td>
                        <td>14</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>54.96</td>
                    </tr>
                    <tr>
                        <th>3515</th>
                        <td>18/09</td>
                        <td>12</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>56.73</td>
                    </tr>
                    <tr>
                        <th>46244</th>
                        <td>07/05</td>
                        <td>19</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>56.01</td>
                    </tr>
                    <tr>
                        <th>3551</th>
                        <td>18/09</td>
                        <td>13</td>
                        <td>pepperoni</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>9.75</td>
                        <td>Mozzarella Cheese, Pepperoni</td>
                        <td>53.61</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p style="font-size: 25px"><strong>ФИЛЬТРАЦИЯ И СОРТИРОВКА</strong></p>
            <p>Сортировать можно и отфильтрованные данные:</p>
            <p class="fake-code">
<span class="code-line">датафрейм[условие/ия фильтрации].sort_values('признак') # по возрастанию</span>
            <p>или</p>
            <p class="fake-code">
<span class="code-line">датафрейм[условие/ия фильтрации].sort_values('признак', ascending=False) # по убыванию</span>
            <p>Если нам нужны только заказы с гавайской пиццей (<em>hawaiian</em>; <strong>pizza_name_id</strong>), отсортированные по возрастанию их стоимости (<strong>total_price</strong>), напишем следующий код:</p>
            <pre class="line-numbers"><code class="language-python">df[df['pizza_name_id'] == 'hawaiian'].sort_values('total_price')</code></pre>
            <p><span class="code-chip">df[df['pizza_name_id'] == 'hawaiian']</span>&nbsp; - берем заказы только с гавайской пиццей</p>
            <p><span class="code-chip">.sort_values('total_price')</span>&nbsp; - сортируем их по возрастанию стоимости</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>48615</th>
                        <td>01/05</td>
                        <td>14</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>55.76</td>
                    </tr>
                    <tr>
                        <th>19599</th>
                        <td>21/10</td>
                        <td>13</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>55.57</td>
                    </tr>
                    <tr>
                        <th>19595</th>
                        <td>21/10</td>
                        <td>13</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>52.79</td>
                    </tr>
                    <tr>
                        <th>19493</th>
                        <td>21/10</td>
                        <td>21</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>53.16</td>
                    </tr>
                    <tr>
                        <th>19427</th>
                        <td>20/10</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>51.92</td>
                    </tr>
                    <tr>
                        <th>694</th>
                        <td>25/10</td>
                        <td>13</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>37.47</td>
                    </tr>
                    <tr>
                        <th>725</th>
                        <td>12/08</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>38.30</td>
                    </tr>
                    <tr>
                        <th>594</th>
                        <td>24/05</td>
                        <td>17</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>35.29</td>
                    </tr>
                    <tr>
                        <th>764</th>
                        <td>03/04</td>
                        <td>20</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>38.96</td>
                    </tr>
                    <tr>
                        <th>20</th>
                        <td>03/10</td>
                        <td>21</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>3.0</td>
                        <td>49.5</td>
                        <td>Sliced Ham, Pineapple..</td>
                        <td>30.31</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Если нужна сортировка по убыванию:</p>
            <pre class="line-numbers"><code class="language-python">df[df['pizza_name_id'] == 'hawaiian'].sort_values('total_price', ascending=False)</code></pre>
            <p><span class="code-chip">df[df['pizza_name_id'] == 'hawaiian']</span>&nbsp; - берем заказы только с гавайской пиццей</p>
            <p><span class="code-chip">.sort_values('total_price', ascending=False)</span>&nbsp; - сортируем их по убыванию стоимости</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>20</th>
                        <td>03/10</td>
                        <td>21</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>3.0</td>
                        <td>49.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>30.31</td>
                    </tr>
                    <tr>
                        <th>458</th>
                        <td>26/05</td>
                        <td>14</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>42.15</td>
                    </tr>
                    <tr>
                        <th>409</th>
                        <td>13/12</td>
                        <td>16</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>40.26</td>
                    </tr>
                    <tr>
                        <th>490</th>
                        <td>26/02</td>
                        <td>13</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>37.93</td>
                    </tr>
                    <tr>
                        <th>78</th>
                        <td>07/07</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>L</td>
                        <td>Classic</td>
                        <td>2.0</td>
                        <td>33.0</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>39.25</td>
                    </tr>
                    <tr>
                        <th>1632</th>
                        <td>31/08</td>
                        <td>20</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>55.58</td>
                    </tr>
                    <tr>
                        <th>1652</th>
                        <td>01/09</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>53.96</td>
                    </tr>
                    <tr>
                        <th>47732</th>
                        <td>26/04</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>53.55</td>
                    </tr>
                    <tr>
                        <th>47788</th>
                        <td>24/04</td>
                        <td>22</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>50.96</td>
                    </tr>
                    <tr>
                        <th>47793</th>
                        <td>25/04</td>
                        <td>12</td>
                        <td>hawaiian</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>1.0</td>
                        <td>10.5</td>
                        <td>Sliced Ham, Pineapple...</td>
                        <td>52.50</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <h2 id="chapter2-3">2.3 В чем разница между <span class="code-chip">.loc[]</span>&nbsp; и <span class="code-chip">.iloc[]</span>&nbsp;?</h2>
            <p>В прошлой главе мы с вами рассмотрели метод <span class="code-chip">.loc[]</span>&nbsp;, с помощью которого можно обращаться к строке по индексу:</p>
            <p class="fake-code">
<span class="code-line">датафрейм.loc[индекс] # обращение к строке по индексу</span>
            <p>Например, мы хотим извлечь заказ под индексом 0:</p>
            <pre class="line-numbers"><code class="language-python">df.iloc[0]</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>0</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>order_date</th>
                        <td>30/03</td>
                    </tr>
                    <tr>
                        <th>order_hour</th>
                        <td>13</td>
                    </tr>
                    <tr>
                        <th>pizza_name_id</th>
                        <td>big</td>
                    </tr>
                    <tr>
                        <th>pizza_size</th>
                        <td>S</td>
                    </tr>
                    <tr>
                        <th>pizza_category</th>
                        <td>Classic</td>
                    </tr>
                    <tr>
                        <th>quantity</th>
                        <td>4.0</td>
                    </tr>
                    <tr>
                        <th>total_price</th>
                        <td>48.0</td>
                    </tr>
                    <tr>
                        <th>pizza_ingredients</th>
                        <td>Bacon, Pepperoni, Italian Sausage, Chorizo Sausage</td>
                    </tr>
                    <tr>
                        <th>delivery_price</th>
                        <td>30.31</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Если нужно конретное значение из датафрейма, к нему можно обратиться по <em>индексу</em> и <em>признаку</em>:</p>
            <p class="fake-code">
<span class="code-line">датафрейм.loc[индекс]['признак'] # обращение к значению по индексу и признаку</span>
            <p>Например мы хотим узнать какие ингредиенты (<strong>pizza_ingredients</strong>) были использованы для пиццы в заказе под индексом 0:</p>
            <pre class="line-numbers"><code class="language-python">df.iloc[0]['pizza_ingredients']</code></pre>
            <div class="print_result">Bacon, Pepperoni, Italian Sausage, Chorizo Sausage</div>
            <p>Но иногда возникает необходимость обратиться к данным не по их индексу, а по их положению в таблице. Особенно это актуально, когда мы выполняем операции сортировки или изменения порядка строк – ведь при сортировке меняется именно местоположение строк, а не их индекс.</p>
            <p>Здесь нам и пригодится метод <span class="code-chip">.iloc[]</span>&nbsp;, который даёт возможность обращаться
                к данным по их <em>положению</em> в датафрейме:</p>
            <p class="fake-code">
<span class="code-line">датафрейм.iloc[положение]  # обращение к строке по положению</span>
            </p>
            <p>или</p>
            <p class="fake-code">
<span class="code-line">датафрейм.iloc[положение]['признак']  # обращение к значению по положению и признаку</span>
            </p>
            <p>
                <span class="code-chip">положение</span>&nbsp; показывает место строки в датафрейме: к первой строке можно обратиться через 0, ко второй через 1, и т.д. Также существует обратная нумерация положения строк: у последней строки положение -1, у предпоследней -2 и т.д.
            </p>
            <p>Чтобы найти, из каких ингредиентов (<strong>pizza_ingredients</strong>) состоит пицца в самом дешевом заказе (<strong>total price</strong>), нужно написать следующий код:</p>
            <pre class="line-numbers"><code class="language-python">df.sort_values('total_price').iloc[0]['pizza_ingredients']</code></pre>
            <div class="print_result">Mozzarella Cheese, Pepperoni</div>
            <p><span class="code-chip">df.sort_values('total_price')</span>&nbsp; - сортируем заказы по возрастанию цены</p>
            <p><span class="code-chip">.iloc[0]</span>&nbsp; - извлекаем первую строку после сортировки (положение 0)</p>
            <p><span class="code-chip">['pizza_ingredients']</span>&nbsp; - извлекаем ингредиенты пиццы в самом дешевом заказе</p>
            <p>Если бы мы применили метод <span class="code-chip">.loс[0]</span>&nbsp; в коде выше, мы бы не получили необходимый результат. Код бы вернул ингредиенты в заказе под иском индексом 0, а не первом заказе после сортировки по возрастанию цены:</p>
            <pre class="line-numbers"><code class="language-python">df.sort_values('total_price').loc[0]['pizza_ingredients']</code></pre>
            <div class="print_result">Bacon, Pepperoni, Italian Sausage, Chorizo Sausage</div>
            <a href="https://edu.hse.ru/mod/quiz/view.php?id=1574901" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>&nbsp;<a href="https://edu.hse.ru/mod/quiz/view.php?id=1574898" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>
            <div style="height: 50px;"></div>
            <h2 id="chapter2-4">2.4 Как сделать фильтрацию или сортировку в Series?</h2>
            <p>В предыдущих разделах мы изучили, как выполнять фильтрацию и сортировку данных в объектах типа <span class="code-chip">DataFrame</span>&nbsp;. Но аналогичные операции нередко нужны и для одиночных столбцов (<span class="code-chip">Series</span>&nbsp;). Хотя в целом подходы идентичны, имеются небольшие различия в синтаксисе.</p>
            <p>Представьте, что у вас есть серия <span class="code-chip">pizza</span>&nbsp;, которая содержит названия пицц (индексы) и их цену в долларах (значения):</p>
            <pre class="line-numbers"><code class="language-python">import pandas as pd
pizza = pd.Series (data=[10, 15, 13, 12],
                   index=['margherita', 'capricciosa', 'hawaiian', 'four cheese'])
pizza</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>0</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>margherita</th>
                        <td>10</td>
                    </tr>
                    <tr>
                        <th>capricciosa</th>
                        <td>15</td>
                    </tr>
                    <tr>
                        <th>hawaiian</th>
                        <td>13</td>
                    </tr>
                    <tr>
                        <th>four cheese</th>
                        <td>12</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p style="font-size: 25px;"><strong>ФИЛЬТРАЦИЯ СЕРИИ</strong></p>
            <p class="fake-code">
<span class="code-line">серия[условие фильтрации]</span>
            </p>
            <p>Если мы хотим найти все пиццы, цена которых больше 10 долларов:</p>
            <pre class="line-numbers"><code class="language-python">pizza[pizza>10]</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>0</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>capricciosa</th>
                        <td>15</td>
                    </tr>
                    <tr>
                        <th>hawaiian</th>
                        <td>13</td>
                    </tr>
                    <tr>
                        <th>four cheese</th>
                        <td>12</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>При фильтрации серии (<span class="code-chip">Series</span>&nbsp;) не нужно обращаться к столбцу, как это делалось в <span class="code-chip">DataFrame</span>&nbsp;. Просто повторяем имя самой серии в условии.</p>
            <p style="font-size: 25px;"><strong>СОРТИРОВКА</strong></p>
            <p>Для сортировки значений серии также используется метод <span class="code-chip">.sort_values()</span>&nbsp;, но внутри него мы не указываем название признака:</p>
            <p class="fake-code">
<span class="code-line">серия.sort_values()  # по возрастанию значений</span>
            </p>
            <p>или</p>
            <p class="fake-code">
<span class="code-line">серия.sort_values(ascending=False)  # по убыванию значений</span>
            </p>
            <p>Если мы хотим расставить пиццы по возрастанию цены:</p>
            <pre class="line-numbers"><code class="language-python">pizza.sort_values()</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>0</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>margherita</th>
                        <td>10</td>
                    </tr>
                    <tr>
                        <th>four cheese</th>
                        <td>12</td>
                    </tr>
                    <tr>
                        <th>hawaiian</th>
                        <td>13</td>
                    </tr>
                    <tr>
                        <th>capricciosa</th>
                        <td>15</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Если нужна сортировка по убыванию цены, нужно добавить параметр <span class="code-chip">ascending=False</span>&nbsp;:</p>
            <pre class="line-numbers"><code class="language-python">pizza.sort_values(ascending=False)</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>0</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>capricciosa</th>
                        <td>15</td>
                    </tr>
                    <tr>
                        <th>hawaiian</th>
                        <td>13</td>
                    </tr>
                    <tr>
                        <th>four cheese</th>
                        <td>12</td>
                    </tr>
                    <tr>
                        <th>margherita</th>
                        <td>10</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>В серии еще есть столбец индексов – в нашем случае это название пиццы. По нему также можно сделать сортировку, но для этого нужно воспользоваться методом <span class="code-chip">.sort_index()</span>&nbsp;:</p>
            <p class="fake-code">
<span class="code-line">серия.sort_index()  # по возрастанию индексов</span>
            </p>
            <p>или</p>
            <p class="fake-code">
<span class="code-line">серия.sort_index(ascending=False)  # по убыванию индексов</span>
            </p>
            <p>Чтобы отсортировать серию по названию пиццы (индексам):</p>
            <pre class="line-numbers"><code class="language-python">pizza.sort_index()</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>0</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th>capricciosa</th>
                        <td>15</td>
                    </tr>
                    <tr>
                        <th>four cheese</th>
                        <td>12</td>
                    </tr>
                    <tr>
                        <th>hawaiian</th>
                        <td>13</td>
                    </tr>
                    <tr>
                        <th>margherita</th>
                        <td>10</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <a href="https://edu.hse.ru/mod/quiz/view.php?id=1575209" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211)" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>
            <div style="height: 50px;"></div>
        </section>
</div>

<div style="height: 0px; padding: 20px;"></div>
<div> <!-- ГЛАВА 3 -->

<section>
    <h1 style="font-size: 30px; color:#1e01da;" id="chapter3">Глава 3. Новые признаки</h1>
    <div style="height: 10px;"></div>
    <h2 id="chapter3-1">3.1 Как создать новый признак в данных?</h2>
    <p>В этой главе мы изучим, как создавать новые столбцы в датафрейме. Создавая признаки, мы можем получить из уже имеющихся данных новую полезную информацию, которая может нам пригодиться для анализа и принятия решений.</p>
    <p style="display:inline">Давайте снова обратимся к данным по заказам пиццы </p><a style="display:inline" href="https://edu.hse.ru/mod/resource/view.php?id=1610926"><p style="display:inline">pizza.csv:</p></a>
            <div class="scrollable-table">
            <table border="1" class="dataframe_new" style="width: 100%;">
                <thead>
                <tr>
                    <th>Признак</th>
                    <th>Описание</th>
                    <th>Формат данных(.dtypes)</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <th>order_date</th>
                    <td>дата заказа (день/месяц)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>order_hour</th>
                    <td>час дня, в который сделан заказ</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>pizza_name_id</th>
                    <td>вид пиццы (hawaiian, pepperoni и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>pizza_size</th>
                    <td>размер пиццы (S, M, L и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>pizza_category</th>
                    <td>описание пиццы (Classic, Veggie и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>quantity</th>
                    <td>количество пицц</td>
                    <td>float64</td>
                </tr>
                <tr>
                    <th>total_price</th>
                    <td>стоимость заказа ($)</td>
                    <td>float64</td>
                </tr>                <tr>
                    <th>pizza_ingredients</th>
                    <td>ингредиенты</td>
                    <td>object</td>
                </tr>                <tr>
                    <th>delivery_price</th>
                    <td>стоимость доставки</td>
                    <td>float64</td>
                </tr>
                </tbody>
            </table>
            </div>
<p>Одно <strong>наблюдение</strong> - это один <strong>заказ</strong>.</p>
        </section>

<section>
        <pre class="line-numbers"><code class="language-python">import pandas as pd

df = pd.read_csv('pizza.csv')
df.head()</code></pre>

            <p>Результат работы программы:</p>
<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
        </tr>
        </thead>
        <tbody>

        <tr>
            <th>0</th>
            <td>30/03</td>
            <td>13</td>
            <td>big</td>
            <td>S</td>
            <td>Classic</td>
            <td>4.0</td>
            <td>48.00</td>
            <td>Bacon, Pepperoni, ...</td>
        </tr>
        <tr>
            <th>1</th>
            <td>19/09</td>
            <td>14</td>
            <td>cali</td>
            <td>L</td>
            <td>Chicken</td>
            <td>4.0</td>
            <td>83.00</td>
            <td>Chicken, Artichoke, ...</td>
        </tr>
        <tr>
            <th>2</th>
            <td>19/05</td>
            <td>12</td>
            <td>big</td>
            <td>S</td>
            <td>Classic</td>
            <td>4.0</td>
            <td>48.00</td>
            <td>Bacon, Pepperoni, ...</td>
        </tr>
        <tr>
            <th>3</th>
            <td>13/02</td>
            <td>13</td>
            <td>sicilian</td>
            <td>M</td>
            <td>Supreme</td>
            <td>3.0</td>
            <td>48.75</td>
            <td>Coarse Sicilian Salami, ...</td>
        </tr>
        <tr>
            <th>4</th>
            <td>01/06</td>
            <td>12</td>
            <td>spicy</td>
            <td>S</td>
            <td>Supreme</td>
            <td>3.0</td>
            <td>37.50</td>
            <td>Capocollo, Tomatoes, ...</td>
        </tr>
        </tbody>
    </table>
</div>

</section>

<section>
    <p>Самый простой способ создать новый признак – это выполнить арифметические операции уже с существующими столбцами. Например, у нас есть колонка <em>количество пицц в заказе</em> (<strong>quantity</strong>) и <em>стоимость заказа</em> (<strong>total_price</strong>), на их основе мы можем посчитать, сколько стоит одна пицца, разделив <strong>total_price</strong> на <strong>quantity</strong>. Назовем этот новый столбец со стоимостью одной пиццы <strong>unit_price:</strong></p>
            <pre class="line-numbers"><code class="language-python">df['unit_price'] = df['total_price']/df['quantity']  # создаем новый признак unit_price
df  # выводим датафрейм</code></pre>
<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
            <th>unit_price</th>
        </tr>
        </thead>
        <tbody>
        <tr>
<th>0</th>
<td>30/03</td>
<td>13</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>4.0</td>
<td>48.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
</tr>
<tr>
<th>1</th>
<td>19/09</td>
<td>14</td>
<td>cali</td>
<td>L</td>
<td>Chicken</td>
<td>4.0</td>
<td>83.00</td>
<td>Chicken, Artichoke, ...</td>
<td>20.75</td>
</tr>
<tr>
<th>2</th>
<td>19/05</td>
<td>12</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>4.0</td>
<td>48.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
</tr>
<tr>
<th>3</th>
<td>13/02</td>
<td>13</td>
<td>sicilian</td>
<td>M</td>
<td>Supreme</td>
<td>3.0</td>
<td>48.75</td>
<td>Coarse Sicilian Salami, ...</td>
<td>16.25</td>
</tr>
<tr>
<th>4</th>
<td>01/06</td>
<td>12</td>
<td>spicy</td>
<td>S</td>
<td>Supreme</td>
<td>3.0</td>
<td>37.50</td>
<td>Capocollo, Tomatoes, ...</td>
<td>12.50</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>48615</th>
<td>01/05</td>
<td>14</td>
<td>hawaiian</td>
<td>S</td>
<td>Classic</td>
<td>1.0</td>
<td>10.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>10.50</td>
</tr>
<tr>
<th>48616</th>
<td>01/05</td>
<td>14</td>
<td>spicy</td>
<td>S</td>
<td>Supreme</td>
<td>1.0</td>
<td>12.50</td>
<td>Capocollo, Tomatoes, ...</td>
<td>12.50</td>
</tr>
<tr>
<th>48617</th>
<td>01/05</td>
<td>14</td>
<td>veggie</td>
<td>S</td>
<td>Veggie</td>
<td>1.0</td>
<td>12.00</td>
<td>Mushrooms, Tomatoes, ...</td>
<td>12.00</td>
</tr>
<tr>
<th>48618</th>
<td>01/05</td>
<td>14</td>
<td>hawaiian</td>
<td>L</td>
<td>Classic</td>
<td>1.0</td>
<td>16.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>16.50</td>
</tr>
<tr>
<th>48619</th>
<td>01/05</td>
<td>13</td>
<td>five</td>
<td>L</td>
<td>Veggie</td>
<td>1.0</td>
<td>18.50</td>
<td>Mozzarella Cheese, ...</td>
<td>18.50</td>
</tr>

        </tbody>
    </table>
    </div>

    <p>В конец таблицы добавился новый признак <strong>unit_price</strong>, показывающий, сколько стоила одна пицца в каждом заказе.</p>
</section>

<section>
<div class="important-card">
    <div class="important-text">
        Названия столбцов датафрейма не могут повторяться. Создавая новый признак, убедитесь, что столбца с таким названием в данных еще нет.
    </div>
</div>
</section>
<div style="height: 50px;"></div>
<section><h2 id="chapter3-2">3.2 Что такое именованная функция?</h2></section>

<section>
    <p>
        Довольно часто в анализе приходится перекодировать какие-то признаки – тогда на помощь приходят функции. Один из вариантов функции – <em>именованная функция</em>, которая <strong>создается</strong> с помощью оператора <span class="code-chip">def</span>:
    </p>
    <p class="fake-code">
<span class="code-line">def название функции(аргумент):</span>
<span class="code-line">&emsp;if условие 1:</span>
<span class="code-line">&emsp;&emsp;return результат 1</span>
<span class="code-line">&emsp;elif условие 2:</span>
<span class="code-line">&emsp;&emsp;return результат 2</span>
<span class="code-line">&emsp;...</span>
<span class="code-line">&emsp;else:</span>
<span class="code-line">&emsp;&emsp;return результат N</span>
    </p>

    <p>
        Чтобы применить функцию и получить новый признак в датафрейме, нужно воспользоваться методом <span class="code-chip">.apply()</span>:
    </p>
    <p class="fake-code">
<span class="code-line">датафрейм['новый признак'] = датафрейм['признак'].apply(название функции)</span>
    </p>
</section>

<section>
    <p>
        В данных есть признак <strong>order_hour</strong>, который показывает, в каком часу был сделан заказ. Из него мы хотим создать новый признак, который будет показывать время заказа: <em>morning</em> до 12 часов, <em>day</em> до 17 часов, <em>evening</em> от 17 и позже. Для начала <strong>создадим</strong> функцию, в которой будет прописан этот алгоритм перекодирования:
    </p>
    <pre class="line-numbers"><code class="language-python">def recode(x):        # создаем функцию recode с аргументом x
  if x < 12:          # если заказ был сделан до 12
    return 'morning'  # вернуть morning
  elif x < 17:        # если заказ был сделан до 17
    return 'day'      # вернуть day
  else:               # во всех остальных случаях
    return 'evening'  # вернуть evening
</code></pre>
    <p>
        Аргумент <span class="code-chip">x</span> будет принимать значения того признака, к которому мы применим функцию <span class="code-chip">recode</span>.
    </p>
    <p>
        Теперь <strong>применим</strong> функцию <span class="code-chip">recode</span> к признаку <strong>order_hour</strong> c помощью метода <span class="code-chip">.apply()</span>, а результат работы запишем в новый столбец <strong>order_timeofday</strong>:
    </p>
    <pre class="line-numbers"><code class="language-python">df['order_timeofday'] = df['order_hour'].apply(recode)  # применяем функцию recode
df  # выводим датафрейм</code></pre>
<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
            <th>unit_price</th>
            <th>order_timeofday</th>
        </tr>
        </thead>
        <tbody>
            <tr>
<th>0</th>
<td>30/03</td>
<td>13</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>4.0</td>
<td>48.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>day</td>
</tr>
<tr>
<th>1</th>
<td>19/09</td>
<td>14</td>
<td>cali</td>
<td>L</td>
<td>Chicken</td>
<td>4.0</td>
<td>83.00</td>
<td>Chicken, Artichoke, ...</td>
<td>20.75</td>
<td>day</td>
</tr>
<tr>
<th>2</th>
<td>19/05</td>
<td>12</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>4.0</td>
<td>48.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>day</td>
</tr>
<tr>
<th>3</th>
<td>13/02</td>
<td>13</td>
<td>sicilian</td>
<td>M</td>
<td>Supreme</td>
<td>3.0</td>
<td>48.75</td>
<td>Coarse Sicilian Salami, ...</td>
<td>16.25</td>
<td>day</td>
</tr>
<tr>
<th>4</th>
<td>01/06</td>
<td>12</td>
<td>spicy</td>
<td>S</td>
<td>Supreme</td>
<td>3.0</td>
<td>37.50</td>
<td>Capocollo, Tomatoes, ...</td>
<td>12.50</td>
<td>day</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>48615</th>
<td>01/05</td>
<td>14</td>
<td>hawaiian</td>
<td>S</td>
<td>Classic</td>
<td>1.0</td>
<td>10.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>10.50</td>
<td>day</td>
</tr>
<tr>
<th>48616</th>
<td>01/05</td>
<td>14</td>
<td>spicy</td>
<td>S</td>
<td>Supreme</td>
<td>1.0</td>
<td>12.50</td>
<td>Capocollo, Tomatoes, ...</td>
<td>12.50</td>
<td>day</td>
</tr>
<tr>
<th>48617</th>
<td>01/05</td>
<td>14</td>
<td>veggie</td>
<td>S</td>
<td>Veggie</td>
<td>1.0</td>
<td>12.00</td>
<td>Mushrooms, Tomatoes, ...</td>
<td>12.00</td>
<td>day</td>
</tr>
<tr>
<th>48618</th>
<td>01/05</td>
<td>14</td>
<td>hawaiian</td>
<td>L</td>
<td>Classic</td>
<td>1.0</td>
<td>16.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>16.50</td>
<td>day</td>
</tr>
<tr>
<th>48619</th>
<td>01/05</td>
<td>13</td>
<td>five</td>
<td>L</td>
<td>Veggie</td>
<td>1.0</td>
<td>18.50</td>
<td>Mozzarella Cheese, ...</td>
<td>18.50</td>
<td>day</td>
</tr>
        </tbody>
        </table>
        </div>

    <p>
        К примеру, можно проверить, что функция действительно сработала, сделав фильтрацию, и таким образом найти все вечерние заказы (<em>evening</em>; <strong>order_timeofday</strong>):
    </p>
    <pre class="line-numbers"><code class="language-python">df[df['order_timeofday'] == 'evening']</code></pre>
    <div class="scrollable-table">    
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
            <th>unit_price</th>
            <th>order_timeofday</th>
        </tr>
        </thead>
        <tbody>
<tr>
<th>20</th>
<td>03/10</td>
<td>21</td>
<td>hawaiian</td>
<td>L</td>
<td>Classic</td>
<td>3.0</td>
<td>49.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>16.50</td>
<td>evening</td>
</tr>
<tr>
<th>23</th>
<td>04/05</td>
<td>18</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>3.0</td>
<td>36.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
</tr>
<tr>
<th>25</th>
<td>21/05</td>
<td>17</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>2.0</td>
<td>24.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
</tr>
<tr>
<th>39</th>
<td>08/01</td>
<td>17</td>
<td>ital</td>
<td>L</td>
<td>Classic</td>
<td>2.0</td>
<td>41.00</td>
<td>Capocollo, Red Peppers, ...</td>
<td>20.50</td>
<td>evening</td>
</tr>
<tr>
<th>50</th>
<td>04/10</td>
<td>18</td>
<td>southw</td>
<td>L</td>
<td>Chicken</td>
<td>2.0</td>
<td>41.50</td>
<td>Chicken, Tomatoes, ...</td>
<td>20.75</td>
<td>evening</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>48562</th>
<td>30/04</td>
<td>22</td>
<td>the</td>
<td>XL</td>
<td>Classic</td>
<td>1.0</td>
<td>25.50</td>
<td>Kalamata Olives, ...</td>
<td>25.50</td>
<td>evening</td>
</tr>
<tr>
<th>48571</th>
<td>30/04</td>
<td>21</td>
<td>five</td>
<td>L</td>
<td>Veggie</td>
<td>1.0</td>
<td>18.50</td>
<td>Mozzarella Cheese, ...</td>
<td>18.50</td>
<td>evening</td>
</tr>
<tr>
<th>48592</th>
<td>01/05</td>
<td>17</td>
<td>bbq</td>
<td>L</td>
<td>Chicken</td>
<td>1.0</td>
<td>20.75</td>
<td>Barbecued Chicken, ...</td>
<td>20.75</td>
<td>evening</td>
</tr>
<tr>
<th>48593</th>
<td>01/05</td>
<td>17</td>
<td>green</td>
<td>S</td>
<td>Veggie</td>
<td>1.0</td>
<td>12.00</td>
<td>Spinach, Mushrooms, ...</td>
<td>12.00</td>
<td>evening</td>
</tr>
<tr>
<th>48594</th>
<td>01/05</td>
<td>17</td>
<td>pepperoni</td>
<td>L</td>
<td>Classic</td>
<td>1.0</td>
<td>15.25</td>
<td>Mozzarella Cheese, Pepperoni</td>
<td>15.25</td>
<td>evening</td>
</tr>
<tr>
<td></td>
</tr>
        </tbody>
        </table>
        </div>
</section>

<section>
    <div style="height: 50px;"></div>
    <h2 id="chapter3-3">3.3 Что такое анонимная функция?</h2>
    <p>Именованная функция удобна, когда у нас 3 условия и более. Однако когда условий меньше, проще использовать <strong>анонимную</strong> функцию, которая реализуется с помощью оператора <span class="code-chip">lambda</span>. Она удобна тем, что ее можно <strong>сразу применить</strong> без предварительного создания:</p>
    <p class="fake-code">
<span class="code-line">датафрейм['новый признак'] = датафрейм['признак'].apply(lambda аргумент: результат 1 if условие else результат 2)</span>
    </p>
    <p>или</p>
    <p class="fake-code">
<span class="code-line">датафрейм['новый признак'] = датафрейм['признак'].apply(lambda аргумент: инструкция)</span>
    </p>
    <p>Например, мы хотим создать новый бинарный признак <strong>unit_price_recoded</strong> по следующему правилу: если цена пиццы (<strong>unit_price</strong>) более 20 долларов, то вернуть 1, иначе 0.</p>
    <pre class="line-numbers"><code class="language-python">df['unit_price_recoded'] = df['unit_price'].apply(lambda x: 1 if x > 20 else 0)
df</code></pre>
<p><span class="code-chip">df['unit_price_recoded']</span> - создаем новый признак <strong>unit_price_recoded</strong></p>
<p><span class="code-chip">df['unit_price']</span> - источник данных для функции</p>
<p><span class="code-chip">.apply()</span> - применяем функцию</p>
<p><span class="code-chip">lambda x:</span> - создаем анонимную функцию с аргументом <span class="code-chip">x</span></p>
<p><span class="code-chip">1 if x > 20 else 0</span> - вернуть <span class="code-chip">1</span> если <strong>unit_price</strong> больше 20, иначе вернуть <span class="code-chip">0</span></p>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
            <th>unit_price</th>
            <th>order_timeofday</th>
            <th>unit_price_recoded</th>
        </tr>
        </thead>
        <tbody>
<tr>
<th>20</th>
<td>03/10</td>
<td>21</td>
<td>hawaiian</td>
<td>L</td>
<td>Classic</td>
<td>3.0</td>
<td>49.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>16.50</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<th>23</th>
<td>04/05</td>
<td>18</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>3.0</td>
<td>36.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
<td>1</td>
</tr>
<tr>
<th>25</th>
<td>21/05</td>
<td>17</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>2.0</td>
<td>24.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<th>39</th>
<td>08/01</td>
<td>17</td>
<td>ital</td>
<td>L</td>
<td>Classic</td>
<td>2.0</td>
<td>41.00</td>
<td>Capocollo, Red Peppers, ...</td>
<td>20.50</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<th>50</th>
<td>04/10</td>
<td>18</td>
<td>southw</td>
<td>L</td>
<td>Chicken</td>
<td>2.0</td>
<td>41.50</td>
<td>Chicken, Tomatoes, ...</td>
<td>20.75</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>48562</th>
<td>30/04</td>
<td>22</td>
<td>the</td>
<td>XL</td>
<td>Classic</td>
<td>1.0</td>
<td>25.50</td>
<td>Kalamata Olives, ...</td>
<td>25.50</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<th>48571</th>
<td>30/04</td>
<td>21</td>
<td>five</td>
<td>L</td>
<td>Veggie</td>
<td>1.0</td>
<td>18.50</td>
<td>Mozzarella Cheese, ...</td>
<td>18.50</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<th>48592</th>
<td>01/05</td>
<td>17</td>
<td>bbq</td>
<td>L</td>
<td>Chicken</td>
<td>1.0</td>
<td>20.75</td>
<td>Barbecued Chicken, ...</td>
<td>20.75</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<th>48593</th>
<td>01/05</td>
<td>17</td>
<td>green</td>
<td>S</td>
<td>Veggie</td>
<td>1.0</td>
<td>12.00</td>
<td>Spinach, Mushrooms, ...</td>
<td>12.00</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<th>48594</th>
<td>01/05</td>
<td>17</td>
<td>pepperoni</td>
<td>L</td>
<td>Classic</td>
<td>1.0</td>
<td>15.25</td>
<td>Mozzarella Cheese, Pepperoni</td>
<td>15.25</td>
<td>evening</td>
<td>0</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>


</section>

<section>
    <p>Для создания новых признаков могут быть полезны операторы, функции и методы строк:</p>
    <div class="table-container">
    <table border="1" class="dataframe_new" style="width: 100%;">
        <thead>
        <tr style="text-align: right; width: 100%">
            <th>МЕТОД/ФУНКЦИЯ/ОПЕРАТОРЫ</th>
            <th>ОПИСАНИЕ</th>
        </tr>
        </thead>
        <tbody>
            <tr>
                <th><span class="code-chip">'строка' in x</span></th>
                <td>наличие 'строки' в объекте x</td>
            </tr>
            <tr>
                <th><span class="code-chip">x.count('строка')</span></th>
                <td>подсчет количества вхождение 'строки' в объект x</td>
            </tr>
            <tr>
                <th><span class="code-chip">len(x)</span></th>
                <td>длина объекта x</td>
            </tr>
        </tbody>
    </table>
    </div>

    <p>
        Например, мы хотим узнать, есть ли среди ингредиентов (<strong>pizza_ingredients</strong>) перец (<em>Pepper</em>). Другими словами, нужно проверить наличие <em>Pepper</em> в каждом значении признака <strong>pizza_ingredients</strong>. Если признак есть, вернуть 1, а иначе 0. Создадим для этого новый столбец <strong>pepper_check</strong>:
    </p>
        <pre class="line-numbers"><code class="language-python">df['pepper_check'] = df['pizza_ingredients'].apply(lambda x: 1 if 'Pepper' in x else 0)
df  # выводим датафрейм</code></pre>
    <p><span class="code-chip">df['pepper_check']</span> - создаем новый признак <strong>pepper_check</strong></p>
    <p><span class="code-chip">df['pizza_ingredients']</span> - источник данных для функции</p>
    <p><span class="code-chip">.apply()</span> - применяем функцию</p>
    <p><span class="code-chip">lambda x:</span> - создаем анонимную функцию с аргументом <span class="code-chip">x</span></p>
    <p><span class="code-chip">1 if 'Pepper' in x else 0</span> - вернуть <span class="code-chip">1</span> если <span class="code-chip">'Pepper'</span> в <strong>pizza_ingredients</strong>, иначе вернуть <span class="code-chip">0</span></p>
<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
            <th>unit_price</th>
            <th>order_timeofday</th>
            <th>unit_price_recoded</th>
            <th>pepper_check</th>
        </tr>
        </thead>
        <tbody>
<tr>
<th>20</th>
<td>03/10</td>
<td>21</td>
<td>hawaiian</td>
<td>L</td>
<td>Classic</td>
<td>3.0</td>
<td>49.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>16.50</td>
<td>evening</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<th>23</th>
<td>04/05</td>
<td>18</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>3.0</td>
<td>36.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<th>25</th>
<td>21/05</td>
<td>17</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>2.0</td>
<td>24.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<th>39</th>
<td>08/01</td>
<td>17</td>
<td>ital</td>
<td>L</td>
<td>Classic</td>
<td>2.0</td>
<td>41.00</td>
<td>Capocollo, Red Peppers, ...</td>
<td>20.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<th>50</th>
<td>04/10</td>
<td>18</td>
<td>southw</td>
<td>L</td>
<td>Chicken</td>
<td>2.0</td>
<td>41.50</td>
<td>Chicken, Tomatoes, ...</td>
<td>20.75</td>
<td>evening</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>48562</th>
<td>30/04</td>
<td>22</td>
<td>the</td>
<td>XL</td>
<td>Classic</td>
<td>1.0</td>
<td>25.50</td>
<td>Kalamata Olives, ...</td>
<td>25.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<th>48571</th>
<td>30/04</td>
<td>21</td>
<td>five</td>
<td>L</td>
<td>Veggie</td>
<td>1.0</td>
<td>18.50</td>
<td>Mozzarella Cheese, ...</td>
<td>18.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<th>48592</th>
<td>01/05</td>
<td>17</td>
<td>bbq</td>
<td>L</td>
<td>Chicken</td>
<td>1.0</td>
<td>20.75</td>
<td>Barbecued Chicken, ...</td>
<td>20.75</td>
<td>evening</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<th>48593</th>
<td>01/05</td>
<td>17</td>
<td>green</td>
<td>S</td>
<td>Veggie</td>
<td>1.0</td>
<td>12.00</td>
<td>Spinach, Mushrooms, ...</td>
<td>12.00</td>
<td>evening</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<th>48594</th>
<td>01/05</td>
<td>17</td>
<td>pepperoni</td>
<td>L</td>
<td>Classic</td>
<td>1.0</td>
<td>15.25</td>
<td>Mozzarella Cheese, Pepperoni</td>
<td>15.25</td>
<td>evening</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>

<p>Если мы хотим посчитать количество ингредиентов (<strong>pizza_ingredients</strong>) в каждой пицце, нам в этом поможет метод <span class="code-chip">.count()</span>. Можно заметить, что ингредиенты перечислены через запятую с пробелом:</p>
<div class="scrollable-table">    
<table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>pizza_ingredients</th>
            <th>КОЛИЧЕСТВО ИНГРЕДИЕНТОВ</th>
        </tr>
        </thead>
        <tbody>
            <tr>
                <td>ингредиент</td>
                <td>1</td>
            </tr>
            <tr>
                <td>ингредиент1, ингредиент2</td>
                <td>2</td>
            </tr>
            <tr>
                <td>ингредиент1, ингредиент2, ингредиент3</td>
                <td>3</td>
            </tr>
        </tbody>
    </table>
</div>

    <p>Если в значении нет запятых с пробелом, то вернуть 1, если есть одна запятая с пробелом, то вернуть 2 и т.д. Другими словами посчитать количество запятых с пробелом и прибавить 1 (<span class="code-chip">x.count(', ') + 1</span>). Создадим новый признак <strong>ingr_count</strong> по этой логике:</p>
    <pre class="line-numbers"><code class="language-python">df['ingr_count'] = df['pizza_ingredients'].apply(lambda x: x.count(', ') + 1)
df  # выводим датафрейм</code></pre>

<p><span class="code-chip">df['ingr_count']</span> - создаем новый признак <strong>ingr_count</strong></p>
<p><span class="code-chip">df['pizza_ingredients']</span> - источник данных для функции</p>
<p><span class="code-chip">.apply()</span> - применяем функцию</p>
<p><span class="code-chip">lambda x:</span> - создаем анонимную функцию с аргументом <span class="code-chip">x</span></p>
<p><span class="code-chip">x.count(', ') + 1</span> - вернет количество <span class="code-chip">', '</span> + 1 в значениях признака <strong>pizza_ingredients</strong></p>
<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
            <th>unit_price</th>
            <th>order_timeofday</th>
            <th>unit_price_recoded</th>
            <th>pepper_check</th>
            <th>ingr_count</th>
        </tr>
        </thead>
        <tbody>
<tr>
<th>20</th>
<td>03/10</td>
<td>21</td>
<td>hawaiian</td>
<td>L</td>
<td>Classic</td>
<td>3.0</td>
<td>49.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>16.50</td>
<td>evening</td>
<td>0</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<th>23</th>
<td>04/05</td>
<td>18</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>3.0</td>
<td>36.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
<td>1</td>
<td>1</td>
<td>7</td>
</tr>
<tr>
<th>25</th>
<td>21/05</td>
<td>17</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>2.0</td>
<td>24.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
<td>0</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<th>39</th>
<td>08/01</td>
<td>17</td>
<td>ital</td>
<td>L</td>
<td>Classic</td>
<td>2.0</td>
<td>41.00</td>
<td>Capocollo, Red Peppers, ...</td>
<td>20.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<th>50</th>
<td>04/10</td>
<td>18</td>
<td>southw</td>
<td>L</td>
<td>Chicken</td>
<td>2.0</td>
<td>41.50</td>
<td>Chicken, Tomatoes, ...</td>
<td>20.75</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>48562</th>
<td>30/04</td>
<td>22</td>
<td>the</td>
<td>XL</td>
<td>Classic</td>
<td>1.0</td>
<td>25.50</td>
<td>Kalamata Olives, ...</td>
<td>25.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<th>48571</th>
<td>30/04</td>
<td>21</td>
<td>five</td>
<td>L</td>
<td>Veggie</td>
<td>1.0</td>
<td>18.50</td>
<td>Mozzarella Cheese, ...</td>
<td>18.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<th>48592</th>
<td>01/05</td>
<td>17</td>
<td>bbq</td>
<td>L</td>
<td>Chicken</td>
<td>1.0</td>
<td>20.75</td>
<td>Barbecued Chicken, ...</td>
<td>20.75</td>
<td>evening</td>
<td>0</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<th>48593</th>
<td>01/05</td>
<td>17</td>
<td>green</td>
<td>S</td>
<td>Veggie</td>
<td>1.0</td>
<td>12.00</td>
<td>Spinach, Mushrooms, ...</td>
<td>12.00</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<th>48594</th>
<td>01/05</td>
<td>17</td>
<td>pepperoni</td>
<td>L</td>
<td>Classic</td>
<td>1.0</td>
<td>15.25</td>
<td>Mozzarella Cheese, Pepperoni</td>
<td>15.25</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>

<p>Когда нужно просто посчитать количество символов в строке, достаточно будет воспользоваться функцией <span class="code-chip">len()</span>. Посчитаем длину значений признака <strong>pizza_ingredients</strong>, а результат сохраним в новый столбец <strong>len_ingr</strong></p>
    <pre class="line-numbers"><code class="language-python">df['len_ingr'] = df['pizza_ingredients'].apply(lambda x: len(x))
df  # выводим датафрейм</code></pre>

<p><span class="code-chip">df['len_ingr']</span> - создаем новый признак <strong>ingr_count</strong></p>
<p><span class="code-chip">df['pizza_ingredients']</span> - источник данных для функции</p>
<p><span class="code-chip">.apply()</span> - применяем функцию</p>
<p><span class="code-chip">lambda x:</span> - создаем анонимную функцию с аргументом <span class="code-chip">x</span></p>
<p><span class="code-chip">len(x)</span> - вернет количество символов в значениях признака <strong>pizza_ingredients</strong></p>


<div class="scrollable-table">
        <table border="1" class="dataframe table-container">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
            <th>unit_price</th>
            <th>order_timeofday</th>
            <th>unit_price_recoded</th>
            <th>pepper_check</th>
            <th>ingr_count</th>
            <th>len_ingr</th>
        </tr>
        </thead>
        <tbody>
<tr>
<th>20</th>
<td>03/10</td>
<td>21</td>
<td>hawaiian</td>
<td>L</td>
<td>Classic</td>
<td>3.0</td>
<td>49.50</td>
<td>Sliced Ham, Pineapple, ...</td>
<td>16.50</td>
<td>evening</td>
<td>0</td>
<td>1</td>
<td>4</td>
<td>50</td>
</tr>
<tr>
<th>23</th>
<td>04/05</td>
<td>18</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>3.0</td>
<td>36.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
<td>1</td>
<td>1</td>
<td>7</td>
<td>83</td>
</tr>
<tr>
<th>25</th>
<td>21/05</td>
<td>17</td>
<td>big</td>
<td>S</td>
<td>Classic</td>
<td>2.0</td>
<td>24.00</td>
<td>Bacon, Pepperoni, ...</td>
<td>12.00</td>
<td>evening</td>
<td>0</td>
<td>1</td>
<td>4</td>
<td>50</td>
</tr>
<tr>
<th>39</th>
<td>08/01</td>
<td>17</td>
<td>ital</td>
<td>L</td>
<td>Classic</td>
<td>2.0</td>
<td>41.00</td>
<td>Capocollo, Red Peppers, ...</td>
<td>20.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td>80</td>
</tr>
<tr>
<th>50</th>
<td>04/10</td>
<td>18</td>
<td>southw</td>
<td>L</td>
<td>Chicken</td>
<td>2.0</td>
<td>41.50</td>
<td>Chicken, Tomatoes, ...</td>
<td>20.75</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td>71</td>
</tr>
<tr>
<th>...</th>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<th>48562</th>
<td>30/04</td>
<td>22</td>
<td>the</td>
<td>XL</td>
<td>Classic</td>
<td>1.0</td>
<td>25.50</td>
<td>Kalamata Olives, ...</td>
<td>25.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>40</td>
</tr>
<tr>
<th>48571</th>
<td>30/04</td>
<td>21</td>
<td>five</td>
<td>L</td>
<td>Veggie</td>
<td>1.0</td>
<td>18.50</td>
<td>Mozzarella Cheese, ...</td>
<td>18.50</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td>71</td>
</tr>
<tr>
<th>48592</th>
<td>01/05</td>
<td>17</td>
<td>bbq</td>
<td>L</td>
<td>Chicken</td>
<td>1.0</td>
<td>20.75</td>
<td>Barbecued Chicken, ...</td>
<td>20.75</td>
<td>evening</td>
<td>0</td>
<td>1</td>
<td>8</td>
<td>86</td>
</tr>
<tr>
<th>48593</th>
<td>01/05</td>
<td>17</td>
<td>green</td>
<td>S</td>
<td>Veggie</td>
<td>1.0</td>
<td>12.00</td>
<td>Spinach, Mushrooms, ...</td>
<td>12.00</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>40</td>
</tr>
<tr>
<th>48594</th>
<td>01/05</td>
<td>17</td>
<td>pepperoni</td>
<td>L</td>
<td>Classic</td>
<td>1.0</td>
<td>15.25</td>
<td>Mozzarella Cheese, Pepperoni</td>
<td>15.25</td>
<td>evening</td>
<td>0</td>
<td>0</td>
<td>6</td>
<td>92</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
</section>


<section><a href="https://edu.hse.ru/mod/quiz/view.php?id=1606511" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>
    <div style="height: 50px;"></div>
</section>
</div>

<div style="height: 0px; padding: 20px;"></div>
<div> <!-- ГЛАВА 4 -->
<section>
    <h1 style="font-size: 30px; color:#1e01da;" id="chapter4">Глава 4. Частотная таблица. Визуализация</h1>
    <div style="height: 10px;"></div>
    <h2 id="chapter4-1">4.1 Что такое частотная таблица?</h2>
</section>

<section>
    <p style="display:inline">
        Представьте, что мы управляем пиццерией и хотим понять, какие пиццы пользуются наибольшей популярностью у клиентов. Данные о заказах в течение года записаны в файле в </p><a style="display:inline" href="https://edu.hse.ru/mod/resource/view.php?id=1610926"><p style="display:inline">pizza.csv:</p></a>
            <div class="scrollable-table">
            <table border="1" class="dataframe_new" style="width: 100%;">
                <thead>
                <tr>
                    <th>Признак</th>
                    <th>Описание</th>
                    <th>Формат данных(.dtypes)</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <th>order_date</th>
                    <td>дата заказа (день/месяц)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>order_hour</th>
                    <td>час дня, в который сделан заказ</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>pizza_name_id</th>
                    <td>вид пиццы (hawaiian, pepperoni и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>pizza_size</th>
                    <td>размер пиццы (S, M, L и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>pizza_category</th>
                    <td>описание пиццы (Classic, Veggie и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>quantity</th>
                    <td>количество пицц</td>
                    <td>float64</td>
                </tr>
                <tr>
                    <th>total_price</th>
                    <td>стоимость заказа ($)</td>
                    <td>float64</td>
                </tr>                <tr>
                    <th>pizza_ingredients</th>
                    <td>ингридиенты</td>
                    <td>object</td>
                </tr>                <tr>
                    <th>delivery_price</th>
                    <td>стоимость доставки</td>
                    <td>float64</td>
                </tr>
                </tbody>
            </table>
            </div>
    <p>Одно <strong>наблюдение</strong> - это один <strong>заказ</strong>.</p>

    <pre class="line-numbers"><code class="language-python">import pandas as pd

df = pd.read_csv('pizza.csv')
df.head()</code></pre>
<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>order_date</th>
            <th>order_hour</th>
            <th>pizza_name_id</th>
            <th>pizza_size</th>
            <th>pizza_category</th>
            <th>quantity</th>
            <th>total_price</th>
            <th>pizza_ingredients</th>
        </tr>
        </thead>
        <tbody>

        <tr>
            <th>0</th>
            <td>30/03</td>
            <td>13</td>
            <td>big</td>
            <td>S</td>
            <td>Classic</td>
            <td>4.0</td>
            <td>48.00</td>
            <td>Bacon, Pepperoni, ...</td>
        </tr>
        <tr>
            <th>1</th>
            <td>19/09</td>
            <td>14</td>
            <td>cali</td>
            <td>L</td>
            <td>Chicken</td>
            <td>4.0</td>
            <td>83.00</td>
            <td>Chicken, Artichoke, ...</td>
        </tr>
        <tr>
            <th>2</th>
            <td>19/05</td>
            <td>12</td>
            <td>big</td>
            <td>S</td>
            <td>Classic</td>
            <td>4.0</td>
            <td>48.00</td>
            <td>Bacon, Pepperoni, ...</td>
        </tr>
        <tr>
            <th>3</th>
            <td>13/02</td>
            <td>13</td>
            <td>sicilian</td>
            <td>M</td>
            <td>Supreme</td>
            <td>3.0</td>
            <td>48.75</td>
            <td>Coarse Sicilian Salami, ...</td>
        </tr>
        <tr>
            <th>4</th>
            <td>01/06</td>
            <td>12</td>
            <td>spicy</td>
            <td>S</td>
            <td>Supreme</td>
            <td>3.0</td>
            <td>37.50</td>
            <td>Capocollo, Tomatoes, ...</td>
        </tr>
        </tbody>
    </table>
</div>

<p>Чтобы понять, какие пиццы (<strong>pizza_name_id</strong>) заказывают чаще, нужно построить <strong>частотную таблицу</strong>, которая отразит количество (частоту) случаев появления каждой пиццы в наших данных. Для построения частотной таблицы используется метод <span class="code-chip">.value_counts()</span>:</p>
<div style="height: 10px;"></div>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts()</span>
    </p>
<pre class="line-numbers"><code class="language-python">df['pizza_name_id'].value_counts()</code></pre>
<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>pizza_name_id</th>
            <th>count</th>
        </tr>
        </thead>
        <tbody>
<tr><td><strong>ital</strong></td><td>4238</td></tr>
<tr><td><strong>classic</strong></td><td>2416</td></tr>
<tr><td><strong>bbq</strong></td><td>2372</td></tr>
<tr><td><strong>spinach</strong></td><td>2372</td></tr>
<tr><td><strong>hawaiian</strong></td><td>2370</td></tr>
<tr><td><strong>pepperoni</strong></td><td>2369</td></tr>
<tr><td><strong>thai</strong></td><td>2315</td></tr>
<tr><td><strong>cali</strong></td><td>2302</td></tr>
<tr><td><strong>ckn</strong></td><td>1941</td></tr>
<tr><td><strong>sicilian</strong></td><td>1887</td></tr>
<tr><td><strong>spicy</strong></td><td>1887</td></tr>
<tr><td><strong>southw</strong></td><td>1885</td></tr>
<tr><td><strong>four</strong></td><td>1850</td></tr>
<tr><td><strong>big</strong></td><td>1811</td></tr>
<tr><td><strong>veggie</strong></td><td>1510</td></tr>
<tr><td><strong>mexicana</strong></td><td>1456</td></tr>
<tr><td><strong>napolitana</strong></td><td>1451</td></tr>
<tr><td><strong>prsc</strong></td><txd>1428</td></tr>
<tr><td><strong>peppr</strong></td><td>1422</td></tr>
<tr><td><strong>the</strong></td><td>1406</td></tr>
<tr><td><strong>five</strong></td><td>1359</td></tr>
<tr><td><strong>pep</strong></td><td>1342</td></tr>
<tr><td><strong>green</strong></td><td>987</td></tr>
<tr><td><strong>spin</strong></td><td>957</td></tr>
<tr><td><strong>soppressata</strong></td><td>957</td></tr>
<tr><td><strong>calabrese</strong></td><td>927</td></tr>
<tr><td><strong>mediterraneo</strong></td><td>923</td></tr>
<tr><td><strong>brie</strong></td><td>480</td></tr>
</tbody>
    </table>
</div>
</section>

<section>
    <div class="important-card">
        <div class="important-text">
            <strong>Частотная таблица</strong> - таблица, которая показывает, как часто встречаются разные значения или категории в исследуемом признаке. Чаще всего используется для анализа категориальных или дискретных количественных данных.
        </div>
    </div>
</section>

<section>
    <p>Любая сводная таблица, построенная с помощью метода <span class="code-chip">.value_counts()</span> имеет следующие свойства:</p>
        <ul>
            <li>
<p><strong>Формат серии (Series).</strong> В нашем случае <em>индексы</em> - это уникальные названия пицц (<strong>pizza_name_id</strong>), <em>значения</em> - это число заказов (строк), в которых встретилась каждая пицца. Например, неаполитанская пицца (<em>napolitana</em>; <strong>pizza_name_id</strong>) встретилась 1451 раз.</p>
            </li>
            <li>
<p><strong>Отсортирована по убыванию частоты значений.</strong> Первым будет идти значение, которое встретилось больше всего раз. В нашем случае это итальянская пицца (<em>ital</em>; <strong>pizza_name_id</strong>), она была в 4238 заказах. А последней будет идти категория, которая встречается реже всего. По нашим данным, это пицца с сыром бри (<em>brie</em>; <strong>pizza_name_id</strong>), она была в 480 заказах.</p>
            </li>
        </ul>
        <div style="height: 10px;"></div>
    <h2>СОРТИРОВКА ЧАСТОТНОЙ ТАБЛИЦЫ</h2>
    <p>Стандартную сортировку можно поменять. Если нужна сортировка по возрастанию частотности, то есть первой должна выводиться пицца, которая была в наименьшем количестве заказов, обратимся к методу <span class="code-chip">.sort_values()</span>:</p>

    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts().sort_values() # по возрастанию частотности</span>
    </p>

    <pre class="line-numbers"><code class="language-python">df['pizza_name_id'].value_counts().sort_values()</code></pre>

    <div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>pizza_name_id</th>
            <th>count</th>
        </tr>
        </thead>
        <tbody>
<tr><td><strong>brie</strong></td><td>480</td></tr>
<tr><td><strong>mediterraneo</strong></td><td>923</td></tr>
<tr><td><strong>calabrese</strong></td><td>927</td></tr>
<tr><td><strong>spin</strong></td><td>957</td></tr>
<tr><td><strong>soppressata</strong></td><td>957</td></tr>
<tr><td><strong>green</strong></td><td>987</td></tr>
<tr><td><strong>pep</strong></td><td>1342</td></tr>
<tr><td><strong>five</strong></td><td>1359</td></tr>
<tr><td><strong>the</strong></td><td>1406</td></tr>
<tr><td><strong>peppr</strong></td><td>1422</td></tr>
<tr><td><strong>prsc</strong></td><td>1428</td></tr>
<tr><td><strong>napolitana</strong></td><td>1451</td></tr>
<tr><td><strong>mexicana</strong></td><td>1456</td></tr>
<tr><td><strong>veggie</strong></td><td>1510</td></tr>
<tr><td><strong>big</strong></td><td>1811</td></tr>
<tr><td><strong>four</strong></td><td>1850</td></tr>
<tr><td><strong>southw</strong></td><td>1885</td></tr>
<tr><td><strong>sicilian</strong></td><td>1887</td></tr>
<tr><td><strong>spicy</strong></td><td>1887</td></tr>
<tr><td><strong>ckn</strong></td><td>1941</td></tr>
<tr><td><strong>cali</strong></td><td>2302</td></tr>
<tr><td><strong>thai</strong></td><td>2315</td></tr>
<tr><td><strong>pepperoni</strong></td><td>2369</td></tr>
<tr><td><strong>hawaiian</strong></td><td>2370</td></tr>
<tr><td><strong>bbq</strong></td><td>2372</td></tr>
<tr><td><strong>spinach</strong></td><td>2372</td></tr>
<tr><td><strong>classic</strong></td><td>2416</td></tr>
<tr><td><strong>ital</strong></td><td>4238</td></tr>
</tbody>
    </table>
    </div>
</section>

<section>
    <p>Если нужна сортировка по возрастанию индексов (отсортировать название пицц по алфавиту), используем метод <span class="code-chip">.sort_index()</span>:</p>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts().sort_index() # по возрастанию индексов</span>
    </p>

    <pre class="line-numbers"><code class="language-python">df['pizza_name_id'].value_counts().sort_index()</code></pre>

<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>pizza_name_id</th>
            <th>count</th>
        </tr>
        </thead>
        <tbody>
<tr><td><strong>bbq</strong></td><td>2372</td></tr>
<tr><td><strong>big</strong></td><td>1811</td></tr>
<tr><td><strong>brie</strong></td><td>480</td></tr>
<tr><td><strong>calabrese</strong></td><td>927</td></tr>
<tr><td><strong>cali</strong></td><td>2302</td></tr>
<tr><td><strong>ckn</strong></td><td>1941</td></tr>
<tr><td><strong>classic</strong></td><td>2416</td></tr>
<tr><td><strong>five</strong></td><td>1359</td></tr>
<tr><td><strong>four</strong></td><td>1850</td></tr>
<tr><td><strong>green</strong></td><td>987</td></tr>
<tr><td><strong>hawaiian</strong></td><td>2370</td></tr>
<tr><td><strong>ital</strong></td><td>4238</td></tr>
<tr><td><strong>mediterraneo</strong></td><td>923</td></tr>
<tr><td><strong>mexicana</strong></td><td>1456</td></tr>
<tr><td><strong>napolitana</strong></td><td>1451</td></tr>
<tr><td><strong>pep</strong></td><td>1342</td></tr>
<tr><td><strong>pepperoni</strong></td><td>2369</td></tr>
<tr><td><strong>peppr</strong></td><td>1422</td></tr>
<tr><td><strong>prsc</strong></td><td>1428</td></tr>
<tr><td><strong>sicilian</strong></td><td>1887</td></tr>
<tr><td><strong>soppressata</strong></td><td>957</td></tr>
<tr><td><strong>southw</strong></td><td>1885</td></tr>
<tr><td><strong>spicy</strong></td><td>1887</td></tr>
<tr><td><strong>spin</strong></td><td>957</td></tr>
<tr><td><strong>spinach</strong></td><td>2372</td></tr>
<tr><td><strong>thai</strong></td><td>2315</td></tr>
<tr><td><strong>the</strong></td><td>1406</td></tr>
<tr><td><strong>veggie</strong></td><td>1510</td></tr>
</tbody>
    </table>
    </div>
</section>

<section>
    <p>Для сортировки по убыванию индексов (отсортировать названия пицц в обратном алфавитном порядке) метод <span class="code-chip">.sort_index()</span> нужно использовать с параметром <span class="code-chip">ascending=False</span>:</p>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts().sort_index(ascending=False) # по убыванию индексов</span>
    </p>

    <pre class="line-numbers"><code class="language-python">df['pizza_name_id'].value_counts().sort_index(ascending=False)</code></pre>
    <div class="scrollable-table">    
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>pizza_name_id</th>
            <th>count</th>
        </tr>
        </thead>
        <tbody>
<tr><td><strong>veggie</strong></td><td>1510</td></tr>
<tr><td><strong>the</strong></td><td>1406</td></tr>
<tr><td><strong>thai</strong></td><td>2315</td></tr>
<tr><td><strong>spinach</strong></td><td>2372</td></tr>
<tr><td><strong>spin</strong></td><td>957</td></tr>
<tr><td><strong>spicy</strong></td><td>1887</td></tr>
<tr><td><strong>southw</strong></td><td>1885</td></tr>
<tr><td><strong>soppressata</strong></td><td>957</td></tr>
<tr><td><strong>sicilian</strong></td><td>1887</td></tr>
<tr><td><strong>prsc</strong></td><td>1428</td></tr>
<tr><td><strong>peppr</strong></td><td>1422</td></tr>
<tr><td><strong>pepperoni</strong></td><td>2369</td></tr>
<tr><td><strong>pep</strong></td><td>1342</td></tr>
<tr><td><strong>napolitana</strong></td><td>1451</td></tr>
<tr><td><strong>mexicana</strong></td><td>1456</td></tr>
<tr><td><strong>mediterraneo</strong></td><td>923</td></tr>
<tr><td><strong>ital</strong></td><td>4238</td></tr>
<tr><td><strong>hawaiian</strong></td><td>2370</td></tr>
<tr><td><strong>green</strong></td><td>987</td></tr>
<tr><td><strong>four</strong></td><td>1850</td></tr>
<tr><td><strong>five</strong></td><td>1359</td></tr>
<tr><td><strong>classic</strong></td><td>2416</td></tr>
<tr><td><strong>ckn</strong></td><td>1941</td></tr>
<tr><td><strong>cali</strong></td><td>2302</td></tr>
<tr><td><strong>calabrese</strong></td><td>927</td></tr>
<tr><td><strong>brie</strong></td><td>480</td></tr>
<tr><td><strong>big</strong></td><td>1811</td></tr>
<tr><td><strong>bbq</strong></td><td>2372</td></tr>
</tbody>
    </table>
    </div>
<div style="height: 10px;"></div>
    <h2>НОРМАЛИЗАЦИЯ ДАННЫХ ЧАСТОТНОЙ ТАБЛИЦЫ</h2>
    <p>Если мы хотим получить не абсолютные значени частотности (количество строк), а относительные, то есть долю каждой категории в данных, внутрь <span class="code-chip">.value_counts()</span>, нужно добавить параметр <span class="code-chip">normalize=True</span>:</p>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts(normalize=True) # доля каждой категории в данных</span>
    </p>

    <pre class="line-numbers"><code class="language-python">df['pizza_name_id'].value_counts(normalize=True)</code></pre>
    <div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>pizza_name_id</th>
            <th>proportion</th>
        </tr>
        </thead>
        <tbody>
<tr><td><strong>ital</strong></td><td>0.087166</td></tr>
<tr><td><strong>classic</strong></td><td>0.049691</td></tr>
<tr><td><strong>bbq</strong></td><td>0.048787</td></tr>
<tr><td><strong>spinach</strong></td><td>0.048787</td></tr>
<tr><td><strong>hawaiian</strong></td><td>0.048745</td></tr>
<tr><td><strong>pepperoni</strong></td><td>0.048725</td></tr>
<tr><td><strong>thai</strong></td><td>0.047614</td></tr>
<tr><td><strong>cali</strong></td><td>0.047347</td></tr>
<tr><td><strong>ckn</strong></td><td>0.039922</td></tr>
<tr><td><strong>sicilian</strong></td><td>0.038811</td></tr>
<tr><td><strong>spicy</strong></td><td>0.038811</td></tr>
<tr><td><strong>southw</strong></td><td>0.038770</td></tr>
<tr><td><strong>four</strong></td><td>0.038050</td></tr>
<tr><td><strong>big</strong></td><td>0.037248</td></tr>
<tr><td><strong>veggie</strong></td><td>0.031057</td></tr>
<tr><td><strong>mexicana</strong></td><td>0.029947</td></tr>
<tr><td><strong>napolitana</strong></td><td>0.029844</td></tr>
<tr><td><strong>prsc</strong></td><td>0.029371</td></tr>
<tr><td><strong>peppr</strong></td><td>0.029247</td></tr>
<tr><td><strong>the</strong></td><td>0.028918</td></tr>
<tr><td><strong>five</strong></td><td>0.027951</td></tr>
<tr><td><strong>pep</strong></td><td>0.027602</td></tr>
<tr><td><strong>green</strong></td><td>0.020300</td></tr>
<tr><td><strong>spin</strong></td><td>0.019683</td></tr>
<tr><td><strong>soppressata</strong></td><td>0.019683</td></tr>
<tr><td><strong>calabrese</strong></td><td>0.019066</td></tr>
<tr><td><strong>mediterraneo</strong></td><td>0.018984</td></tr>
<tr><td><strong>brie</strong></td><td>0.009872</td></tr>
</tbody>
    </table>
</div>
</section>


<section>
    <p>Доли не очень удобны для интерпретации, так как они меняются в диапазоне от 0 до 1. Но их несложно перевести в проценты, просто умножив на 100 нашу частотную таблицу:</p>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts(normalize=True) * 100  # процент каждой категории в данных</span>
    </p>

    <pre class="line-numbers"><code class="language-python">df['pizza_name_id'].value_counts(normalize=True) * 100</code></pre>
    <div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>pizza_name_id</th>
            <th>proportion</th>
        </tr>
        </thead>
        <tbody>
<tr><td><strong>ital</strong></td><td>8.716578</td></tr>
<tr><td><strong>classic</strong></td><td>4.969148</td></tr>
<tr><td><strong>bbq</strong></td><td>4.878651</td></tr>
<tr><td><strong>spinach</strong></td><td>4.878651</td></tr>
<tr><td><strong>hawaiian</strong></td><td>4.874537</td></tr>
<tr><td><strong>pepperoni</strong></td><td>4.872480</td></tr>
<tr><td><strong>thai</strong></td><td>4.761415</td></tr>
<tr><td><strong>cali</strong></td><td>4.734677</td></tr>
<tr><td><strong>ckn</strong></td><td>3.992184</td></tr>
<tr><td><strong>sicilian</strong></td><td>3.881119</td></tr>
<tr><td><strong>spicy</strong></td><td>3.881119</td></tr>
<tr><td><strong>southw</strong></td><td>3.877005</td></tr>
<tr><td><strong>four</strong></td><td>3.805019</td></tr>
<tr><td><strong>big</strong></td><td>3.724805</td></tr>
<tr><td><strong>veggie</strong></td><td>3.105718</td></tr>
<tr><td><strong>mexicana</strong></td><td>2.994652</td></tr>
<tr><td><strong>napolitana</strong></td><td>2.984369</td></tr>
<tr><td><strong>prsc</strong></td><td>2.937063</td></tr>
<tr><td><strong>peppr</strong></td><td>2.924722</td></tr>
<tr><td><strong>the</strong></td><td>2.891814</td></tr>
<tr><td><strong>five</strong></td><td>2.795146</td></tr>
<tr><td><strong>pep</strong></td><td>2.760181</td></tr>
<tr><td><strong>green</strong></td><td>2.030029</td></tr>
<tr><td><strong>spin</strong></td><td>1.968326</td></tr>
<tr><td><strong>soppressata</strong></td><td>1.968326</td></tr>
<tr><td><strong>calabrese</strong></td><td>1.906623</td></tr>
<tr><td><strong>mediterraneo</strong></td><td>1.898396</td></tr>
<tr><td><strong>brie</strong></td><td>0.987248</td></tr>
</tbody>
    </table>
</div>
    <p>Теперь сразу понятно, что итальянская пицца (<em>ital</em>; <strong>pizza_name_id</strong>) встретилась в 8.72% заказов, а пицца с сыром бри (<em>brie</em>; <strong>pizza_name_id</strong>) менее чем в 1%.</p>
</section>

<section>
    <div style="height: 50px;"></div>
    <h2 id="chapter4-2">4.2 Как визуализировать признаки в Pandas?</h2>
    <p>Визуализация - важнейший инструмент в анализе данных, помогающий наглядно увидеть ответы на свои вопросы и принять решения. Чтобы понять, как визуализировать тот или иной признак, нужно определить его тип (количественный или категориальный), и только после этого переходить к созданию визуализации. Для построения графиков мы будем использовать метод <span class="code-chip">.plot()</span>.</p>
    <img src="picture/6.svg" width="100%" alt="Рисунок 9">
    <h2>КОЛИЧЕСТВЕННЫЕ ПРИЗНАКИ</h2>
    <p>Одним из количественных признаков в наших данных является стоимость заказа (<strong>total_price</strong>). Чтобы его визуализировать, можно использовать два графика: <strong>гистограмма</strong> и <strong>ящик с усами</strong>.</p>
    <h3>Гистограмма</h3>
    <p>Это график, который представляет распределение данных в виде прямоугольников (интервалов) разной высоты. <strong>По горизонтальной оси (X)</strong> – диапазон значений количественного признака, разбитый на интервалы. <strong>По вертикальной оси (Y)</strong> – частота каждого интервала (Frequency).</p>
    <p>Чтобы построить гистограмму, нужно написать следуюший код:</p>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].plot(kind='hist')</span>
    </p>
    <p><span class="code-chip">kind='hist'</span> - тип графика (гистограмма)</p>

    <pre class="line-numbers"><code class="language-python">df['total_price'].plot(kind='hist')</code></pre>

    <img src="picture/4.2.1.png" width="70%" alt="Рисунок 1">

    <p>Какие выводы мы можем сделать на основе этого графика?</p>
    <ul>
        <li>
            <p>Стоимость заказов варьируется в диапазоне примерно от 10 до 80 долларов (<strong>горизонтальная ось (X)</strong>)</p>
        </li>
        <li>
            <p>Стоимость большинства заказов не превышает 20 долларов. Таких заказов около 30 тыс. (<strong>самый длинный прямоугольник</strong>)</p>
        </li>
    </ul>

    <p>При таком построении гистограммы данные автоматически разбиваются на 10 интервалов (прямоугольников), но если мы хотим рассмотреть распределение признака более подробно, можно увеличить количество интервалов, например, до 20 – это регулируется параметром <span class="code-chip">bins</span>:</p>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].plot(kind='hist', bins=количество интервалов)</span>
    </p>

    <pre class="line-numbers"><code class="language-python">df['total_price'].plot(kind='hist', bins=20)</code></pre>
    <img src="picture/4.2.2.png" width="70%" alt="Рисунок 2">

<h3>Ящик с усами</h3>
<p>График, который визуализирует основные описательные статистики количественного признака. <strong>По горизонтальной оси (X)</strong> – диапазон значений количественного признака.</p>
<p>Для его построения используем следуюший код:</p>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].plot(kind='box', vert=False)</span>
    </p>
    <p><span class="code-chip">kind = 'box'</span> - тип графика (ящик с усами)</p>
    <p><span class="code-chip">vert = False</span> - ящик с усами будет лежать горизонтально</p>

    <pre class="line-numbers"><code class="language-python">df['total_price'].plot(kind='box', vert=False)</code></pre>
    <img src="picture/4.2.3.png" width="70%" alt="Рисунок 3">
    <p>Какие выводы мы можем сделать на основе этого графика?</p>
    <ul>
        <li>
<p>Стоимость заказов варьируется в диапазоне, примерно, от 10 до 80 долларов (<strong>горизонтальная ось (X)</strong>)</p>
        </li>
    </ul>
    <p>На самом деле этот график несет гараздо больше информации, мы еще вернемся к нему в Главе 6 "Описательные статистики", а пока нам просто нужно научиться его строить и смотреть на диапазон значений количественного признака по горизонтальной оси.</p>
    <h3>Диаграмма рассеяния</h3>
    <p>Гистограмма и ящик с усами показывают <em>распределение одного</em> количественного признака, но если мы хотим посмотреть на <strong>зависимость двух количественных признаков</strong>, используется <strong>диаграмма рассеяния</strong>. Например, мы хотим посмотреть, как стоимость доставки (<strong>delivery_price</strong>) зависит от стоимости заказа (<strong>total_price</strong>) – тогда для построения диаграммы рассеяния применяем следующий синтаксис:</p>

    <p class="fake-code">
<span class="code-line">датафрейм.plot('признак по оси X', 'признак по оси Y', kind='scatter')</span>
    </p>

    <p><span class="code-chip">kind = 'scatter'</span>- тип графика (диаграмма рассеяния)</p>
    <pre class="line-numbers"><code class="language-python">df.plot('total_price', 'delivery_price', kind='scatter')</code></pre>

    <img src="picture/4.2.4.png" width="70%" alt="Рисунок 4">

    <p>Какие выводы мы можем сделать на основе этого графика?</p>
    <ul>
        <li>
            <p>С увеличением стоимости заказа (<strong>горизонтальная ось (X)</strong>) снижается стоимость доставки (<strong>вертикальная ось (Y)</strong>)</p>
        </li>
    </ul>
    <h3>Линейный график</h3>
    <p>Довольно часто в анализе возникает необходимость посмотреть динамику какого-нибудь количественного показателя на определенном временном отрезке. Сделать это можно с помощью линейного графика.</p>
    <p>В линейном графике <strong>по горизонтальной оси (X)</strong>, как правило, расположена временная шкала (даты, годы, месяцы и т.п.), а <strong>вертикальная ось (Y)</strong> отражает количественные значения (цены, численность, показатели производительности и т.д.).</p>
    <p>Мы хотим узнать, как меняется динамика количества заказов пиццы в течение дня (<strong>order_hour</strong>). Чтобы построить такой график, нужно сначала построить частотную таблицу с помощью метода <span class="code-chip">.value_counts()</span>, а уже к полученной частотной таблице применить метод <span class="code-chip">.plot()</span>, без каких либо параметров:</p>

    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts().plot()</span>
    </p>

    <p><span class="code-chip">датафрейм['признак'].value_counts()</span> - частотная таблица</p>
    <p><span class="code-chip">.plot()</span> - линейный график</p>

    <p>Сначала рассмотрим, как выглядит частотная таблица по часам заказа (<strong>order_hour</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['order_hour'].value_counts()</code></pre>

<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>order_hour</th>
            <th>count</th>
        </tr>
        </thead>
        <tbody>
<tr><td><strong>12</strong></td><td>6543</td></tr>
<tr><td><strong>13</strong></td><td>6203</td></tr>
<tr><td><strong>18</strong></td><td>5359</td></tr>
<tr><td><strong>17</strong></td><td>5143</td></tr>
<tr><td><strong>19</strong></td><td>4350</td></tr>
<tr><td><strong>16</strong></td><td>4185</td></tr>
<tr><td><strong>14</strong></td><td>3521</td></tr>
<tr><td><strong>20</strong></td><td>3487</td></tr>
<tr><td><strong>15</strong></td><td>3170</td></tr>
<tr><td><strong>11</strong></td><td>2672</td></tr>
<tr><td><strong>21</strong></td><td>2528</td></tr>
<tr><td><strong>22</strong></td><td>1370</td></tr>
<tr><td><strong>23</strong></td><td>68</td></tr>
<tr><td><strong>10</strong></td><td>17</td></tr>
<tr><td><strong>9</strong></td><td>4</td></tr>
</tbody>
    </table>
    </div>
</section>

<section>
    <p>В прошлом разделе мы обсудили, что метод <span class="code-chip">.value_counts()</span> автоматически сортирует таблицу по убыванию частотности – поэтому часы идут не по порядку, а по количеству заказов, совершенных в это время. Для построения графика часы нужно упорядочить, то есть отсортировать частотную таблицу по индексам с помощью метода <span class="code-chip">.sort_index()</span>:</p>

    <pre class="line-numbers"><code class="language-python">df['order_hour'].value_counts().sort_index()</code></pre>
<div class="scrollable-table">
            <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th>order_hour</th>
            <th>count</th>
        </tr>
        </thead>
        <tbody>
<tr><td><strong>9</strong></td><td>4</td></tr>
<tr><td><strong>10</strong></td><td>17</td></tr>
<tr><td><strong>11</strong></td><td>2672</td></tr>
<tr><td><strong>12</strong></td><td>6543</td></tr>
<tr><td><strong>13</strong></td><td>6203</td></tr>
<tr><td><strong>14</strong></td><td>3521</td></tr>
<tr><td><strong>15</strong></td><td>3170</td></tr>
<tr><td><strong>16</strong></td><td>4185</td></tr>
<tr><td><strong>17</strong></td><td>5143</td></tr>
<tr><td><strong>18</strong></td><td>5359</td></tr>
<tr><td><strong>19</strong></td><td>4350</td></tr>
<tr><td><strong>20</strong></td><td>3487</td></tr>
<tr><td><strong>21</strong></td><td>2528</td></tr>
<tr><td><strong>22</strong></td><td>1370</td></tr>
<tr><td><strong>23</strong></td><td>68</td></tr>
</tbody>
    </table>
</div>

    <p>Теперь мы можем построить <strong>линейный график</strong>, применив к отсортированной частотной таблице метод <span class="code-chip">.plot()</span>:</p>

    <pre class="line-numbers"><code class="language-python">df['order_hour'].value_counts().sort_index().plot()</code></pre>

    <img src="picture/4.2.5.png" width="70%" alt="Рисунок 5">

    <p>Какие выводы мы можем сделать на основе этого графика?</p>
    <ul>
        <li>
            <p>Большинство заказов делают в 12:00 и 18:00 часов (<strong>пики на графике</strong>)</p>
        </li>
        <li>
            <p>До 10:00 заказов практически нет</p>
        </li>
    </ul>

    <h2>КАТЕГОРИАЛЬНЫЕ ПРИЗНАКИ</h2>

    <p>Для визуализации категориальных данных используется два графика: <strong>круговая</strong> и <strong>столбчатая диаграмма</strong>. Рассмотрим их подробнее:</p>
    <h3>Круговая диаграмма</h3>
    <p>В таком графике данные представлены в виде круга, разделенного на секторы разного размера. Каждый сектор представляет собой долю от общего объема данных.</p>
    <p>Мы хотим узнать, как распределено количество заказов по категориям пиццы (<strong>pizza_category</strong>).Чтобы построить круговую диаграмму, как и в случае с линейным графиком, нужно сначала построить частотную таблицу, а уже к ней применить метод<br> <span class="code-chip">.plot()</span>:</p>

    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts().plot(kind='pie')</span>
    </p>

    <p><span class="code-chip">датафрейм['признак'].value_counts()</span> - частотная таблица</p>
    <p><span class="code-chip">kind = 'pie'</span> - тип графика (круговая диаграмма)</p>

    <pre class="line-numbers"><code class="language-python">df['pizza_category'].value_counts().plot(kind='pie')</code></pre>


    <img src="picture/4.2.6.png" width="70%" alt="Рисунок 6">

    <p>Если категорий в признаке достаточно много, круговая диаграмма будет не лучшим вариантом для его представления. Однако в нашем случае категорий пицц всего четыре, и такой тип графика будет уместен.</p>

    <h3>Столбчатая диаграмма</h3>
    <p>Она отображается в виде вертикальных (горизонтальных) полос разной высоты (ширины), каждая из которых соответствует отдельной категории или группе данных.</p>
    <p>Перед нами та же самая задача: визуализировать распределение числа заказов по категориям пиццы (<strong>pizza_category</strong>). Для этого мы в первую очередь вновь строим частотную таблицу, а только после этого строим график:</p>

    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts().plot(kind='bar')  # вертикальная</span>
    </p>
    <p>или</p>
    <p class="fake-code">
<span class="code-line">датафрейм['признак'].value_counts().plot(kind='barh')  # горизонтальная</span>
    </p>

    <p><span class="code-chip">датафрейм['признак'].value_counts()</span> - частотная таблица</p>
    <p><span class="code-chip">kind = 'bar'</span> / <span class="code-chip">kind = 'barh'</span> - тип графика (столбчатая диаграмма)</p>


    <p>Чтобы построить столбчатую диаграмму с вертикальными столбцами, нужно указать в методе <span class="code-chip">.plot()</span> параметр <span class="code-chip">kind='bar'</span>:</p>


    <img src="picture/4.2.7.png" width="70%" alt="Рисунок 7">


    <p>Если нужна столбчатая диаграмма с горизонтальными столбцами, нужно указать параметр <span class="code-chip">kind='barh'</span>. <span class="code-chip">h</span> в <span class="code-chip">barh</span> означает <em>horizontal</em> (горизонтальный):</p>


    <pre class="line-numbers"><code class="language-python">df['pizza_category'].value_counts().plot(kind='barh')</code></pre>

    <img src="picture/4.2.8.png" width="70%" alt="Рисунок 8">

</section>



<section><a href="https://edu.hse.ru/mod/quiz/view.php?id=1610931" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>&nbsp;<a href="https://edu.hse.ru/mod/quiz/view.php?id=1610932" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>
    <div style="height: 50px;"></div>
</section>
</div>

<div style="height: 0px; padding: 20px;"></div>
<div> <!-- ГЛАВА 5 -->
        <section>
        <h1 style="font-size: 30px; color:#1e01da;" id="chapter5">Глава 5. Агрегирование данных. Сводные таблицы</h1>
        <h2 id="chapter5-1">5.1 Что такое агрегирование данных?</h2>
        <p>В этом разделе мы познакомимся с важным инструментом анализа данных — агрегированием.</p>
        <div class="definition-card">
            <div class="definition-text">
                <strong>Агрегирование данных</strong> — это процесс преобразования множества отдельных значений в единые итоговые показатели путем расчета общих характеристик, таких как среднее, сумма и т.д.
            </div>
        </div>
        <p>Чтобы применить <strong>метод</strong> к <strong>признаку</strong> в <strong>датафрейме</strong>(<span class="code-chip">DataFrame</span>), нужно написать:</p>
        <p class="fake-code">
<span class="code-line">датафрейм['признак'].метод()</span>
        </p>
        <p>Если вы работаете с <strong>серией</strong>(<span class="code-chip">Series</span>):</p>
        <p class="fake-code">
<span class="code-line">серия.метод()</span>
        </p>
            <p style="font-size: 25px;"><strong>Методы агрегирования</strong></p>
        <p>Представим, что мы недавно открыли свою пиццерию и хотим проанализировать
            заказы клиентов за прошедший год, чтобы оптимизировать ассортимент и
            маркетинговую стратегию, и в итоге повысить прибыльность бизнеса. Для этого
            у нас есть набор данных pizza.csv</a>, включающий информацию о заказах пиццы за этот период:</p>
        <div class="scrollable-table">
            <table border="1" class="dataframe_new" style="width: 100%;">
                <thead>
                <tr>
                    <th>Признак</th>
                    <th>Описание</th>
                    <th>Формат данных(.dtypes)</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <th>order_date</th>
                    <td>дата заказа (день/месяц)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>order_hour</th>
                    <td>час дня, в который сделан заказ</td>
                    <td>int64</td>
                </tr>
                <tr>
                    <th>pizza_name_id</th>
                    <td>вид пиццы (hawaiian, pepperoni и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>pizza_size</th>
                    <td>размер пиццы (S, M, L и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>pizza_category</th>
                    <td>описание пиццы (Classic, Veggie и т.д.)</td>
                    <td>object</td>
                </tr>
                <tr>
                    <th>quantity</th>
                    <td>количество пицц</td>
                    <td>float64</td>
                </tr>
                <tr>
                    <th>total_price</th>
                    <td>стоимость заказа ($)</td>
                    <td>float64</td>
                </tr>                <tr>
                    <th>pizza_ingredients</th>
                    <td>ингредиенты</td>
                    <td>object</td>
                </tr>                <tr>
                    <th>delivery_price</th>
                    <td>стоимость доставки</td>
                    <td>float64</td>
                </tr>
                </tbody>
            </table>
        </div>
        <p>Одно <strong>наблюдение</strong> - это один <strong>заказ</strong>.</p>
        <pre class="line-numbers"><code class="language-python">import pandas as pd
df = pd.read_csv('pizza.csv')
df.head()</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>order_date</th>
                        <th>order_hour</th>
                        <th>pizza_name_id</th>
                        <th>pizza_size</th>
                        <th>pizza_category</th>
                        <th>quantity</th>
                        <th>total_price</th>
                        <th>pizza_ingredients</th>
                        <th>delivery_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th class="index-col">0</th>
                        <td>30/03</td>
                        <td>13</td>
                        <td>big</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>4.0</td>
                        <td>48.00</td>
                        <td>Bacon, Pepperoni...</td>
                        <td>30.86</td>
                    </tr>
                    <tr>
                        <th class="index-col">1</th>
                        <td>19/09</td>
                        <td>14</td>
                        <td>cali</td>
                        <td>L</td>
                        <td>Chicken</td>
                        <td>4.0</td>
                        <td>83.00</td>
                        <td>Chicken, Artichoke...</td>
                        <td>9.33</td>
                    </tr>
                    <tr>
                        <th class="index-col">2</th>
                        <td>19/05</td>
                        <td>12</td>
                        <td>big</td>
                        <td>S</td>
                        <td>Classic</td>
                        <td>4.0</td>
                        <td>48.00</td>
                        <td>Bacon, Pepperoni...</td>
                        <td>33.19</td>
                    </tr>
                    <tr>
                        <th class="index-col">3</th>
                        <td>13/02</td>
                        <td>13</td>
                        <td>sicilian</td>
                        <td>M</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>48.75</td>
                        <td>Coarse Sicilian Salami...</td>
                        <td>31.06</td>
                    </tr>
                    <tr>
                        <th class="index-col">4</th>
                        <td>01/06</td>
                        <td>12</td>
                        <td>spicy</td>
                        <td>S</td>
                        <td>Supreme</td>
                        <td>3.0</td>
                        <td>37.50</td>
                        <td>Capocollo, Tomatoes...</td>
                        <td>34.19</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Чтобы посмотреть самый дешевый заказ применим метод <span class="code-chip">.min()</span> к признаку <strong>total_price</strong>:</p>
            <pre class="line-numbers"><code class="language-python">df['total_price'].min()</code></pre>
            <div class="print_result">9.75</div>
            <p>Если нужно узнать стоимость самого дорогого заказа, то применим к этому же признаку метод <span class="code-chip">.max()</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['total_price'].max()</code></pre>
            <div class="print_result">83.0</div>
            <p>Для того чтобы посчитать среднюю стоимость заказа (<strong>total_price</strong>) используем метод <span class="code-chip">.mean()</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['total_price'].mean()</code></pre>
            <div class="print_result">np.float64(16.821473673385437)</div>
            <p>Функция <span class="code-chip">round(число, количество знаков после точки)</span> при необходимости округлит численный результат до нужного количества знаков:</p>
            <pre class="line-numbers"><code class="language-python">round(df['total_price'].mean(), 2) # округляем среднее до сотых</code></pre>
            <div class="print_result">np.float64(16.82)</div>
            <p>В наших данных одно наблюдение - это один заказ. Применив метод <span class="code-chip">.sum()</span> к признаку <strong>quantity</strong>, можно узнать, <em>сколько всего пицц</em> сделала пиццерия за год:</p>
            <pre class="line-numbers"><code class="language-python">df['quantity'].sum()</code></pre>
            <div class="print_result">np.float64(49574.0)</div>
            <p>Чтобы узнать, <em>сколько видов пицц</em> можно заказать, применим метод <span class="code-chip">.nunique()</span> к <strong>pizza_name_id</strong>. Он подсчитывает количество уникальных значений признака</p>
            <pre class="line-numbers"><code class="language-python">df['pizza_name_id'].nunique()</code></pre>
            <div class="print_result">28</div>
            <p>Применив метод <span class="code-chip">.count()</span>, можно узнать количество непропущенных значений (не NaN) признака:</p>
            <pre class="line-numbers"><code class="language-python">df['pizza_category'].count()</code></pre>
            <div class="print_result">np.int64(48603)</div>
            <p>В данных есть описание (<strong>pizza_category</strong>) 48603 заказов. Сравнив это число с <em>общей длиной датафрейма</em> (<span class="code-chip">.shape[0]</span>), можно понять, есть ли в признаке пропуски:</p>
            <pre class="line-numbers"><code class="language-python">df.shape[0]</code></pre>
            <div class="print_result">48620</div>
            <p>Всего за год было сделано 48620 заказов, но описание есть только у 48603 – значит в <strong>pizza_category</strong> 17 пропусков (NaN).</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe_new" style="width: 100%;">
                    <thead>
                    <tr>
                        <th>МЕТОД</th>
                        <th>ОПИСАНИЕ</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <th><span class="code-chip">.min()</span></th>
                        <td>наименьшее значение</td>
                    </tr>
                    <tr>
                        <th><span class="code-chip">.max()</span></th>
                        <td>наибольшее значение</td>
                    </tr>
                    <tr>
                        <th><span class="code-chip">.mean()</span></th>
                        <td>среднее арифметическое</td>
                    </tr>
                    <tr>
                        <th><span class="code-chip">.sum()</span></th>
                        <td>сумма</td>
                    </tr>
                    <tr>
                        <th><span class="code-chip">.nunique()</span></th>
                        <td>количество уникальных значений</td>
                    </tr>
                    <tr>
                        <th><span class="code-chip">.count()</span></th>
                        <td>количество непропущенных значений</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Разумеется, это лишь начальные шаги в мире методов агрегирования данных. Более подробно и полно мы раскроем тему в Главе 6 "Описательные статистики".</p>
            <p style="font-size: 25px;"><strong>Фильтрация и агрегирование</strong></p>
            <p>Методы агрегирования можно применить и к отфильтрованным данным. В общем виде это выглядит так:</p>
            <p class="fake-code">
<span class="code-line">датафрейм[условие фильтрации]['признак'].метод()</span>
            </p>
            <p>До этого мы считали, сколько всего пицц испекли
                за год (<span class="code-chip">df['quantity'].sum()</span>). Но предположим, теперь нас интересует,
                сколько конкретно гавайских пицц (<em>hawaiian</em>; <strong>pizza_name_id</strong>) было приготовлено нашим рестораном:</p>
            <pre class="line-numbers"><code class="language-python">df[df['pizza_name_id'] == 'hawaiian']['quantity'].sum()</code></pre>
            <div class="print_result">np.float64(2422.0)</div>
            <p><span class="code-chip">df[df['pizza_name_id'] == 'hawaiian']</span> - фильтруем данные и оставляем заказы только с гавайской пиццей.</p>
            <p><span class="code-chip">['quantity'].sum()</span> - в отфильтрованных данных обращаемся к признаку quantity и ищем суммарное количество заказанных пицц.</p>
            <p>Агрегированные значения могут выступать и условием фильтрации. Например, мы хотим посчитать количество заказов, стоимость которых (<strong>total_price</strong>) больше среднего:</p>
            <pre class="line-numbers"><code class="language-python">df[df['total_price'] > df['total_price'].mean()].shape[0]</code></pre>
            <div class="print_result">18496</div>
            <p><span class="code-chip">df[df['total_price'] > df['total_price'].mean()]</span> - фильтруем данные и оставляем заказы, стоимость которых выше среднего (<span class="code-chip">df['total_price'].mean()</span>)</p>
            <p><span class="code-chip">.shape[0]</span> - считаем количество строк (заказов) после фильтрации.</p>
            <div style="height: 10px;"></div>

            <h2 id="chapter5-2">5.2 Что такое сводная таблица?</h2>
            <p>В прошлом разделе мы посмотрели, сколько гавайских пицц
                (<em>hawaiian</em>; <strong>pizza_name_id</strong>) было приготовлено:</p>
            <pre class="line-numbers"><code class="language-python">df[df['pizza_name_id'] == 'hawaiian']['quantity'].sum()</code></pre>
            <div class="print_result">np.float64(2422.0)</div>
            <p>Но что, если нам нужно посчитать количество пицц каждого вида?
                Тогда нам придется делать 28 (<span class="code-chip">df['pizza_name_id'].nunique()</span>)
                фильтраций с агрегированием. Это долго и не очень удобно,
                гораздо разумнее будет сгруппировать данные с помощью метода <span class="code-chip">.groupby()</span>,
                который построит <strong>сводную таблицу</strong>, в которой будет посчитано количество пицц
                (<strong>quantity</strong>) каждого вида (<strong>pizza_name_id</strong>):</p>
            <pre class="line-numbers"><code class="language-python">df.groupby('pizza_name_id')['quantity'].sum()</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th>pizza_name_id</th>
                        <th>quantity</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>bbq</strong></td>
                        <td>2432.0</td>
                    </tr>
                    <tr>
                        <td><strong>big</strong></td>
                        <td>1914.0</td>
                    </tr>
                    <tr>
                        <td><strong>brie</strong></td>
                        <td>490.0</td>
                    </tr>
                    <tr>
                        <td><strong>calabrese</strong></td>
                        <td>937.0</td>
                    </tr>
                    <tr>
                        <td><strong>cali</strong></td>
                        <td>2370.0</td>
                    </tr>
                    <tr>
                        <td><strong>ckn</strong></td>
                        <td>1960.0</td>
                    </tr>
                    <tr>
                        <td><strong>classic</strong></td>
                        <td>2453.0</td>
                    </tr>
                    <tr>
                        <td><strong>five</strong></td>
                        <td>1409.0</td>
                    </tr>
                    <tr>
                        <td><strong>four</strong></td>
                        <td>1902.0</td>
                    </tr>
                    <tr>
                        <td><strong>green</strong></td>
                        <td>997.0</td>
                    </tr>
                    <tr>
                        <td><strong>hawaiian</strong></td>
                        <td>2422.0</td>
                    </tr>
                    <tr>
                        <td><strong>ital</strong></td>
                        <td>4303.0</td>
                    </tr>
                    <tr>
                        <td><strong>mediterraneo</strong></td>
                        <td>934.0</td>
                    </tr>
                    <tr>
                        <td><strong>mexicana</strong></td>
                        <td>1484.0</td>
                    </tr>
                    <tr>
                        <td><strong>napolitana</strong></td>
                        <td>1464.0</td>
                    </tr>
                    <tr>
                        <td><strong>pep</strong></td>
                        <td>1359.0</td>
                    </tr>
                    <tr>
                        <td><strong>pepperoni</strong></td>
                        <td>2418.0</td>
                    </tr>
                    <tr>
                        <td><strong>peppr</strong></td>
                        <td>1446.0</td>
                    </tr>
                    <tr>
                        <td><strong>prsc</strong></td>
                        <td>1457.0</td>
                    </tr>
                    <tr>
                        <td><strong>sicilian</strong></td>
                        <td>1938.0</td>
                    </tr>
                    <tr>
                        <td><strong>soppressata</strong></td>
                        <td>961.0</td>
                    </tr>
                    <tr>
                        <td><strong>southw</strong></td>
                        <td>1917.0</td>
                    </tr>
                    <tr>
                        <td><strong>spicy</strong></td>
                        <td>1924.0</td>
                    </tr>
                    <tr>
                        <td><strong>spin</strong></td>
                        <td>970.0</td>
                    </tr>
                    <tr>
                        <td><strong>spinach</strong></td>
                        <td>2396.0</td>
                    </tr>
                    <tr>
                        <td><strong>thai</strong></td>
                        <td>2371.0</td>
                    </tr>
                    <tr>
                        <td><strong>the</strong></td>
                        <td>1420.0</td>
                    </tr>
                    <tr>
                        <td><strong>veggie</strong></td>
                        <td>1526.0</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <div class="definition-card">
                <div class="definition-text">
                    <strong>Сводная таблица</strong> — это специализированный инструмент, предназначенный для группировки и агрегирования данных по одному или нескольким признакам (таким как регион, товар, временные периоды и т.д.).
                </div>
            </div>
            <p style="font-size: 25px;"><strong>ПРОСТЕЙШАЯ ГРУППИРОВКА</strong></p>
            <p>Самый простой вариант группировки – это когда мы хотим разделить данные по категориям одного признака
                (<span class="code-chip">'столбец группировки'</span>), и для каждой категории агрегируем один признак <br>
                (<span class="code-chip">'столбец агрегирования'</span>):</p>
            <p class="fake-code">
<span class="code-line"> датафрейм.groupby('столбец группировки')['столбец агрегирования'].метод()</span>
            </p>
            <p><span class="code-chip">'столбец группировки'</span> - это признак, по которому мы разделяем датафрейм на группы.</p>
            <p><span class="code-chip">'столбец агрегирования' (столбец интереса)</span> -
                это признак, значения которого будут подвергнуты дальнейшей обработке внутри каждой группы.</p>
            <p><span class="code-chip">.метод()</span> - то, как нужно обработать <span class="code-chip">'столбец агрегирования'</span></p>
            <p>Если нам нужно рассчитать, сколько пицц (<strong>quantity</strong>) разного размера (<strong>pizza_size</strong>) было изготовлено:</p>
            <pre class="line-numbers"><code class="language-python">df.groupby('pizza_size')['quantity'].sum()</code></pre>
            <p><span class="code-chip">.groupby('pizza_size'</span>) группирует все данные по размеру пиццы. Это значит, что все пиццы одного размера будут собраны в одну группу.</p>
            <p>Внутри каждой группы выбирается столбец <span class="code-chip">['quantity']</span>, который содержит количество пицц.</p>
            <p>Применяя метод <span class="code-chip">.sum()</span>, мы суммируем количество пицц в каждой группе (каждом размере).</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th>pizza_size</th>
                        <th>quantity</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>L</td>
                        <td>18956.0</td>
                    </tr>
                    <tr>
                        <td>M</td>
                        <td>15635.0</td>
                    </tr>
                    <tr>
                        <td>S</td>
                        <td>14403.0</td>
                    </tr>
                    <tr>
                        <td>XL</td>
                        <td>552.0</td>
                    </tr>
                    <tr>
                        <td>XXL</td>
                        <td>28.0</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Полученная сводная таблица имеет формат серии (<strong>Series</strong>): индексы - <strong>pizza_size</strong>, значения - <strong>quantity</strong>.</p>
            <p style="font-size: 25px;"><strong>НЕСКОЛЬКО СТОЛБЦОВ ГРУППИРОВКИ</strong></p>
            <p>Можно разделить данные по категориям и подкатегории на основании нескольких признаков (<span class="code-chip">'ст. группировки 1'</span> - основная группа, <span class="code-chip">'ст. группировки 2', ...</span> - подгруппы):</p>
            <p class="fake-code">
<span class="code-line">датафрейм.groupby(['ст. группировки 1', 'ст. группировки 2', ...])['столбец агрегирования'].метод()</span>
            </p>
            <p><span class="code-chip">['ст. группировки 1', 'ст. группировки 2', ...]</span> - это признаки, по котором мы разделяем <span class="code-chip">датафрейм</span> на группы.</p>
            <p><span class="code-chip">'столбец агрегирования'</span> (столбец интереса) - это признак, значения которого будут подвергнуты дальнейшей обработке внутри каждой группы и подгруппы.</p>
            <p><span class="code-chip">.метод()</span> - то, как нужно обработать <span class="code-chip">'столбец агрегирования'</span></p>
            <p>Чтобы выяснить, сколько пицц (<strong>quantity)</strong>) каждого конкретного вида (<strong>pizza_name_id</strong>) и размера (<strong>pizza_size</strong>) было изготовлено, нужно написать следующий код:</p>
            <pre class="line-numbers"><code class="language-python">df.groupby(['pizza_name_id', 'pizza_size'])['quantity'].sum()</code></pre>
            <p><span class="code-chip">.groupby(['pizza_name_id', 'pizza_size'])</span> группирует все данные по виду и размеру пиццы</p>
            <p>Внутри каждой группы выбирается столбец <span class="code-chip">['quantity']</span>, который содержит количество пицц соответствующего вида и размера.</p>
            <p>Применяя метод <span class="code-chip">.sum()</span>, мы суммируем количество пицц в каждой группе (каждом виде и размере).</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th>Pizza</th>
                        <th>Size</th>
                        <th>Price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td rowspan="3" class="pizza-name">bbq</td>
                        <td class="size">L</td>
                        <td class="price">992.0</td>
                    </tr>
                    <tr>
                        <td class="size">M</td>
                        <td class="price">956.0</td>
                    </tr>
                    <tr>
                        <td class="size">S</td>
                        <td class="price">484.0</td>
                    </tr>
                    <tr>
                        <td class="pizza-name">big</td>
                        <td class="size">S</td>
                        <td class="price">1914.0</td>
                    </tr>
                    <tr>
                        <td class="pizza-name">brie</td>
                        <td class="size">S</td>
                        <td class="price">490.0</td>
                    </tr>
                    <tr>
                        <td rowspan="2" class="pizza-name">the</td>
                        <td class="size">XL</td>
                        <td class="price">552.0</td>
                    </tr>
                    <tr>
                        <td class="size">XXL</td>
                        <td class="price">28.0</td>
                    </tr>
                    <tr>
                        <td rowspan="3" class="pizza-name">veggie</td>
                        <td class="size">L</td>
                        <td class="price">427.0</td>
                    </tr>
                    <tr>
                        <td class="size">M</td>
                        <td class="price">635.0</td>
                    </tr>
                    <tr>
                        <td class="size">S</td>
                        <td class="price">464.0</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p style="font-size: 25px;"><strong>НЕСКОЛЬКО СТОЛБЦОВ АГРЕГИРОВАНИЯ</strong></p>
            <p>Для каждой группы можно агрегировать несколько признаков   (<span class="code-chip">'ст. агрегирования N'</span>). Их нужно передать в формате списка:</p>
            <p class="fake-code">
<span class="code-line">датафрейм.groupby('столбец группировки')[['ст. агрегирования 1', 'ст. агрегирования 2', ...]].метод()</span>
            </p>
            <p><span class="code-chip">'столбец группировки'</span> - это признак, по которому мы разделяем датафрейм на группы.</p>
            <p><span class="code-chip">['ст. агрегирования 1', 'ст. агрегирования 2', ...]</span> (столбцы интереса) - это признаки, значения которых будут подвергнуты дальнейшей обработке внутри каждой группы.</p>
            <p><span class="code-chip">.метод()</span> - то, как нужно обработать <span class="code-chip">['ст. агрегирования 1', 'ст. агрегирования 2', ...]</span></p>
            <p>Если мы хотим создать сводную таблицу, в которой будeт посчитана выручка от всех заказов (сумма по признаку <strong>total_price</strong>)
                и общее количество приготовленных пицц (<strong>quantity</strong>) каждого размера, то пишем следующий код:</p>
            <pre class="line-numbers"><code class="language-python">df.groupby('pizza_size')[['total_price', 'quantity']].sum()</code></pre>
            <p><span class="code-chip">.groupby('pizza_size')</span> группирует все данные по размеру пиццы</p>
            <p>Внутри каждой группы выбираем столбцы <span class="code-chip">['total_price', 'quantity']</span>, которые содержат информацию стоимости заказа и количество пицц в них.</p>
            <p>Применяя метод <span class="code-chip">.sum()</span>, мы суммируем значения <strong>total_price</strong> и количество пицц (<strong>quantity</strong>) в каждой группе (<strong>pizza_size</strong>).</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th>pizza_size</th>
                        <th>total_price</th>
                        <th>quantity</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>L</td>
                        <td>375318.70</td>
                        <td>18956.0</td>
                    </tr>
                    <tr>
                        <td>M</td>
                        <td>249382.25</td>
                        <td>15635.0</td>
                    </tr>
                    <tr>
                        <td>S</td>
                        <td>178076.50</td>
                        <td>14403.0</td>
                    </tr>
                    <tr>
                        <td>XL</td>
                        <td>14076.00</td>
                        <td>552.0</td>
                    </tr>
                    <tr>
                        <td>XXL</td>
                        <td>1006.60</td>
                        <td>28.0</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Полученная сводная таблица имеет
                формат датафрейма (<strong>DataFrame</strong>): индексы - <strong>pizza_size</strong>, значения - сумма по <strong>total_price</strong> и <strong>quantity</strong>.</p>
            <p>Также из нее можно получить дополнительную полезную информацию — сколько в среднем зарабатывает наше заведение на каждой пицце определенного размера. Для этого сохраним сводную таблицу в новой переменной <span class="code-chip">gb1</span>, а затем добавим новый признак <strong>revenue</strong>, который будет
                рассчитан как отношение общей выручки от заказа (<strong>total_price</strong>) к количеству пицц в заказе (<strong>quantity</strong>):</p>
            <pre class="line-numbers"><code class="language-python"># Сохраням сводную таблицу в переменную gb
gb1 = df.groupby('pizza_size')[['total_price', 'quantity']].sum()

# Считаем выручку от одной пиццы в каждом размере
gb1['revenue'] = gb1['total_price']/gb1['quantity']

# Выводим сводную таблицу
gb1</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th>pizza_size</th>
                        <th>total_price</th>
                        <th>quantity</th>
                        <th>revenue</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>L</td>
                        <td>375318.70</td>
                        <td>18956.0</td>
                        <td>19.799467</td>
                    </tr>
                    <tr>
                        <td>M</td>
                        <td>249382.25</td>
                        <td>15635.0</td>
                        <td>15.950256</td>
                    </tr>
                    <tr>
                        <td>S</td>
                        <td>178076.50</td>
                        <td>14403.0</td>
                        <td>12.363848</td>
                    </tr>
                    <tr>
                        <td>XL</td>
                        <td>14076.00</td>
                        <td>552.0</td>
                        <td>25.500000</td>
                    </tr>
                    <tr>
                        <td>XXL</td>
                        <td>1006.60</td>
                        <td>28.0</td>
                        <td>35.950000</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Мы видим, что в одна пицца размера <em>S</em> приносит,
                в среднем, выручку в размере <em>12.36</em> долларов. А, например,
                пицца в размере <em>XXL</em>, в среднем, <em>36.95</em> долларов.</p>
            <p>При необходимости сводную таблицу (<span class="code-chip">gb1</span>), можно отсортировать по любому
                признаку с помощью метода <span class="code-chip">.sort_values()</span>. Сделаем это по признаку <strong>revenue</strong>:</p>

            <pre class="line-numbers"><code class="language-python">gb1.sort_values('revenue')</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th>pizza_size</th>
                        <th>total_price</th>
                        <th>quantity</th>
                        <th>revenue</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>S</td>
                        <td>178076.50</td>
                        <td>14403.0</td>
                        <td>12.363848</td>
                    </tr>
                    <tr>
                        <td>M</td>
                        <td>249382.25</td>
                        <td>15635.0</td>
                        <td>15.950256</td>
                    </tr>
                    <tr>
                        <td>L</td>
                        <td>375318.70</td>
                        <td>18956.0</td>
                        <td>19.799467</td>
                    </tr>
                    <tr>
                        <td>XL</td>
                        <td>14076.00</td>
                        <td>552.0</td>
                        <td>25.500000</td>
                    </tr>
                    <tr>
                        <td>XXL</td>
                        <td>1006.60</td>
                        <td>28.0</td>
                        <td>35.950000</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p style="font-size: 25px;"><strong>НЕСКОЛЬКО МЕТОДОВ АГРЕГИРОВАНИЯ</strong></p>
            <p>Чтобы во время группировки применить
                сразу несколько методов агрегирования, нужно воспользоваться методом <span class="code-chip">.agg()</span>:</p>
            <p class="fake-code">
<span class="code-line">датафрейм.groupby('столбец группировки')['столбец агрегирования'].agg(['метод 1', 'метод 2', ...])</span>
            </p>
            <p><span class="code-chip">'столбец группировки'</span> - это признак, по которому мы разделяем датафрейм на группы.</p>
            <p><span class="code-chip">'столбец агрегирования'</span> - это признак, значения которого будут подвергнуты дальнейшей обработке внутри каждой группы.</p>
            <p><span class="code-chip">['метод 1', 'метод 2', ...]</span> - методы, которые нужно применить к <span class="code-chip">'столбцу агрегирования'</span></p>
            <p>Чтобы узнать стоимость самого дорого и дешевого заказа (<strong>total_price</strong>)
                для каждого размера пиццы (<strong>pizza_size</strong>), необходимо сделать следующую группировку:</p>
            <p class="fake-code">
<span class="code-line">df.groupby('pizza_size')['total_price'].agg(['min', 'max'])</span>
            </p>
            <p><span class="code-chip">.groupby('pizza_size')</span> группирует все данные по размеру пиццы.
                Это значит, что все пиццы одного размера будут собраны в одну группу.</p>
            <p>Внутри каждой группы выбирается столбец <span class="code-chip">['total_price']</span>, который содержит цену каждого заказа.</p>
            <p>С помощью <span class="code-chip">.agg(['min', 'max'])</span> находим самую дешевую и дорогую пиццу в каждой группе (каждом размере).</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th>pizza_size</th>
                        <th>min_price</th>
                        <th>max_price</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>L</td>
                        <td>15.25</td>
                        <td>83.00</td>
                    </tr>
                    <tr>
                        <td>M</td>
                        <td>12.50</td>
                        <td>50.25</td>
                    </tr>
                    <tr>
                        <td>S</td>
                        <td>9.75</td>
                        <td>48.00</td>
                    </tr>
                    <tr>
                        <td>XL</td>
                        <td>25.50</td>
                        <td>51.00</td>
                    </tr>
                    <tr>
                        <td>XXL</td>
                        <td>35.95</td>
                        <td>35.95</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <p>Полученная сводная таблица имеет
                формат датафрейма (<strong>DataFrame)</strong>: индексы - <strong>pizza_size</strong>, значения - <strong>min</strong> и <strong>max</strong> по цене.</p>
            <a href="https://edu.hse.ru/mod/quiz/view.php?id=1610933" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>&nbsp;<a href="https://edu.hse.ru/mod/quiz/view.php?id=1610936" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>

        </section>
</div>

<div style="height: 0px; padding: 20px;"></div>
<div> <!-- ГЛАВА 6 -->
<section>
    <h1 style="font-size: 30px; color:#1e01da;" id="chapter6">Глава 6. Описательные статистики. Пропуски и выбросы</h1>
    <div style="height: 10px;"></div>
    
    <h2 id="chapter6-1">6.1 Что такое описательные статистики?</h2>

    <p style="display:inline">В предыдущих главах мы рассмотрели структуры продаж нашей пиццерии. Но чтобы уверенно двигаться вперёд и развивать бизнес, нужно выйти за пределы собственной компании и взглянуть шире — оценить обстановку на рынке общественного питания. Рассмотрим, как это сделать, на примере данных </p><a style="display:inline" href="https://google.com"><p style="display:inline">restaurants.csv:</p></a>

    <table border="1" class="dataframe_new" style="width: 100%;">
        <tr>
            <th>ПРИЗНАК</th>
            <th>ОПИСАНИЕ</th>
            <th>ФОРМАТ ДАННЫХ (.dtypes)</th>
        </tr>
        <tr>
            <td><strong>name</strong></td>
            <td>название ресторана</td>
            <td>object</td>
        </tr>
        <tr>
            <td><strong>restaurant_type</strong></td>
            <td>тип ресторана</td>
            <td>object</td>
        </tr>
        <tr>
            <td><strong>rate</strong></td>
            <td>рейтинг ресторана</td>
            <td>float64</td>
        </tr>
        <tr>
            <td><strong>votes</strong></td>
            <td>количество людей, поставивших оценку ресторана</td>
            <td>int64</td>
        </tr>
        <tr>
            <td><strong>avg_receipt</strong></td>
            <td>средний размер чека на двоих в ресторане</td>
            <td>float64</td>
        </tr>
        <tr>
            <td><strong>online_order</strong></td>
            <td>возможность сделать онлайн заказ (1 - есть, 0 - нет)</td>
            <td>int64</td>
        </tr>
        <tr>
            <td><strong>table_booking</strong></td>
            <td>возможность забронировать столик (1 - есть, 0 - нет)</td>
            <td>int64</td>
        </tr>
        <tr>
            <td><strong>cuisines_type</strong></td>
            <td>кухня в ресторане</td>
            <td>object</td>
        </tr>
        <tr>
            <td><strong>area</strong></td>
            <td>район, где расположен ресторан</td>
            <td>object</td>
        </tr>
    </table>

    <p>Одно <strong>наблюдение</strong> - это один <strong>ресторан</strong>.</p>

    <pre class="line-numbers"><code class="language-python">import pandas as pd

df = pd.read_csv('restaurants.csv')
df.head()</code></pre>

<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>name</th>
            <th>restaurant_type</th>
            <th>rate</th>
            <th>votes</th>
            <th>avg_receipt</th>
            <th>online_order</th>
            <th>table_booking</th>
            <th>cuisines_type</th>
            <th>area</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>#FeelTheROLL</td>
            <td>Quick Bites</td>
            <td>3.4</td>
            <td>7.0</td>
            <td>200.0</td>
            <td>0</td>
            <td>0</td>
            <td>Fast Food</td>
            <td>Bellandur</td>
        </tr>
        <tr>
            <th>1</th>
            <td>#L-81 Cafe</td>
            <td>Quick Bites</td>
            <td>3.9</td>
            <td>48.0</td>
            <td>400.0</td>
            <td>1</td>
            <td>0</td>
            <td>Fast Food, Beverages</td>
            <td>Byresandra,Tavarekere,Madiwala</td>
        </tr>
        <tr>
            <th>2</th>
            <td>#refuel</td>
            <td>Cafe</td>
            <td>3.7</td>
            <td>NaN</td>
            <td>400.0</td>
            <td>1</td>
            <td>0</td>
            <td>Cafe, Beverages</td>
            <td>Bannerghatta Road</td>
        </tr>
        <tr>
            <th>3</th>
            <td>'@ Biryani Central</td>
            <td>Casual Dining</td>
            <td>2.7</td>
            <td>135.0</td>
            <td>550.0</td>
            <td>1</td>
            <td>0</td>
            <td>Biryani, ...</td>
            <td>Marathahalli</td>
        </tr>
        <tr>
            <th>4</th>
            <td>'@99</td>
            <td>Takeaway, Delivery</td>
            <td>3.4</td>
            <td>37.0</td>
            <td>200.0</td>
            <td>0</td>
            <td>0</td>
            <td>Mughlai, Biryani, ...</td>
            <td>Whitefield</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Для такого исследования нам потребуются <strong>описательные статистики</strong>. Чтобы охарактеризовать среднестатистический ресторан, будем использовать <strong>меры центральной тенденции</strong>, раскрывающие портрет <em>типичного</em> игрока индустрии. Чтобы изучить <em>разнообразие</em> рынка, рассчитаем <strong>меры вариативности</strong> – они покажут, насколько разнятся заведения по ключевым характеристикам. Наконец, чтобы заглянуть внутрь структуры рынка и <em>выявить слои</em> заведений различного уровня, задействуем <strong>квартили</strong>.</p>

    <img src="picture/chapter6/7.svg" width="100%" alt="Рисунок 1">

    <p>Чтобы автоматически рассчитать описательные статистики для столбцов типа <em>int64</em> и <em>float64</em>, нужно применить метод <span class="code-chip">.describe()</span> к нашему датафрейму:</p>

    <pre class="line-numbers"><code class="language-python">df.describe()</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>rate</th>
            <th>votes</th>
            <th>avg_receipt</th>
            <th>online_order</th>
            <th>table_booking</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>count</th>
            <td>6407.0</td>
            <td>6370.0</td>
            <td>6407.0</td>
            <td>6407.0</td>
            <td>6407.0</td>
        </tr>
        <tr>
            <th>mean</th>
            <td>3.584642</td>
            <td>204.234694</td>
            <td>555.880912</td>
            <td>0.537225</td>
            <td>0.113157</td>
        </tr>
        <tr>
            <th>std</th>
            <td>0.424497</td>
            <td>621.802723</td>
            <td>475.615400</td>
            <td>0.498651</td>
            <td>0.316810</td>
        </tr>
        <tr>
            <th>min</th>
            <td>2.0</td>
            <td>1.0</td>
            <td>40.0</td>
            <td>0.0</td>
            <td>0.0</td>
        </tr>
        <tr>
            <th>25%</th>
            <td>3.3</td>
            <td>13.0</td>
            <td>300.0</td>
            <td>0.0</td>
            <td>0.0</td>
        </tr>
        <tr>
            <th>50%</th>
            <td>3.6</td>
            <td>40.0</td>
            <td>400.0</td>
            <td>1.0</td>
            <td>0.0</td>
        </tr>
        <tr>
            <th>75%</th>
            <td>3.9</td>
            <td>149.0</td>
            <td>650.0</td>
            <td>1.0</td>
            <td>0.0</td>
        </tr>
        <tr>
            <th>max</th>
            <td>4.9</td>
            <td>16345.0</td>
            <td>6000.0</td>
            <td>1.0</td>
            <td>1.0</td>
        </tr>
        </tbody>
    </table>
</div>

    <ul>
        <li><strong>count</strong> - количество непропущенных значений (не NaN) в признаке, аналог метода <span class="code-chip">.count()</span></li>
        <li><strong>mean</strong> - среднее арифметическое (МЦТ)</li>
        <li><strong>std</strong> - стандартное отклонение (мера вариативности)</li>
        <li><strong>min</strong> - минимум (квартили)</li>
        <li><strong>25%</strong> - первый квартиль (квартили)</li>
        <li><strong>50%</strong> - медиана/второй квартиль (МЦТ/квартили)</li>
        <li><strong>75%</strong> - третий квартиль (квартили)</li>
        <li><strong>max</strong> - максимум (квартили)</li>
    </ul>

    <p>Если описательные статистики нужны по признакам в формате <em>object</em>, добавьте внутрь <span class="code-chip">.describe()</span> параметр <span class="code-chip">include='object'</span>:</p>

    <pre class="line-numbers"><code class="language-python">df.describe(include='object')</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>name</th>
            <th>restaurant_type</th>
            <th>cuisines_type</th>
            <th>area</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>count</th>
            <td>6407</td>
            <td>6387</td>
            <td>6407</td>
            <td>6407</td>
        </tr>
        <tr>
            <th>unique</th>
            <td>6407</td>
            <td>80</td>
            <td>2035</td>
            <td>30</td>
        </tr>
        <tr>
            <th>top</th>
            <td>Zyksha</td>
            <td>Quick Bites</td>
            <td>North Indian, Chinese</td>
            <td>Byresandra,Tavarekere,Madiwala</td>
        </tr>
        <tr>
            <th>freq</th>
            <td>1</td>
            <td>2467</td>
            <td>381</td>
            <td>735</td>
        </tr>
        </tbody>
    </table>
</div>

    <ul>
        <li><strong>count</strong> - количество непропущенных значений (не NaN) в признаке, аналог метода <span class="code-chip">.count()</span></li>
        <li><strong>unique</strong> - количество уникальных категорий, аналог метода <span class="code-chip">.nunique()</span> (мера вариативности)</li>
        <li><strong>top</strong> - самое часто встречаемое значение, мода (МЦТ)</li>
        <li><strong>freq</strong> - частота моды</li>
    </ul>

    <div style="height: 10px;"></div>
    <h2 id="chapter6-2">6.2 Какие бывают меры центральной тенденции?</h2>

    <p>Когда перед нами большой объём информации, сложно сразу определить основные особенности или характеристики признаков – в таком случае на помощь приходят <strong>меры центральной тенденции</strong> (МЦТ)</p>

    <div class="important-card">
        <div class="important-text">
        <strong>Меры центральной тенденции (МЦТ)</strong> - группа описательных статистик, необходимая для характеристики <em>типичного</em> наблюдения в данных.
    </div></div>

    <p>Мы рассмотрим три описательных статистики: среднее арифметическое, медиана и мода.</p>

    <h3>СРЕДНЕЕ АРИФМЕТИЧЕСКОЕ</h3>

    <p>Среднее арифметическое (также называемое средним значением) является наиболее распространённым способом выражения общей тенденции или основного уровня данных.  В математике среднее обозначается x̄. Если мы хотим рассчитать среднее для некоторого признака X, нужно найти сумму по нему и разделить на количество наблюдений:

x̄= (x<sub>1</sub> + x<sub>2</sub> + ... + x<sub>n</sub>) / n</p>

    <p>Среднее, как правило, рассчитывается для <strong>количественных признаков</strong>. Чтобы рассчитать среднее арифметическое в Python, нужно воспользоваться методом <span class="code-chip">.mean()</span>. Например, мы хотим узнать средний рейтинг ресторанов (<strong>rate</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].mean()</code></pre>
    <p class="print_result">np.float64(3.5846417980334015)</p>
    <p>Или хотим выяснить средний размер чека (<strong>avg_receipt</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].mean()</code></pre>
    <p class="print_result">np.float64(555.8809115030435)</p>
    <p>Помимо оценки количественных признаков, среднее арифметическое применяется к <strong>категориальным бинарным</strong> данным, закодированным в виде 1 и 0. Для таких данных среднее арифметическое показывает долю 1 в данных. В наших данных есть признак <strong>online_order</strong> - идентификатор того, есть ли в ресторане возможность сделать онлайн-заказ. Если такая возможность есть - 1, иначе 0. Если мы хотим найти долю ресторанов, в которых есть опция онлайн-заказа, напишем следующий код:</p>

    <pre class="line-numbers"><code class="language-python">df['online_order'].mean()</code></pre>
    <p class="print_result">np.float64(0.5372249102544092)</p>

    <p>Получается, доля ресторанов, в которых есть возможность заказать онлайн, составляет 0.53. Для удобства можно умножить значение на 100, чтобы перевести доли в проценты:</p>

    <pre class="line-numbers"><code class="language-python">df['online_order'].mean()*100</code></pre>
    <p class="print_result">np.float64(53.722491025440924)</p>

    <p>Кажется, что среднее арифметическое идеально подходит для описания типичного наблюдения в данных, однако у него есть серьезный недостаток — <strong>чувствительность к выбросам</strong>. <strong>Выбросы</strong> — это крайне высокие или низкие значения, резко отличающиеся от остальных данных. Например, если в вашем наборе данных преобладают недорогие заведения общепита с небольшими средними чеками, но присутствуют несколько элитных ресторанов с гораздо более высокими ценами, то среднее арифметическое размера чека будет заметно увеличено за счет этих дорогих заведений. Из-за этого средняя величина станет завышенной, и получится неверное представление о типичном размере чека в большинстве мест.</p>

    <h3>МЕДИАНА</h3>

    <p><strong>Медиана</strong> - это мера центральной тенденции, лежащая по центру распределения данных. В отличие от среднего, медиана <strong>к выбросам устойчива</strong>; это связано с методологией ее рассчета, в которой мы берем не все данные, а только те, что лежат посередине:</p>

    <ul>
        <li>Если количество наблюдений <strong>нечетное</strong>, медиана - это значение, стоящее посередине. Например, в <strong>[1, 2, 3, 4, 5]</strong> медиана равна <strong>3</strong>.</li>
        <li>Если количество наблюдений <strong>четное</strong>, медиана - это среднее значение двух центральных наблюдений. Например, в <strong>[1, 2, 3, 4]</strong> медиана равна <strong>2.5</strong>.</li>
    </ul>

    <p>Аналогично среднему арифметическому, медиана рассчитывается, как правило, для <strong>количественных признаков</strong>. Если мы хотим рассчитать медиану размера чека (<strong>avg_receipt</strong>), воспользуемся методом <span class="code-chip">.median()</span>:</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].median()</code></pre>
<p class="print_result">400.0</p>

    <p>Получается, в половине ресторанов размер чека меньше 400 у.е., а в другой половине больше</p>

    <h3>МОДА</h3>

    <p>Последняя мера центральной тенденции - <strong>мода</strong>. Она показывает <strong>самое частое (популярное) значение</strong> в данных. Если значения среднего и медианы может быть только одно, то мод в данных может быть несколько:</p>

    <p>Данные: <strong>F D A D B C</strong></p>
    <div class="scrollable-table">
    <table border="1" class="dataframe">
    <tr>
        <th>Значение</th>
        <th>Частота</th>
    </tr>
    <tr>
        <td>F</td>
        <td>1</td>
    </tr>
    <tr>
        <td>D</td>
        <td>2</td>
    </tr>
    <tr>
        <td>A</td>
        <td>1</td>
    </tr>
    <tr>
        <td>B</td>
        <td>1</td>
    </tr>
</table></div>
<p><strong>D</strong> встречается чаще всего, значит <strong>D - МОДА</strong>.</p>

    <p>Как правило, моду рассчитывают для <strong>категориальных признаков</strong>. Если мы хотим найти, какая кухня (<strong>cuisines_type</strong>) наиболее распространенная в наших данных, воспользуемся методом <span class="code-chip">.mode()</span>:</p>

    <pre class="line-numbers"><code class="language-python">df['cuisines_type'].mode()</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>cuisines_type</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>North Indian, Chinese</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Этот метод возвращает серию (<strong>Series</strong>). Если бы мод было несколько (какие-то значения встретились одинаково часто), то все они вывелись бы в этой таблице. Чтобы извлечь конкретное значение моды, к нему нужно обратиться по индексу:</p>

    <pre class="line-numbers"><code class="language-python">df['cuisines_type'].mode()[0]</code></pre>
<p class="print_result">North Indian, Chinese</p>

    <p>Моду <strong>количественного признака</strong> можно оценить по гистограмме распределения.</p>

    <h3>СРАВНЕНИЕ МЕР ЦЕНТРАЛЬНОЙ ТЕНДЕНЦИИ</h3>

    <p>Мы разобрали три основных МЦТ. У каждой из них есть особенности использования и интерпретации:</p>

    <table border="1" class="dataframe_new" style="width: 100%;">
        <tr>
            <th></th>
            <th>СРЕДНЕЕ АРИФМЕТИЧЕСКОЕ</th>
            <th>МЕДИАНА</th>
            <th>МОДА</th>
        </tr>
        <tr>
            <td><strong>Определение</strong></td>
            <td>Отношение суммы всех наблюдений к их количеству</td>
            <td>Срединная МЦТ</td>
            <td>Самые частые/популярные значения</td>
        </tr>
        <tr>
            <td><strong>Метод</strong></td>
            <td><span class="code-chip">.mean()</span></td>
            <td><span class="code-chip">.median()</span></td>
            <td><span class="code-chip">.mode()</span></td>
        </tr>
        <tr>
            <td><strong>Устойчивость к выбросам</strong></td>
            <td>✕</td>
            <td>✓</td>
            <td>-</td>
        </tr>
        <tr>
            <td><strong>Типы данных:</strong></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><em>количественные</em></td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
        </tr>
        <tr>
            <td><em>категориальные</em></td>
            <td>Бинарные, закодированные в виде 1 и 0 (доля 1 в данных)</td>
            <td>✕</td>
            <td>✓</td>
        </tr>
    </table>

    <p>Теперь посмотрим, как графически оценивать среднее, медиану и моду по гистограмме.</p>
    <p>Для начала рассмотрим <strong>симметричные распределения.</strong> Распределение можно назвать симметричным, если гистограмма зеркально-симметрична относительно центра графика. Для оценки мер центральной тенденции в таких распределениях нужно запомнить два правила:</p>
    <ul>
        <li>
            <p>Среднее и медиана совпадают (или почти совпадают) и находятся по центру</p>
        </li>
        <li>
            <p>Мода - это пик(и)</p>
        </li>
    </ul>

    <img src="picture/chapter6/10.svg" width="100%" alt="Рисунок 10">

    <p>Выбросов (они могут находится на хвостах распределения) нет – а если и есть, то они уравновешивают среднее арифметическое слева и справа, и оно остается по центру. Медиана просто делит данные пополам.</p>

    <p>Если в данных один пик, как на гистограмме слева, со средним и медианой будет совпадать также и мода, так как пик данных находится по центру. Когда в данных одна мода, такое распределение называются <strong>унимодальным</strong>.</p>

    <p>В данных может быть и несколько пиков, как на графике справа. Когда пиков два, такое распределение называется <strong>бимодальным</strong>, и в нем каждый из пиков будет модой. Среднее и медиана также будут находиться посередине.</p>

    <p>Построим гистограмму распределения рейтинга ресторанов (<strong>rate</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].plot(kind='hist', bins=15)</code></pre>
    <img src="picture/chapter6/img1.png" width="100%" alt="Рисунок 10">

    <p>В целом, полученное распределение практически симметрично. Давайте сравним среднее и медиану для него:</p>

    <pre class="line-numbers"><code class="language-python">round(df['rate'].mean(), 1)  # среднее</code></pre>
<p class="print_result">np.float64(3.6)</p>
    
    <pre class="line-numbers"><code class="language-python">round(df['rate'].median(), 1)  # медиана</code></pre>
<p class="print_result">3.6</p>

    <p>Мы видим, что среднее и медиана совпадают. Если мы мысленно проведем линию на гистограмме признака <strong>rate</strong> на значении 3.6, она окажется по середине графика.</p>

    <p>Из равенства среднего и медианы вытекает еще одно свойство:</p>

    <ul><li><p>
        если среднее и медиана совпадают (или практически совпадают), мы не можем утверждать, что в даннных есть экстремальные значения (выбросы)
    </p></li></ul>
    <p>Распределения также могут быть <strong>асимметричными</strong>, в которых относительно центра графика отсутвует какая-либо зеркальность. В таких распределениях для оценки мер центральной тенденции пользуемся следующими тремя правилами:</p>
    
    <ul>
        <li><p>
Среднее арифметическое тяготеет к тяжелым хвостам (к выбросам)
        </p></li>
        <li><p>
            Медиана тяготеет к основной группе данных (от выбросов)
        </p></li>
        <li><p>
            Мода - это пик(и)
        </p></li>
    </ul>

    <img src="picture/chapter6/11.svg" width="100%" alt="Рисунок 11">

    <p>Для определения моды мы пользуемся той же логикой, что и в симметричных распределениях: мода - там, где пик. Теперь разберемся со средним и медианой.</p>
    
    <p>На первой гистограмме тяжелый хвост находится справа. В этом тяжелом хвосте собраны <strong>экстремально высокие значения</strong> (выбросы), значительно отличающиеся от большей части наших данных. Из всех мер центральной тенденции среднее будет ближе всего к этому тяжелому хвосту, так как эта МЦТ не устойчива к выбросам и всегда тянется к экстремальным значениям. Медиана будет дальше от выбросов, чем среднее, так как эта МЦТ к выбросам устойчива. Из этого наблюдения у нас вытекает еще одна закономерность:</p>

    <ul><li><p>Если <strong>среднее значительно больше, чем медиана</strong>, это свидетельствует о том, что в данных есть <strong>экстремально высокие значения</strong></p></li></ul>

    <p>В тяжелом хвосте на второй гистограмме собрались <strong>экстремально низкие значения</strong> (выбросы). Логика определения среднего и медианы здесь точно такая же. Среднее не устойчиво к выбросам, а значит оно будет тяготеть к тяжелым хвостам и будет ближе всего к ним. Медиана к выбросам устойчива, а значит она будет дальше от экстремальных значений. На основании этого мы можем сделать еще один вывод:</p>

    <ul><li><p>Если <strong>среднее значительно меньше, чем медиана</strong>, это свидетельствует о том, что в данных есть <strong>экстремально низкие значения</strong></p></li></ul>

    <p>Построим гистограмму распределения размера чека (<strong>avg_receipt</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].plot(kind='hist', bins=15)</code></pre>

    <img src="picture/chapter6/img2.png" width="100%" alt="Рисунок 2">

    <p>Распределение размера чека асимметричное. В большей части ресторанов чек не превышает 2000 у.е., однако мы видим на гистограмме тяжелый хвост справа, там находятся рестораны с экстремально высоким размером чека. Значит мы можем предположить, что для данного признака среднее значение будет больше, чем медиана. Давайте это предположение проверим:</p>

    <pre class="line-numbers"><code class="language-python">round(df['avg_receipt'].mean(), 1)  # среднее</code></pre>
<p class="print_result">np.float64(555.9)</p>
    <pre class="line-numbers"><code class="language-python">round(df['avg_receipt'].median(), 1)  # медиана</code></pre>
<p class="print_result">400.0</p>
    <p>Как мы видим, среднее больше медианы почти на 156 у.е. Значит наши выводы на основе гистограммы оказались верны.</p>

    <div style="height: 10px;"></div>
    <h2 id="chapter6-3">6.3 Какие бывают квартили?</h2>

    <div class="important-card">
        <div class="important-text">
            <strong>Квартили</strong> — это специальные величины, позволяющие разделить весь набор данных на четыре равных части.
        </div>
    </div>

    <p>Квартили позволяют эффективно разделить данные на отдельные слои на основании некоторого <strong>количественного признака</strong>. В контексте ресторанного рынка использование квартилей помогает выделить различные сегменты заведений – например, проанализировав рейтинг мест общественного питания (<strong>rate</strong>).</p>

    <p>Выделяют пять основных квартилей:</p>

    <ul>
        <li>
            <p><strong>Нулевой квартиль (Q₀)</strong></p>
            <p>Это такое значение, меньше которого 0% данных. Это то же самое, что <strong>минимум</strong> в данных. Чтобы рассчитать нулевой квартиль, можно воспользоваться методом <span class="code-chip">.quantile(0)</span> или <span class="code-chip">.min()</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(0)</code></pre>
            <p class="print_result">np.float64(1.8)</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].min()</code></pre>
            <p class="print_result">1.8</p>
            <p>Самый низкий рейтинг ресторана – 1.8 звезд. Или, другими словами, 100% ресторанов имеют рейтинг не меньше 1.8.</p>
        </li>
        
        <li>
            <p><strong>Первый квартиль (Q₁)</strong></p>
            <p>Это значение, меньше которого 25% данных, или значение, больше которого 75% данных.</p>
            <p>Для рассчета первого квартиля используется метод <span class="code-chip">.quantile(0.25)</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(0.25)</code></pre>
            <p class="print_result">3.3</p>
            <p>25% ресторанов имеют рейтинг менее 3.3 звезд. Эти 25% ресторанов можно отнести к худшим ресторанам с самым низким рейтингом. У остальных 75% ресторанов рейтинг более 3.3 звезд.</p>
        </li>
        
        <li>
            <p><strong>Второй квартиль (Q₂)</strong></p>
            <p>Это то же самое, что <strong>медиана</strong>. Второй квартиль делит данные пополам: меньше него 50% данных и больше него тоже 50%.</p>
            <p>Для рассчета этого значения используется либо метод <span class="code-chip">.quantile(0.5)</span>, либо <span class="code-chip">.median()</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(0.5)</code></pre>
            <p class="print_result">np.float64(3.6)</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].median()</code></pre>
            <p class="print_result">3.6</p>
            <p>50% ресторанов имеют рейтинг менее (более) 3.6 звезд, или медиана рейтинга ресторана составляет 3.6 звезд</p>
        </li>
        
        <li>
            <p><strong>Третий квартиль (Q₃)</strong></p>
            <p>Это значение, меньше которого 75% данных. Или значение, больше которого 25% данных.</p>
            <p>Для рассчета третьего квартиля используется метод <span class="code-chip">.quantile(0.75)</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(0.75)</code></pre>
            <p class="print_result">np.float64(3.9)</p>
            <p>25% ресторанов имеют рейтинг более 3.9 звезд. Это сегмент ресторанов с самым высоким рейтингом. У остальных 75% ресторанов рейтинг меньше этого значения.</p>
        </li>
        
        <li>
            <p><strong>Четвертый квартиль (Q₄)</strong></p>
            <p>Это то же самое, что <strong>максимум</strong> данных. То есть, это такое значение, больше которого 0% данных.</p>
            <p>Для рассчета этого значения используется либо метод <span class="code-chip">.quantile(1)</span>, либо <span class="code-chip">.max()</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(1)</code></pre>
            <p class="print_result">np.float64(4.9)</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].max()</code></pre>
            <p class="print_result">4.9</p>
        </li>
    </ul>

    <img src="picture/chapter6/12.svg" width="100%" alt="Рисунок 12">
<div class="scrollable-table">
    <table border="1" class="dataframe_new" style="width: 100%;">
        <tr>
            <th></th>
            <th>НУЛЕВОЙ КВАРТИЛЬ<br>(МИНИМУМ)</th>
            <th>ПЕРВЫЙ КВАРТИЛЬ</th>
            <th>ВТОРОЙ КВАРТИЛЬ<br>(МЕДИАНА)</th>
            <th>ТРЕТИЙ КВАРТИЛЬ</th>
            <th>ЧЕТВЕРТЫЙ КВАРТИЛЬ<br>(МАКСИМУМ)</th>
        </tr>
        <tr>
            <td><strong>Определение</strong></td>
            <td>100% значений не меньше чем Q₀</td>
            <td>75% значений больше чем Q₁</td>
            <td>50% значений больше чем Q₂</td>
            <td>25% значений больше чем Q₃</td>
            <td>100% значений не больше чем Q₄</td>
        </tr>
        <tr>
            <td></td>
            <td>Минимальное значение равно Q₀</td>
            <td>25% значений меньше чем Q₁</td>
            <td>50% значений меньше чем Q₂</td>
            <td>75% значений меньше чем Q₃</td>
            <td>Максимальное значение равно Q₄</td>
        </tr>
        <tr>
            <td><strong>Метод</strong></td>
            <td><span class="code-chip">.quantile(0)</span><br><span class="code-chip">.min()</span></td>
            <td><span class="code-chip">.quantile(0.25)</span></td>
            <td><span class="code-chip">.quantile(0.5)</span><br><span class="code-chip">.median()</span></td>
            <td><span class="code-chip">.quantile(0.75)</span></td>
            <td><span class="code-chip">.quantile(1)</span><br><span class="code-chip">.max()</span></td>
        </tr>
        <tr>
            <td><strong>Типы данных:</strong></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><em>количественные</em></td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
        </tr>
        <tr>
            <td><em>категориальные</em></td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
        </tr>
    </table>
</div>
<div style="height: 10px;"></div>
    <h2 id="chapter6-4">6.4 Какие бывают меры вариативности?</h2>

    <p>Мы описали типичный ресторан с помощью мер центральной тенденции. Затем мы провели сегментацию ресторанов по уровням популярности, используя квартили, выделяя верхние и нижние слои по качеству обслуживания и привлекательности для клиентов.</p>

    <p>Теперь, чтобы глубже разобраться в структуре рынка и выяснить, насколько сильно <em>различаются</em> рестораны друг от друга, нам необходимы <strong>меры вариативности</strong> (разброса).</p>

    <div class="important-card">
        <div class="important-text">
        <strong>Меры вариативности</strong> - это группа описательных статистик, которые используются для оценки <em>степени разброса</em> значений признака.
        </div>
    </div>

    <h3>РАЗМАХ</h3>

    <p>Если мы хотим узнать <em>амплитуду разброса</em> <strong>количественного признака</strong>, можно рассчитать <strong>размах</strong>. Чтобы его рассчитать, нужно найти разницу между максимальным и минимальным значением. Например, мы хотим найти размах размера чека (<strong>avg_receipt</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].max() - df['avg_receipt'].min()</code></pre>
<p class="print_result">5960.0</p>
    <p>Размер чека в местах общественного питания меняется в диапазоне 5960 у.е.. Это довольно большое число, говорящие о разнообразии мест, которые представленны в наших данных: у нас есть скромные места с небольшим чеком, но представлены и более изысканные дорогие заведения.</p>

    <p>У размаха есть большой недостаток – он <strong>не устойчив к экстремальным значениям</strong> (выбросам). То есть, если в данных только один дорогой ресторан, где средний размер чека составляет, к примеру, 7000 у.е., а во всех остальных ресторанах чек около 1000 у.е., по итоговому числу может показаться, что дорогих ресторанов очень много – это приведет к искажению общего понимания рынка.</p>

    <p>Этот недостаток связан с тем, что для рассчета размаха берутся крайние значения признака (максимум и минимум), а они зачастую могут оказаться выбросами, единичными искажениями в данных.</p>

    <img src="picture/chapter6/13.svg" width="100%" alt="Рисунок 13">

    <h3>ИНТЕРКВАРТИЛЬНЫЙ РАЗМАХ (IQR)</h3>

    <p>Если мы хотим оценить, в каком диапазоне меняется значение, но при этом нам нужна мера вариативности, устойчивая к выбросам, можно рассчитать <strong>интерквартильный размах</strong> (межквартильный диапазон). Довольно часто его сокращают как IQR (Interquartile Range). Чтобы его рассчитать, нужно из третьего квартиля (Q₃) вычесть первый квартиль (Q₁):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].quantile(0.75) - df['avg_receipt'].quantile(0.25)</code></pre>
<p class="print_result">np.float64(300.0)</p>
    <p>Устойчивость к выбросам этой метрики обусловлена способом ее расчета: берутся не крайние значения, которые могут оказаться выбросами, а Q₁ и Q₃, расположенные ближе к центру распределения. Между этими эти квартилями находится 50% наблюдений (в нашем случае – ресторанов), поэтому мы можем сказать, что диапазон разброса центральных 50% наблюдений по размеру чека составляет 300 у.е.</p>

    <img src="picture/chapter6/14.svg" width="100%" alt="Рисунок 14">

    <h3>ДИСПЕРСИЯ</h3>

    <p>Еще одна мера, позволяющая оценить разброс данных, это <strong>дисперсия</strong>. В математике она обозначается греческой буква сигма в квадрате -  σ<sup>2</sup> . Это мера показывает <em>усредненный квадрат отклонений</em> <strong>количественного</strong> признака от среднего арифметического:</p>

    <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup><mi>σ</mi><mn>2</mn></msup>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mo>(</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>x</mi><mn>1</mn></msub>
          <mo>-</mo>
          <mover><mi>x</mi><mo>¯</mo></mover>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>x</mi><mn>2</mn></msub>
          <mo>-</mo>
          <mover><mi>x</mi><mo>¯</mo></mover>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mo>…</mo>
      <mo>+</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>x</mi><mi>n</mi></msub>
          <mo>-</mo>
          <mover><mi>x</mi><mo>¯</mo></mover>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>)</mo>
    </mrow>
    <mi>n</mi>
  </mfrac>
</math>

    <p>x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>  - каждое наблюдение количественного признака</p>
    <p>x̄  - среднее арифметическое</p>
    <p>(x<sub>n</sub>−x̄)<sup>2</sup>  - квадрат отклонения данных от среднего арифметического. Квадрат берется, чтобы не появился минус, так как отклонение может быть как в большую, так и в меньшую сторону от среднего.</p>
    <p>n  - количество наблюдений. Делим на число наблюдений, чтобы найти усредненное значение.</p>


    <p>Для того чтобы рассчитать дисперсию в Python, нам не нужна формула, нужно лишь воспользоваться методом <span class="code-chip">.var()</span> (от слова variance, – англ. <em>дисперсия</em>)</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].var()</code></pre>
<p class="print_result">224698.25283148492</p>

    <p>Недостатком дисперсии как меры вариативности является ее зависимость от среднего арифметического, вследствие чего она <strong>крайне восприимчива к наличию выбросов</strong>. Более того, поскольку расчет основан на квадратах отклонений, итоговая величина оказывается неудобной для интуитивного осмысления, так как представляет собой квадратную меру первоначальной единицы измерения.</p>
    <p>Тем не менее, попробовать выразить смысл полученного результата можно следующим образом: усредненное квадратичное отклонение размера чека от среднего значения составило 224698.25  у.е<sup>2</sup>.</p>
    <p>Мы можем использовать дисперсию для сравнения степени разброса нескольких наборов данных. Чем больше дисперсия, тем больше разброс данных, и тем менее плотно наши данные собраны вокруг среднего и больше растянуты по числовой оси. С точки зрения гистограммы распределения это выглядит так:</p>
    <img src="picture/chapter6/15.svg" width="100%" alt="Рисунок 15">

    <h3>СТАНДАРТНОЕ ОТКЛОНЕНИЕ</h3>
    <p>Чтобы избавиться от квадрата в дисперсии, можно взять <em>корень</em>. Такая мера вариативности называется <strong>стандартным отклонением</strong> и обозначется  σ , но уже без квадрата:</p>

    <math xmlns="http://www.w3.org/1998/Math/MathML" style="font-size: 1.3em;">
  <mi>σ</mi>
  <mo>=</mo>
  <msqrt>
    <mfrac>
      <mrow>
        <mo>(</mo>
        <msup>
          <mrow>
            <mo>(</mo>
            <msub><mi>x</mi><mn>1</mn></msub>
            <mo>-</mo>
            <mover><mi>x</mi><mo>¯</mo></mover>
            <mo>)</mo>
          </mrow>
          <mn>2</mn>
        </msup>
        <mo>+</mo>
        <msup>
          <mrow>
            <mo>(</mo>
            <msub><mi>x</mi><mn>2</mn></msub>
            <mo>-</mo>
            <mover><mi>x</mi><mo>¯</mo></mover>
            <mo>)</mo>
          </mrow>
          <mn>2</mn>
        </msup>
        <mo>+</mo>
        <mo>…</mo>
        <mo>+</mo>
        <msup>
          <mrow>
            <mo>(</mo>
            <msub><mi>x</mi><mi>n</mi></msub>
            <mo>-</mo>
            <mover><mi>x</mi><mo>¯</mo></mover>
            <mo>)</mo>
          </mrow>
          <mn>2</mn>
        </msup>
        <mo>)</mo>
      </mrow>
      <mi>n</mi>
    </mfrac>
  </msqrt>
</math>


    <p>Чтобы рассчитать стандартное отклонение, воспользуемся методом <span class="code-chip">.std()</span> от англ. <em>standard deviation:</em></p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].std()</code></pre>
<p class="print_result">474.02347286973554</p>

    <p>Стандартное отклонение также <strong>чувствительно к выбросам</strong>, но гораздо удобнее в интерпретации: в среднем размер чека отличается от среднего арифметического на 474.02 у.е..</p>
    <p>Стандартное отклонение также можно использовать для сравнения разброса нескольких наборов данных. Логика такая же, как и с дисперсией: чем больше стандартное отклонение, тем больше вариативность данных, и тем больше данные растянуты по оси:</p>
    <img src="picture/chapter6/16.svg" width="100%" alt="Рисунок 16">

    <h3>КОЛИЧЕСТВО УНИКАЛЬНЫХ ЗНАЧЕНИЙ</h3>

    <p>Меры вариативности, которые мы рассмотрели выше, используется только для количественных признаков. Если мы хотим оценить разнообразие <strong>категориального признака</strong>, можно рассчитать количество уникальных значений с помощью метода <span class="code-chip">.nunique()</span>:</p>

    <pre class="line-numbers"><code class="language-python">df['cuisines_type'].nunique()</code></pre>
<p class="print_result">2045</p>

    <p>Другими словами, в вашем датасете содержится 2045 различных типов кухни.</p>
    <div class="scrollable-table">
    <table border="1" class="dataframe_new" style="width: 100%;">
        <tr>
            <th></th>
            <th>РАЗМАХ</th>
            <th>ИНТЕРКВАРТИЛЬНЫЙ РАЗМАХ</th>
            <th>ДИСПЕРСИЯ</th>
            <th>СТАНДАРТНОЕ ОТКЛОНЕНИЕ</th>
            <th>КОЛИЧЕСТВО УНИКАЛЬНЫХ ЗНАЧЕНИЙ</th>
        </tr>
        <tr>
            <td><strong>Определение</strong></td>
            <td>Амплитуда разброса данных</td>
            <td>Диапазон в котором лежит 50% центральных данных</td>
            <td>Усредненный квадрат отклонений данных от среднего</td>
            <td>Усредненное отклонение данных от среднего</td>
            <td>Количество категорий</td>
        </tr>
        <tr>
            <td><strong>Метод</strong></td>
            <td><span class="code-chip">.max()-.min()</span></td>
            <td><span class="code-chip">.quantile(0.75)-.quantile(0.25)</span></td>
            <td><span class="code-chip">.var()</span></td>
            <td><span class="code-chip">.std()</span></td>
            <td><span class="code-chip">.nunique()</span></td>
        </tr>
        <tr>
            <td><strong>Устойчивость к выбросам</strong></td>
            <td>✕</td>
            <td>✓</td>
            <td>✕</td>
            <td>✕</td>
            <td>-</td>
        </tr>
        <tr>
            <td><strong>Типы данных:</strong></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><em>количественные</em></td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
            <td>✕</td>
        </tr>
        <tr>
            <td><em>категориальные</em></td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
            <td>✓</td>
        </tr>
    </table>
    </div>

<a href="https://edu.hse.ru/mod/quiz/view.php?id=1610938" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>
<div style="height: 10px;"></div>
    <h2 id="chapter6-5">6.5 Как искать выбросы в данных?</h2>

    <p>В прошлых разделах мы уже затронули тему выбросов. А сейчас поговорим о них чуть подробнее.</p>

    <div class="important-card">
        <div class="important-text">
            <strong>Выбросы</strong> — это крайне высокие или низкие значения, резко отличающиеся от остальных данных.
        </div>
    </div>

    <p>В анализе выбросы принято удалять, так как с ними плохо работают классические методы, такие как корреляция и регрессия, о которых мы будем говорить дальше.</p>

    <p>Чтобы удалить выбросы, для начала нужно узнать их границы. Для этого используются два основных метода: <strong>метод N стандартных отклонений</strong> и <strong>метод 1.5 интерквартильных размахов</strong>.</p>

    <h3>МЕТОД N СТАНДАРТНЫХ ОТКЛОНЕНИЙ (STD)</h3>

    <p>Чтобы узнать границы выбросов методом N стандартных отклонений, нужно проделать следующие шаги:</p>

    <ol>
        <li>Рассчитать среднее арифметическое (<span class="code-chip">avg</span>):
            <p class="fake-code"><span class="code-line">avg = датафрейм['признак'].mean()</span></p>
        </li>
        <li>Рассчитать стандартное отклонение (<span class="code-chip">std</span>):
            <p class="fake-code"><span class="code-line">std = датафрейм['признак'].std()</span></p>
        </li>
        <li>Находим левую границу выбросов:
            <p class="fake-code"><span class="code-line">left = avg - N*std</span></p>
        </li>
        <li>Находим правую границу выбросов:
            <p class="fake-code"><span class="code-line">right = avg + N*std</span></p>
        </li>
    </ol>

    <p>Выбросами будут являться все те наблюдения, которые меньше левой границы и больше, чем правая граница. Если мы хотим оставить только чистые данные без выбросов, можно сделать следующую фильтрацию:</p>
    <p class="fake-code"><span class="code-line">df_clean = df[(датафрейм['признак'] >= left) & (датафрейм['признак'] <= right)]</span></p>
    <p>А если, наоборот, нужны только выбросы, делаем следующую фильтрацию:</p>
    <p class="fake-code"><span class="code-line">outliers = df[(датафрейм['признак'] < left) | (датафрейм['признак'] > right)]</span></p>

    <img src="picture/chapter6/17.svg" width="100%" alt="Рисунок 17">

    <p>Давайте рассчитаем границы выбросов для размера чека (<strong>avg_receipt</strong>). Будем считать, что выбросы – это все рестораны, в которых размер чека отличается от среднего более чем на 2 стандартных отклонения:</p>

    <pre class="line-numbers"><code class="language-python">avg = df['avg_receipt'].mean()
std = df['avg_receipt'].std()

left = avg - 2*std
right = avg + 2*std</code></pre>

    <p>Если мы хотим сохранить чистые данные без выбросов в отдельную переменную, чтобы в дальнейшем с ними работать, сделаем следующую фильтрацию:</p>

    <pre class="line-numbers"><code class="language-python">df_clean = df[(df['avg_receipt'] >= left) & (df['avg_receipt'] <= right)]
df_clean.shape[0]</code></pre>
<p class="print_result">5825</p>

    <p>В данных осталось 5825 ресторанов.</p>
    <p>Если мы хотим посчитать количество выбросов, сделаем обратную фильтрацию:</p>
    <pre class="line-numbers"><code class="language-python">df[(df['avg_receipt'] < left) | (df['avg_receipt'] > right)].shape[0]</code></pre>
    <p class="print_result">582</p>

    <p>Выбросами по размеру чека оказались 582 ресторана.</p>

    <h3>МЕТОД 1.5 ИНТЕРКВАРТИЛЬНЫХ РАЗМАХОВ (IQR)</h3>

    <p>Второй метод для нахождения границ выбросов основывается на квартилях. Алгоритм его использования следующий:</p>

    <ol>
        <li>Рассчитать первый квартиль (<span class="code-chip">q1</span>):
            <p class="fake-code"><span class="code-line">q1 = датафрейм['признак'].quantile(0.25)</span></p>
        </li>
        <li>Рассчитать третий квартиль (<span class="code-chip">q3</span>):
            <p class="fake-code"><span class="code-line">q3 = датафрейм['признак'].quantile(0.75)</span></p>
        </li>
        <li>Находим интерквартильный размах (<span class="code-chip">iqr</span>):
            <p class="fake-code"><span class="code-line">iqr = q3-q1</span></p>
        </li>
        <li>Находим левую границу выбросов:
            <p class="fake-code"><span class="code-line">left = q1 - 1.5*iqr</span></p>
        </li>
        <li>Находим правую границу выбросов:
            <p class="fake-code"><span class="code-line">right = q3 + 1.5*iqr</span></p>
        </li>
    </ol>

    <img src="picture/chapter6/18.svg" width="100%" alt="Рисунок 18">

    <p>Теперь давайте рассчитаем границы выбросов размера чека (<strong>avg_receipt</strong>) методом 1.5*IQR:</p>

    <pre class="line-numbers"><code class="language-python">q1 = df['avg_receipt'].quantile(0.25)
q3 = df['avg_receipt'].quantile(0.75)
iqr = q3 - q1

left = q1 - 1.5*iqr
right = q3 + 1.5*iqr</code></pre>

    <p>Сделаем фильтрацию и посчитаем, сколько ресторанов согласно этому методу не будут считаться выбросами:</p>

    <pre class="line-numbers"><code class="language-python">df[(df['avg_receipt'] >= left) & (df['avg_receipt'] <= right)].shape[0]</code></pre>

    <p class="print_result">5825</p>

    <p>Для нахождения количества выбросов сделаем следующую фильтрацию:</p>

    <pre class="line-numbers"><code class="language-python">df[(df['avg_receipt'] < left) | (df['avg_receipt'] > right)].shape[0]</code></pre>

    <p class="print_result">582</p>

    <p>Количество выбросов и чистых данных для обоих методов совпали, но на практике они могут отличаться, и это нормально.</p>

    <h3>ЯЩИК С УСАМИ</h3>

    <p>Мы уже с вами умеем строить ящик с усами. Теперь разберемся подробнее с тем, какую информацию он может нам дать.</p>

    <p>В первую очередь, с его помощью можно оценить наличие выбросов в данных.<strong>Выбросы</strong> на нем <strong>обозначаются кружками</strong> с левой и с правой стороны от "усов". <strong>Границы выбросов</strong> находятся в конце каждого из "усов" и рассчитываются по методу <strong>1.5*IQR</strong>.</p>

    <p><strong>Левая граница</strong> ящика - это <strong>первый квартиль</strong> (Q₁), а <strong>правая граница</strong> - это <strong>третий квартиль</strong> (Q₃). Линия <strong>посередине</strong> - <strong>медиана</strong> (второй квартиль, Q₂)</p>

    <img src="picture/chapter6/19.svg" width="100%" alt="Рисунок 19">

    <p>Ящик всегда показывает квартили, а вот границы "усов" могут рассчитываться по разному в зависимости от того, есть в данных выбросы или нет.</p>

    <p>Если в данных <strong>нет экстремально низких значений</strong>, то есть нет кружков слева:</p>
    <ul>
        <li><p>Левая граница: <strong>минимум</strong></p></li>
        <li><p>Правая граница: <strong>Q3+1.5∗IQR</strong></p></li>
    </ul>

    <p>Если в данных <strong>нет экстремально высоких значений</strong>, то есть нет кружков справа:</p>
    <ul>
        <li><p>Левая граница: <strong>Q1-1.5∗IQR</strong></p></li>
        <li><p>Правая граница: <strong>максимум</strong></p></li>
    </ul>

    <p>Если в данных <strong>нет экстремальных значений</strong>, то есть нет кружков вообще:</p>
    <ul>
        <li><p>Левая граница: <strong>минимум</strong></p></li>
        <li><p>Правая граница: <strong>максимум</strong></p></li>
    </ul>

    <img src="picture/chapter6/20.svg" width="100%" alt="Рисунок 20">

    <div class="important-card">
        <div class="important-text">
            На ящике с усами нет среднего арифметического, но мы можем оценить его положение. Если в данных есть экстремально низкие значения, то среднее будет левее медианы, а если в данных есть экстремально высокие значения, то среднее будет правее медианы.
        </div>
    </div>

    <p>Давайте построим ящик с усами для рейтинга ресторанов (<strong>rate</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].plot(kind='box', vert=False)</code></pre>

    <img src="picture/chapter6/img3.png" width="70%" alt="Рисунок 3">
    
    <p>Мы видим, что выбросы есть слева и справа. Значит если мы хотим узнать точные значения основных показателей, будем следовать следующему алгоритму:</p>

    <p>Самые крайние кружочки – это минимум и максимум:</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].min()  # левый кружок</code></pre>
<p class="print_result">2.0</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].max()  # правый кружок</code></pre>
<p class="print_result">4.9</p>

    <p>Линия посередине ящика - это медиана:</p>
        <pre class="line-numbers"><code class="language-python">df['rate'].median()</code></pre>
<p class="print_result">3.6</p>

    <p>Левая граница ящика - это первый квартиль (<span class="code-chip">q1</span>), а правая граница - третий квартиль (<span class="code-chip">q3</span>):</p>

    <pre class="line-numbers"><code class="language-python">q1 = df['rate'].quantile(0.25)  # левая граница коробки
q1</code></pre>
<p class="print_result">np.float64(3.3)</p>

    <pre class="line-numbers"><code class="language-python">q3 = df['rate'].quantile(0.75)  # правая граница коробки
q3</code></pre>
<p class="print_result">np.float64(3.9)</p>

    <p>Теперь рассчитаем интерквартильный размах (<span class="code-chip">IQR</span>):</p>
    <pre class="line-numbers"><code class="language-python">iqr = q3 - q1
iqr</code></pre>
<p class="print_result">np.float64(0.6000000000000001)</p>

    <p>Теперь можем рассчитать значение левого и правого усов:</p>

    <pre class="line-numbers"><code class="language-python">q1 - 1.5*iqr  # левый ус</code></pre>
<p class="print_result">np.float64(2.3999999999999995)</p>

    <pre class="line-numbers"><code class="language-python">q3 + 1.5*iqr  # правый ус</code></pre>
<p class="print_result">np.float64(4.8)</p>

    <p>А теперь построим ящик с усами для среднего размера чека в ресторанах (<strong>avg_receipt</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].plot(kind='box', vert=False)</code></pre>

    <img src="picture/chapter6/img4.png" width="70%" alt="Рисунок 4">

    <p>У данного признака нет экстремально низких значений, значит левый ус - это минимум, а самая крайна правая точка - это максимум:</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].min()  # левый ус</code></pre>
<p class="print_result">40.0</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].max()  # крайная правая точка</code></pre>
<p class="print_result">6000.0</p>

    <p>Ящик интерпретируется точно также: линия посередине - это медиана, левая граница - первый квартиль (<span class="code-chip">q1</span>), правая граница - третий квартиль (<span class="code-chip">q3</span>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].median()  # линия по середине коробки</code></pre>
<p class="print_result">400.0</p>

    <p>На ящике с усами нет среднего арифметического, но мы можем оценить, какое оно. В данных есть экстремально высокие значения, среднее тянется к выбросам и будет ближе к ним, чем медиана, значит среднее арифметическое будет больше чем 400.</p>

    <pre class="line-numbers"><code class="language-python">q1 = df['avg_receipt'].quantile(0.25)  # левая граница коробки
q1</code></pre>
<p class="print_result">np.float64(300.0)</p>

    <pre class="line-numbers"><code class="language-python">q3 = df['avg_receipt'].quantile(0.75)  # правая граница коробки
q3</code></pre>
<p class="print_result">np.float64(650.0)</p>

    <p>Правый "ус" - это граница выбросов:</p>

    <pre class="line-numbers"><code class="language-python">iqr = q3 - q1  # интерквартильный размах
q3 + 1.5*iqr  # правый ус</code></pre>
<p class="print_result">np.float64(1175.0)</p>



    <a href="https://edu.hse.ru/mod/quiz/view.php?id=1610939" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самопроверка</button></a>
<div style="height: 10px;"></div>
    <h2 id="chapter6-6">6.6 Как обрабатывать пропуски в данных?</h2>

    <p>Теперь обсудим, как работать с пропусками в данных. Пропуск - это отсутствие информации, которое в Pandas обозначается как <span class="code-chip">NaN</span>.</p>

    <h3>ПОДСЧЕТ КОЛИЧЕСТВА ПРОПУСКОВ</h3>

    <p>Мы уже встречали метод агрегирования <span class="code-chip">.count()</span>, который возвращает количество непропущенных значений. Но если нам, наоборот, нужно количество пропусков, можно использоваться методом <span class="code-chip">.isna()</span>. Давайте применим его к нашему датафрейму по ресторанам и посмотрим, что он вернет:</p>

    <pre class="line-numbers"><code class="language-python">df.isna()</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>name</th>
            <th>restaurant_type</th>
            <th>rate</th>
            <th>votes</th>
            <th>avg_receipt</th>
            <th>online_order</th>
            <th>table_booking</th>
            <th>cuisines_type</th>
            <th>area</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>1</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>2</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>True</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>3</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>4</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>...</th>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
        </tr>
        <tr>
            <th>6402</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>6403</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>6404</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>6405</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>6406</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Этот метод преобразует все значения датафрейма в <span class="code-chip">True</span> и <span class="code-chip">False</span>. <span class="code-chip">True</span> говорит о том, что значение пропущено (NaN), а <span class="code-chip">False</span> - что пропуска нет. По сути <span class="code-chip">True</span> - это 1, а <span class="code-chip">False</span> - это 0 Если мы хотим посчитать <strong>количество пропусков</strong> в каждом столбце, нам нужно просуммировать <span class="code-chip">True</span>. Для этого применим к <span class="code-chip">.isna()</span> еще и метод <span class="code-chip">.sum()</span>:</p>

    <p class="fake-code"><span class="code-line">датафрейм.isna().sum()</span></p>

    <pre class="line-numbers"><code class="language-python">df.isna().sum()</code></pre>

    <div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>20</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>37</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Мы видим 20 пропусков в признаке тип ресторана (<strong>restaurant_type</strong>) и 37 пропусков в количестве людей, поставивших оценку (<strong>votes</strong>). В остальных признаках пропусков нет.</p>

    
    <p>Для того чтобы получить не количество, а <strong>долю пропусков</strong>, применим к <span class="code-chip">.isna()</span> метод <span class="code-chip">.mean()</span>:</p>

    <p class="fake-code"><span class="code-line">датафрейм.isna().mean()</span></p>

    <pre class="line-numbers"><code class="language-python">df.isna().mean()</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>0.003122</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>0.005775</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0.0</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Такая команда возвращает долю пропусков, так как <span class="code-chip">.isna()</span> трансформирует признаки в бинарный формат, где каждый признак по факту 0 (<span class="code-chip">False</span>) и 1 (<span class="code-chip">True</span>), а среднее найденное по такому признаку будет показывать долю 1 в данных, то есть долю пропусков.</p>

    <p>При необходимости долю пропусков можно перевести в <strong>проценты</strong>, просто домножив на 100:</p>

    <p class="fake-code"><span class="code-line">датафрейм.isna().mean()*100</span></p>

    <pre class="line-numbers"><code class="language-python">df.isna().mean()*100</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>0.312159</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>0.577493</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0.0</td>
        </tr>
        </tbody>
    </table>
</div>


    <h3>ЗАМЕНА ПРОПУСКОВ</h3>

    <p>Пропуски в данных принято заменять на подходящую меру центральной тенденции. Пропуски в <strong>количественном</strong> признаке заменяют на <strong>медиану</strong>, а в <strong>категориальном</strong> - на <strong>моду</strong>. Заменить пропуски можно с помощью метода <span class="code-chip">.fillna()</span>:</p>

    <p class="fake-code"><span class="code-line">датафрейм['новый признак'] = датафрейм['признак'].fillna(на что заменяем)</span></p>

    <p>Этот метод работает следующим образом: если в <span class="code-chip">признаке</span> значение не пропущено, то <span class="code-chip">.fillna()</span> просто переносит его в <span class="code-chip">новый признак</span>, а если он видит <span class="code-chip">NaN</span>, то записывает вместо него в <span class="code-chip">новый признак</span> то, что мы указали в круглых скобках.</p>

    <p>Количестве людей, поставивших оценку (<strong>votes</strong>) является количественным признаком, поэтому заменим пропуски в нем на медиану, а чистый столбец без пропусков сохраним в новый признак (<strong>votes_clean</strong>):</p>

    <pre class="line-numbers"><code class="language-python">med = df['votes'].median()  # медиана
df['votes_clean'] = df['votes'].fillna(med)  # заменяем
df.isna().sum()  # проверяем</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>20</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>37</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes_clean</th>
            <td>0</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>В столбце <strong>votes</strong> пропуски остались на месте, а вот в <strong>votes_clean</strong> пропусков уже нет. В дальнейшем, если вам понадобится столбец с количеством людей, оценивших ресторан, мы будем работать уже с новым признаком <strong>votes_clean</strong>.</p>

    <p>Второй столбец с пропусками, <strong>restaurant_type</strong> - это тип ресторана. Столбец категориальный, поэтому пропуски в нем мы заменим на моду. Для начала рассчитаем моду для этого признака:</p>

    <pre class="line-numbers"><code class="language-python">df['restaurant_type'].mode()</code></pre>

    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>restaurant_type</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>Quick Bites</td>
        </tr>
        </tbody>
    </table>


    <p>Напомним, что этот метод возвращает не просто значение, а Series таблицу. Чтобы извлечь значение моды, к нему нужно обратиться по индексу:</p>

    <pre class="line-numbers"><code class="language-python">md = df['restaurant_type'].mode()[0]
md</code></pre>

    <p>Теперь мы можем заменить пропуски в признаке на значение моды, а результаты сохраним в новый признак <strong>restaurant_type_clean</strong>:</p>

    <pre class="line-numbers"><code class="language-python">df['restaurant_type_clean'] = df['restaurant_type'].fillna(md)  # заменяем
df.isna().sum()  # проверяем</code></pre>

        <div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>20</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>37</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes_clean</th>
            <td>0</td>
        </tr>
        <tr>
            <th>restaurant_type_clean</th>
            <td>0</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Теперь в <strong>restaurant_type_clean</strong> пропусков нет.</p>

</section>

<section><a href="https://edu.hse.ru/mod/quiz/view.php?id=1610940" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>
    <div style="height: 50px;"></div>
</section>
</div>

<div style="height: 0px; padding: 20px;"></div>
<div> <!-- ГЛАВА 7 -->
        <section>
            <h1 style="font-size: 30px; color:#1e01da;"id="chapter7">Глава 7. Корреляция</h1>
            <h2 id="chapter7-1">7.1 Что такое корреляция?</h2>
            <p>Корреляционный анализ является важным инструментом
                для понимания взаимосвязей между различными факторами.
                Например, мы хотим оценить связь между расходами на рекламу
                ресторана и средним рейтингом или выяснить, есть ли какая-то связь
                между местоположением ресторана и размером чека; ответить на эти вопросы
                нам помогут коэффициенты корреляции</p>
            <div class="definition-card">
                <div class="definition-text">
                    <strong>Корреляция </strong> - мера статистической связи между двумя признаками.
                </div>
            </div>
            <p>Любой из коэффициентов корреляции обладает следующими свойствами:</p>
            <ul>
                <li>Корреляция меняется в диапазоне от <strong>-1 до 1</strong></li>
                <li>Чем ближе корреляция к 0, тем слабее связь между признаками.</li>
            </ul>
            <p><em>В теории мы говорим, что когда корреляция равна 0 - это отсутствие связи, но на практике корреляция от -0.1 до 0.1 также приравнивается к отсутствию связи между признаками.</em></p>
            <ul>
                <li>Чем ближе корреляция к -1 или 1, тем сильнее связь между признаками</li>
                <Li>Если корреляция отрицательная, это значит что между признаками <strong>обратная взаимосвязь</strong>: если значение одного признака А увеличивается, то значение признака В снижается (и наоборот)</Li>
                <li>Если корреляция положительная, это значит, что между признаками <strong>прямая взаимосвязь</strong>: если значение одного признака А увеличивается, то значение признака В тоже увеличивается (и наоборот)</li>
            </ul>
            <img src="picture/21.svg" width="100%" alt="Рисунок 21">
            <div class="accordion-item">
                <button class="accordion-button" style="width: 800px;">КОРРЕЛЯЦИЯ НЕ ЗНАЧИТ ВЛИЯНИЕ</button>
                <div class="accordion-content" style="padding-left: 20px;">
                    <p>Корреляция не говорит о причинно-следственных связях. На ее основе мы не можем говорить о влиянии одного признака на другой, но можем говорить о направлении изменений и о силе взаимосвязи.</p>
                    <p>Поэтому при интерпретации корреляции некорректно использовать такие фразы как: <em>"А влияет/не влияет на B" или "А является/не является причиной на B"</em></p>
                </div>
            </div>
            <p>В зависимости от того, какую взаимосвязь мы хотим рассмотреть и между какими признаками, нужно рассчитывать определенные коэффициенты корреляции. Рассмотрим два вида: корреляции Пирсона и Спирмена.</p>
            <p style="font-size: 25px;"><strong>КОРРЕЛЯЦИЯ ПИРСОНА</strong></p>
            <div class="definition-card">
                <div class="definition-text">
                    <strong>Корреляция Пирсона</strong> - это статистический показатель, используемый для измерения силы и направления <em>линейной</em> связи между двумя <em>количественными признаками</em>.
                </div>
            </div>
            <p>Значение корреляции Пирсона можно корректно интерпретировать только между двумя <strong>количественными признаками</strong>.
                Чтобы получить наиболее точную оценку коэффициента корреляции, количественные признаки должны быть <em>очищены от выбросов</em>, так как Пирсон чувствителен к экстремальным значениям; также распределение данных каждого признака должно быть <em>симметричным и унимодальным</em>.</p>
            <p>Особенность корреляции Пирсона в том, что она оценивает только степень <strong>линейной связи</strong>. То есть, чем больше данные на диаграмме рассеяния <em>похожи на прямую линию</em>,
                тем сильнее будет корреляция Пирсона, тем ближе она будет либо к -1, либо к 1:</p>
            <img src="picture/22.svg" width="100%" alt="Рисунок 22">
            <p>Важнее схожести с прямой только <em>направление данных</em> на диаграмме рассеяния:</p>
            <ul>
                <li>Если данные направлены вниз (на диаграммах слева):</li>
                <ul>
                    <li>коэффициент корреляции Пирсона <em>отрицательный</em>;</li>
                    <li>между признаками <em>обратная линейная связь</em>;</li>
                    <li>при увеличении одного признака, другой будет уменьшаться (и наоборот).</li>
                </ul>
                <li>Если данные <em>направлены вверх</em> (на диаграммах справа):</li>
                <ul>
                    <li>коэффициент корреляции Пирсона <em>положительный</em>;</li>
                    <li>между признаками <em>прямая линейная связь</em>;</li>
                    <li>при увеличении одного признака, другой будет тоже расти (и наоборот)</li>
                </ul>
                <li>Если мы не можем сказать, какое у данных направление (диаграммы по центру):</li>
                <ul>
                    <li>коэффициент корреляции Пирсона <em>близок к нулю</em>;</li>
                    <li>между признаками <em>отсутствует линейная связь</em>;</li>
                    <li>между признаками может существовать <em>нелинейная связь</em>.</li>
                </ul>
            </ul>
            <p>Рассмотрим подробнее случаи, когда корреляция Пирсона между признаками равна нулю. Если точки на диаграмме рассения сложились в идеальную прямую, но она идет строго вертикально или строго горизонтально, корреляция Пирсона все равно будет равна нулю, так как при изменении одного показателя другой не будет меняться.</p>
            <p>Кроме того, данные не всегда связаны линейной связью. Корреляция Пирсона, равная нулю, говорит нам, что данные не похожи на прямую, но при этом признаки могут быть связаны какой-то другой зависимостью, как на примерах ниже:</p>
            <img src="picture/23.svg" width="100%" alt="Рисунок 23">
            <p style="font-size: 25px;"><strong>КОРРЕЛЯЦИЯ СПИРМЕНА</strong></p>
            <div class="definition-card">
                <div class="definition-text"><strong>Монотонность</strong>— это тип связи, при котором один признак только увеличивается или только уменьшается вслед за другим, без перемен направления.</div>
            </div>
            <img src="picture/24.svg" width="100%" alt="Рисунок 24">
            <p>Если Пирсон создан, чтобы "ловить" линейные зависимости, то Спирмен позволяет оценивать силу любых видов монотонных зависимостей, в том числе линейной.</p>
            <p>При интепретации корреляции Спирмена мы смотрим в первую очередь на направление данных:</p>
            <ul>
                <li>Если данные <em>направлены вниз</em> (на диаграммах слева)</li>
                <ul>
                    <li>коэффициент корреляции Спирмена <em>положительный</em>;</li>
                    <li>между признаками <em>убывающая монотонная связь</em>;</li>
                    <li>при увеличении одного признака, другой будет уменьшаться (и наоборот)</li>
                </ul>
                <li>Если данные <em>направлены вверх</em> (на диаграммах справа):</li>
                <ul>
                    <li>коэффициент корреляции Спирмена <em>положительный</em>;</li>
                    <li>между признаками <em>возрастающая монотонная связь</em>;</li>
                    <li>при увеличении одного признака, другой будет тоже расти (и наоборот).</li>
                </ul>
                <li>Если мы не можем сказать, какое у данных направление (диаграммы по центру):</li>
                <ul>
                    <li>коэффициент корреляции Спирмена <em>близок к нулю</em>;</li>
                    <li>между признаками <em>отсутствует монотонная связь</em>;</li>
                    <li>между признаками может существовать <em>немонотонная связь</em>.</li>
                </ul>
            </ul>
            <img src="picture/25.svg" width="100%" alt="Рисунок 25">
            <p>Помимо этого, само значение коэффициента корреляции Спирмена,
                указывает нам на силу монотонности. Чем ближе он к -1 или 1,
                тем ближе данные к <em>идеальной монотонной связи</em>. Если значение равно 0,
                то между признаками отсутсвует моннотонная связь. Промежуточные значения
                (например, 0.5 или -0.7) показывают <em>частичную монотонную связь</em>. Частичная
                монотонность означает, что, в целом, с увеличением одной переменной, другая
                переменная <strong>в основном</strong> увеличивается (или уменьшается), но не всегда строго и
                последовательно. Могут быть небольшие отклонения или "шумы" в данных, которые
                нарушают строгую монотонность, но при этом общая тенденция сохраняется.</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe_new">
                    <thead>
                    <tr>
                        <th></th>
                        <th>Признак А</th>
                        <th>Признак В</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>Корреляция Пирсона</strong></td>
                        <td>Количественный</td>
                        <td>Количественный</td>
                    </tr>
                    <tr>
                        <td><strong>Корреляция Спирмена</strong></td>
                        <td>Порядковый</td>
                        <td>Порядковый</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>Количественный</td>
                        <td>Порядковый</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>Количественный</td>
                        <td>Количественный</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <div style="height: 10px;"></div>
            <h2><strong>7.2 Как расчитать корреляцию?</strong></h2>
            <p>В прошлом разделе мы рассмотрели теоретические аспекты корреляции и то,
                как корреляцию можно оценить по диаграмме рассеяния. Теперь пришло время
                научиться рассчитывать корреляцию с использованием метода <span class="code-chip">.corr()</span> библиотеки
                Pandas. Для этого обратимся к нашим данным по ресторанам <a href="https://edu.hse.ru/mod/resource/view.php?id=1618517">restaurants.csv</a>
                :</p>
            <div class="scrollable-table">
                <table border="1" class="dataframe_new" style="width: 100%;">
                    <thead>
                    <tr>
                        <th>ПРИЗНАК</th>
                        <th>ОПИСАНИЕ</th>
                        <th>ФОРМАТ ДАННЫХ<br>(`.dtypes`)</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>name</strong></td>
                        <td>название ресторана</td>
                        <td>object</td>
                    </tr>
                    <tr>
                        <td><strong>restaurant_type</strong></td>
                        <td>тип ресторана</td>
                        <td>object</td>
                    </tr>
                    <tr>
                        <td><strong>rate</strong></td>
                        <td>рейтинг ресторана</td>
                        <td>float64</td>
                    </tr>
                    <tr>
                        <td><strong>votes</strong></td>
                        <td>количество людей, поставивших оценку ресторана</td>
                        <td>int64</td>
                    </tr>
                    <tr>
                        <td><strong>avg_receipt</strong></td>
                        <td>средний размер чека на двоих в ресторане</td>
                        <td>float64</td>
                    </tr>
                    <tr>
                        <td><strong>online_order</strong></td>
                        <td>возможность сделать онлайн заказ (1 - есть, 0 - нет)</td>
                        <td>int64</td>
                    </tr>
                    <tr>
                        <td><strong>table_booking</strong></td>
                        <td>возможность забронировать столик (1 - есть, 0 - нет)</td>
                        <td>int64</td>
                    </tr>
                    <tr>
                        <td><strong>cuisines_type</strong></td>
                        <td>кухня в ресторане</td>
                        <td>object</td>
                    </tr>
                    <tr>
                        <td><strong>area</strong></td>
                        <td>район, где расположен ресторан</td>
                        <td>object</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Одно <strong>наблюдение</strong> - это один <strong>ресторан</strong>.</p>
            <pre class="line-numbers"><code class="language-python">import pandas as pd
df = pd.read_csv('restaurants.csv')
df.head()</code></pre>

            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th>name</th>
                        <th>restaurant_type</th>
                        <th>rate</th>
                        <th>votes</th>
                        <th>avg_receipt</th>
                        <th>online_order</th>
                        <th>table_booking</th>
                        <th>cuisines_type</th>
                        <th>area</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>#FeelTheROLL</strong></td>
                        <td>Quick Bites</td>
                        <td>3.4</td>
                        <td>7.0</td>
                        <td>200.00</td>
                        <td>0</td>
                        <td>0</td>
                        <td>Fast Food</td>
                        <td>Bellandur</td>
                    </tr>
                    <tr>
                        <td><strong>#L-81 Cafe</strong></td>
                        <td>Quick Bites</td>
                        <td>3.9</td>
                        <td>48.0</td>
                        <td>400.0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>Fast Food, Beverages</td>
                        <td>Byresandra,Tavarekere,Madiwala</td>
                    </tr>
                    <tr>
                        <td><strong>#refuel</strong></td>
                        <td>Cafe</td>
                        <td>3.7</td>
                        <td>NaN</td>
                        <td>400.0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>Cafe, Beverages</td>
                        <td>Bannerghatta Road</td>
                    </tr>
                    <tr>
                        <td><strong>'@ Biryani Central</strong></td>
                        <td>Casual Dining</td>
                        <td>2.7</td>
                        <td>135.0</td>
                        <td>550.0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>Biryani, Mughlai, Chinese</td>
                        <td>Marathahalli</td>
                    </tr>
                    <tr>
                        <td><strong>'@99</strong></td>
                        <td>Takeaway, Delivery</td>
                        <td>3.4</td>
                        <td>37.0</td>
                        <td>200.0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>Mughlai, Biryani, Chinese, North Indian</td>
                        <td>Whitefield</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p style="font-size: 25px;"><strong>ПАРНАЯ КОРРЕЛЯЦИЯ</strong></p>
            <p>Корреляция между двумя конкретными признаками называется парной корреляцией.</p>
            <p style="font-size: 20px;"><strong>Корреляция Пирсона</strong></p>
            <p>Чтобы рассчитать корреляцию Пирсона, используем следующий синтаксис метода <span class="code-chip">.corr()</span>:</p>
            <p class="fake-code">
<span class="code-line">датафрейм['признак 1'].corr(датафрейм['признак 2'])  # Пирсон</span>
            </p>
            <p>Например, мы хотим оценить степень линейной взаимосвязи между рейтингом ресторана
                (<strong>rate</strong>) и количеством людей, поставивших оценку (<strong>votes</strong>) - тогда пишем следующий код:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].corr(df['votes'])</code></pre>
            <div class="print_result">np.float64(0.3932832917441752)</div>
            <p>С точки зрения синтаксиса неважно, какой признак мы укажем первым,
                <strong>rate</strong> или <strong>votes</strong>, значение корреляции от этого не изменится.</p>
            <p>Сила этой линейной зависимости <em>довольно слабая</em>, так как коэффициент корреляции ближе к 0,
                чем к 1. Корреляция получилась <em>положительная</em>, значит между рейтингом (<strong>rate</strong> и количеством
                людей, поставивших оценку (<strong>votes</strong>), <em>прямая линейная</em> взаимосвязь. Это значит, что если вырастет
                рейтинг (<strong>rate</strong>), то, скорее всего, вырастет количество людей, поставивших оценку ресторану (<strong>votes</strong>)</p>
            <div class="accordion-item">
                <button class="accordion-button" style="width: 800px;">Критическая оценка полученного значения</button>
                <div class="accordion-content" style="padding-left: 20px;">
                    <p>Мы не можем до конца верить полученной оценке линейной связи, так как перед этим не
                        проверили распределение признаков и не очистили данные от выбросов. При приведении
                        распределения к симметричному унимодальному виду и очистке от выбросов значение
                        корреляции Пирсона может как вырасти, так и стать еще ближе к 0. Но в любом случае,
                        эти шаги позволят узнать истинную оценку линейности, что для нас гараздо важнее.</p>
                </div>
            </div>

            <p style="font-size: 25px;"><strong>Корреляция Спирмена</strong></p>
            <p>Для рассчета корреляции Спирмена, внутрь метода <span class="code-chip">.corr()</span>,
                    нужно добавить параметр <span class="code-chip">method='spearman'</span>:</p>
            <p class="fake-code"><span class="code-line">датафрейм['признак 1'].corr(датафрейм['признак 2'], method='spearman')  # Спирмен</span></p>
            <p>Оценим уровень монотонности между рейтингом (<strong>rate</strong>) и возможностью делать онлайн заказ (<strong>online_order</strong>) в ресторане:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].corr(df['online_order'], method='spearman')</code></pre>
            <div class="print_result">np.float64(0.09041970519401271)</div>
            <p>Здесь также не важен порядок, в котором мы указали признаки: значение корреляции от этого не изменится.</p>
            <p>Корреляция Спирмена получилось крайне близкая к 0 (значение корреляции менее 0.1) - это говорит о том,
                что между признаками отсутствует монотонная связь. Значит мы не можем сказать, что если в ресторане
                появится возможность заказать онлайн (<strong>online_order</strong> станет равным 1, вместо 0), рейтинг (<strong>rate</strong>) тоже
                увеличится, или что с ростом рейтинга (<strong>rate</strong>) появится возможность сделать онлайн заказ (<strong>online_order</strong>
                станет равным 1, вместо 0)</p>
            <p style="font-size: 25px;"><strong>КОРРЕЛЯЦИОННАЯ МАТРИЦА</strong></p>
                        <p>Парная корреляция показывает зависимость только одной
                            конкретной пары признаков, но если мы хотим автоматически
                            рассчитать корреляцию между всеми признаками в данных
                            (представленных в числовом формате <span class="code-chip">int64</span> или <span class="code-chip">float64</span>),
                            то удобнее будет рассчитать корреляционную матрицу.</p>
                        <div class="definition-card">
                            <div class="definition-text">
                                <strong>Корреляционная матрица</strong> —  это таблица, показывающая корреляции (степень взаимосвязи) между всеми возможными парами признаков в наборе данных.
                            </div>
                        </div>
                        <p>Любая корреляционная матрица обладает двумя свойствами:</p>
                        <ul>
                            <li>По центральной диагонали идут единицы. Это корреляция признака с самим собой (<strong>автокорреляция</strong>); например, корреляция А с А или корреляция B c B.</li>
                            <li>Матрица симметрична относительно центральной оси. Это значит, что значения сверху полностью дублируют значения снизу. Это обусловлено тем, что корреляция A и B равна корреляции B и A</li>
                        </ul>
            <img src="picture/26.svg" width="100%" alt="Рисунок 26">
            <p>Чтобы рассчитать корреляционную матрицу по методу Пирсона, к датафрейму достаточно применить метод <span class="code-chip">.corr()</span>:</p>
            <p class="fake-code">
<span class="code-line">датафрейм.corr()  # Пирсон</span>
            </p>
            <p>Если нужна корреляционная матрица, рассчитанная по <strong>Спирмену</strong>,
                аналогично парной, внутрь добавляем параметр <span class="code-chip">method='spearman'</span>:</p>
            <p class="fake-code">
<span class="code-line">датафрейм.corr(method='spearman')  # Спирмен</span>
            </p>
            <div class="accordion-item">
                <button class="accordion-button" style="width: 800px;"><strong>Ошибка</strong> <span class="code-chip" style="color: black;">ValueError: could not convert string to float</span></button>
                <div class="accordion-content" style="padding-left: 20px;">
                    <p>Метод <span class="code-chip">.corr()</span> рассчитывает корреляционные
                        матрицы исключительно для колонок с численными
                        значениями (<span class="code-chip">int64</span>, <span class="code-chip">float64</span>), а в датарейме могут
                        быть колонки и с текстовой информацией (<span class="code-chip">object</span>).
                        Чтобы показать методу, что надо брать только численные
                        колонки, внутрь <span class="code-chip">.corr()</span> добавляем параметр
                        <span class="code-chip">numeric_only=True</span>:</p>
                    <p class="fake-code">
<span class="code-line">датафрейм.corr(numeric_only=True)  # Пирсон</span>
                    </p>
                    <p>или</p>
                    <p class="fake-code">
<span class="code-line">датафрейм.corr(method='spearman', numeric_only=True)  # Спирмен</span>
                    </p>
                </div>
            </div>
            <p></p>


            <p>Построим корреляционную матрицу, рассчитанную методом Пирсона, по нашим данным:</p>
            <pre class="line-numbers"><code class="language-python">df.corr()  # Пирсон</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>rate</th>
                        <th>votes</th>
                        <th>avg_receipt</th>
                        <th>online_order</th>
                        <th>table_booking</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>rate</strong></td>
                        <td>1.000000</td>
                        <td>0.393283</td>
                        <td>0.381275</td>
                        <td>0.071802</td>
                        <td>0.407116</td>
                    </tr>
                    <tr>
                        <td><strong>votes</strong></td>
                        <td>0.393283</td>
                        <td>1.000000</td>
                        <td>0.337944</td>
                        <td>0.020665</td>
                        <td>0.369404</td>
                    </tr>
                    <tr>
                        <td><strong>avg_receipt</strong></td>
                        <td>0.381275</td>
                        <td>0.337944</td>
                        <td>1.000000</td>
                        <td>-0.132518</td>
                        <td>0.606666</td>
                    </tr>
                    <tr>
                        <td><strong>online_order</strong></td>
                        <td>0.071802</td>
                        <td>0.020665</td>
                        <td>-0.132518</td>
                        <td>1.000000</td>
                        <td>-0.033091</td>
                    </tr>
                    <tr>
                        <td><strong>table_booking</strong></td>
                        <td>0.407116</td>
                        <td>0.369404</td>
                        <td>0.606666</td>
                        <td>-0.033091</td>
                        <td>1.000000</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Все свойства, о которых мы говорили выше, здесь есть.
                По центральной диагонали идут единицы, это автокорреляция
                (<strong>rate</strong> c <strong>rate</strong>, <strong>votes</strong> с <strong>votes</strong> и т.д.). Матрица зеркальна
                относительно центральной диагонали: например, корреляция
                <strong>rate</strong> с <strong>votes</strong> - это то же самое, что <strong>votes</strong> с <strong>rate</strong>, и равно
                0.39.</p>
            <p>Метод <span class="code-chip">.corr()</span> автоматически посчитал корреляции между всеми признаками
                в числовом формате. Например, мы видим, что в матрице представлены
                корреляции с признаками <strong>online_order</strong> и <strong>table_booking</strong>. Они являются
                категориальными бинарными, хотя данные там и закодированы цифрами
                0 и 1. Мы помним из прошлого раздела, что корреляция Пирсона может
                быть интерпретирована только между количественными признаками,
                поэтому значения корреляции Пирсона, связанные с этими признаками,
                не стоит брать в рассчет.</p>
            <p>Чтобы убрать ненужные признаки из корреляционной
                матрицы, которая с точки зрения формата данных
                является DataFrame, передадим список только с
                количественными признаками и только по ним построим
                матрицу:</p>
            <pre class="line-numbers"><code class="language-python">df[['rate',	'votes', 'avg_receipt']].corr()</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>rate</th>
                        <th>votes</th>
                        <th>avg_receipt</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>rate</strong></td>
                        <td>1.000000</td>
                        <td>0.393283</td>
                        <td>0.381275</td>
                    </tr>
                    <tr>
                        <td><strong>votes</strong></td>
                        <td>0.393283</td>
                        <td>1.000000</td>
                        <td>0.337944</td>
                    </tr>
                    <tr>
                        <td><strong>avg_receipt</strong></td>
                        <td>0.381275</td>
                        <td>0.337944</td>
                        <td>1.000000</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Теперь в корреляционной матрице Пирсона ничего лишнего,
                и ее можно проанализировать. Между всеми признаками
                прямая линейная зависимость, так как корреляция только
                положительная. При этом сила линейной взаимосвязи между
                признаками довольно небольшая, так как все значения
                (без учета автокорреляцции) ближе к 0, чем к 1</p>
            <p>Среди представленных признаков, самая сильная линейная
                взаимосвязь между рейтингом (<strong>rate</strong>) и количеством
                людей, поставивших оценку ресторану (<strong>votes</strong>) и равна
                она 0.39.</p>
            <p>Самая слабая корреляция (0.34) между количеством оценивших ресторан
                <strong>votes</strong> и размером чека в ресторане (<strong>avg_receipt</strong>).</p>
            <p>Теперь построим корреляционную матрицу, где значения коэффициентов будут рассчитаны по методу Спирмена:</p>
            <pre class="line-numbers"><code class="language-python">df.corr(method='spearman')  # Спирман</code></pre>
            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>rate</th>
                        <th>votes</th>
                        <th>avg_receipt</th>
                        <th>online_order</th>
                        <th>table_booking</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>rate</strong></td>
                        <td>1.000000</td>
                        <td>0.637504</td>
                        <td>0.327650</td>
                        <td>0.090420</td>
                        <td>0.403877</td>
                    </tr>
                    <tr>
                        <td><strong>votes</strong></td>
                        <td>0.637504</td>
                        <td>1.000000</td>
                        <td>0.472264</td>
                        <td>0.230633</td>
                        <td>0.430287</td>
                    </tr>
                    <tr>
                        <td><strong>avg_receipt</strong></td>
                        <td>0.327650</td>
                        <td>0.472264</td>
                        <td>1.000000</td>
                        <td>-0.008403</td>
                        <td>0.488844</td>
                    </tr>
                    <tr>
                        <td><strong>online_order</strong></td>
                        <td>0.090420</td>
                        <td>0.230633</td>
                        <td>-0.008403</td>
                        <td>1.000000</td>
                        <td>-0.033091</td>
                    </tr>
                    <tr>
                        <td><strong>table_booking</strong></td>
                        <td>0.403877</td>
                        <td>0.430287</td>
                        <td>0.488844</td>
                        <td>-0.033091</td>
                        <td>1.000000</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>Корреляцию Спирмена корректно интерпретировать
                как для количественных, так для и категориальных
                признаков, поэтому извлекать определенные столбцы
                нет необходимости.</p>
            <p>Наиболее сильная монотонная связь, аналогично Пирсону,
                между рейтингом (<strong>rate</strong>) и количеством людей, поставивших
                оценку ресторану (<strong>votes</strong>) и составляет 0.63. Сила этой
                монотонной связи - умеренная.</p>
            <p>Практически нулевые значения корреляции между размером
                чека <strong>avg_receipt</strong> и <strong>online_order</strong>, <strong>online_order</strong> и <strong>table_booking</strong>,
                    <strong>online_order</strong> и <strong>rate</strong> говорят о том, что между парами этих
                признаков отсутствует монотонная связь.</p>
            <p>При этом, например, у возможности забронировать столик (<strong>table_booking</strong>) и размера чека (<strong>avg_receipt</strong>)
                наблюдается слабая возрастающая монотонная связь равная 0.49,
                - это говорит о том, что если в ресторане появится возможность
                бронировать столик (<strong>table_booking</strong> станет 1, вместо 0) размер
                чека в нем тоже может вырасти (<strong>avg_receipt</strong>), или что если цены
                в ресторане вырастут (<strong>avg_receipt</strong> станет больше), то может появиться
                возможность бронировать столик (<strong>table_booking</strong> станет 1, вместо 0).</p>
            <a href="https://edu.hse.ru/mod/quiz/view.php?id=1610941" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>&nbsp;<a href="https://edu.hse.ru/mod/quiz/view.php?id=1610942" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>



        </section>
</div>

<div style="height: 0px; padding: 20px;"></div>
<div> <!-- ГЛАВА 8 -->
        <section>
            <h1 style="font-size: 30px; color:#1e01da;"id="chapter8">Глава 8. Линейная регрессия</h1>
            <h2 id="chapter8-1">8.1 Что такое регрессия?</h2>
            <p>Регрессия представляет собой мощный статистический инструмент, позволяющий выявлять и анализировать взаимосвязи между явлениями. Эта методика незаменима, когда необходимо установить, каким образом изменение одной величины влияет на другую величину. Регрессия помогает исследователю строить прогнозы, оценивать последствия различных воздействий и находить скрытые закономерности в данных. Применение регрессионного анализа широко востребовано в маркетинге, социологии и многих других областях науки и практики, обеспечивая глубокое понимание сложных процессов и принятие обоснованных решений.</p>
            <div class="definition-card">
                <div class="definition-text">
                    <strong>Регрессия </strong> - уравнение, которое показывает как один или несколько факторов оказывают влияние на другой целевой признак.
                </div>
            </div>

            <p>Предположим, у нас есть выборка по семи ресторанам. Про каждый из этих ресторанов нам известен средний размер чека (<strong>avg_receipt</strong>), рейтинг (<strong>rate</strong>) и местоположение (<strong>area</strong>; <em>0</em> - центр, <em>1</em> - не центр):</p>

    <pre class="line-numbers"><code class="language-python">import pandas as pd

df = pd.DataFrame()
df['avg_receipt'] = [50, 100, 200, 200, 150, 350, 350]
df['rate'] = [0.5, 1.5, 1.5, 2.5, 3.5, 3.5, 4.5]
df['area'] = [1, 1, 0, 0, 0, 0, 0]
df</code></pre>


<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>avg_receipt</th>
            <th>rate</th>
            <th>area</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>50</td>
            <td>0.5</td>
            <td>1</td>
        </tr>
        <tr>
            <th>1</th>
            <td>100</td>
            <td>1.5</td>
            <td>1</td>
        </tr>
        <tr>
            <th>2</th>
            <td>200</td>
            <td>1.5</td>
            <td>0</td>
        </tr>
        <tr>
            <th>3</th>
            <td>200</td>
            <td>2.5</td>
            <td>0</td>
        </tr>
        <tr>
            <th>4</th>
            <td>150</td>
            <td>3.5</td>
            <td>0</td>
        </tr>
        <tr>
            <th>5</th>
            <td>350</td>
            <td>3.5</td>
            <td>0</td>
        </tr>
        <tr>
            <th>6</th>
            <td>350</td>
            <td>4.5</td>
            <td>0</td>
        </tr>
        </tbody>
    </table>
</div>

<img src="picture/chapter8/27.svg" width="100%" alt="Рисунок 27">


<p>Мы хотим выяснить, как рейтинг ресторана (<strong>rate</strong>) влияет на средний размер чека (<strong>avg_receipt</strong>) в нем. Запишем это в чуть более математической форме:</p>

<p>avg_receipt = w<sub>0</sub> + w<sub>1</sub> * rate</p>

<p>Мы хотим предсказать размер чека (<strong>avg_receipt</strong>). С точки зрения регрессии этот признак называется <strong>целевой</strong> или <strong>зависимой переменной</strong>. В уравнении линейной регрессии целевой переменной может выступать только <strong>количественный признак</strong>.</p>

<p>Рейтинг ресторана (<strong>rate</strong>) - фактор, оказывающий влияние на размер чека (<strong>avg_receipt</strong>). В модели регрессии рейтинг (<strong>rate</strong>) - это <strong>предиктор</strong> или <strong>независимая переменная</strong>. В отличие от целевой, предиктором может быть выступать и количественный, и категориальный признак.</p>

<p>На вопрос, <em>как</em> рейтинг (<strong>rate</strong>) влияет на размер чека (<strong>avg_receipt</strong>), отвечают параметры (коэффициенты) регрессии w<sub>0</sub> и w<sub>1</sub>. w<sub>0</sub> называют <strong>свободным коэффициентом</strong>. Он стоит в одиночестве, без пары, в отличие от w<sub>1</sub> - <strong>коэффициента независимой переменной</strong>.</p>

<p>Регрессия, в которой только один предиктор (в нашем случае это рейтинг (<strong>rate</strong>)), называется <strong>однофакторной</strong>.</p>

<p>Но мы понимаем, что в реальной жизни не только рейтинг (<strong>rate</strong>) влияет на размер чека (<strong>avg_receipt</strong>). На него может влиять тип кухни, количество сотрудников и многое другое. Такая регрессия, с более чем одним предиктором, называется <strong>многофакторной</strong>. В наших данных, помимо рейтинга, есть еще местоположение (<strong>area</strong>). Если мы хотим добавить этот фактор в модель, то с точки зрения математики регрессию можно записать так:</p>

<p>avg_receipt = w<sub>0</sub> + w<sub>1</sub> * rate + w<sub>2</sub> * area</p>

<p><strong>rate</strong>, <strong>area</strong> - это независимые переменные регрессии.</p>

<p>w<sub>1</sub>, w<sub>2</sub> - коэффициенты независимых переменных</p>

<p>w<sub>0</sub> - свободный коэффициент</p>

<div class="scrollable-table">
<table border="1" class="dataframe_new" style="width: 100%;">
    <tr>
        <th></th>
        <th>ОДНОФАКТОРНАЯ</th>
        <th>МНОГОФАКТОРНАЯ</th>
    </tr>
    <tr>
        <td><strong>Уравнение регрессии</strong></td>
        <td>Ŷ=w<sub>0</sub>+w<sub>1</sub>*X</td>
        <td>Ŷ=w<sub>0</sub>+w<sub>1</sub>*X<sub>1</sub>+...+w<sub>k</sub>*X<sub>k</sub></td>
    </tr>
    <tr>
        <td><strong>Целевая (зависимая) переменная</strong> <br> <em>только количественная</em></td>
        <td>Ŷ</td>
        <td>Ŷ</td>
    </tr>
    <tr>
        <td><strong>Предикторы/независмые переменные</strong></td>
        <td>X</td>
        <td>X<sub>1</sub>, ..., X<sub>k</sub></td>
    </tr>
    <tr>
        <td colspan="3">Параметры:</td>
    </tr>
    <tr>
        <td><strong>Коэффициенты независимой <br> переменной</strong></td>
        <td>w<sub>1</sub></td>
        <td>w<sub>1</sub>, ..., w<sub>k</sub></td>
    </tr>
    <tr>
        <td><strong>Свободный коэффициент</strong></td>
        <td>w<sub>0</sub></td>
        <td>w<sub>0</sub></td>
    </tr>
</table>
</div>
<div style="height: 30px;"></div>
<h2 id="chapter8-2">8.2 Как обучить линейную регрессию?</h2>

<p>После формализации модели нужно обучить ее. <strong>Обучить модель</strong> - значит рассчитать её параметры (w<sub>0</sub>, ..., w<sub>k</sub>). Параметры модели вычисляются по формулам, выведенным из <strong>метода наименьших квадратов (МНК)</strong>, или на английском ordinary least squares (OLS).</p>

<div class="accordion-container">
    <div class="accordion-item">
        <button class="accordion-button" style="width: 800px;">Формулы метода наименьших квадратов&nbsp;</button>
        <div class="accordion-content">
            
<p>Коэффициент независимой переменной (w<sub>1</sub>):</p>

<p>
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>w</mi><msub>1</msub>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mrow>
        <mo>(</mo>
        <mi>x</mi><msub>1</msub><mo>-</mo><mover><mi>x</mi><mo>¯</mo></mover>
        <mo>)</mo>
        <mo>⁢</mo>
        <mo>(</mo>
        <mi>y</mi><msub>1</msub><mo>-</mo><mover><mi>y</mi><mo>¯</mo></mover>
        <mo>)</mo>
        <mo>+</mo>
        <mo>…</mo>
        <mo>+</mo>
        <mo>(</mo>
        <mi>x</mi><msub>n</msub><mo>-</mo><mover><mi>x</mi><mo>¯</mo></mover>
        <mo>)</mo>
        <mo>⁢</mo>
        <mo>(</mo>
        <mi>y</mi><msub>n</msub><mo>-</mo><mover><mi>y</mi><mo>¯</mo></mover>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mrow>
      <mrow>
        <mo>(</mo>
        <mi>x</mi><msub>1</msub><mo>-</mo><mover><mi>x</mi><mo>¯</mo></mover>
        <mo>)</mo>
        <mo>+</mo>
        <mo>…</mo>
        <mo>+</mo>
        <mo>(</mo>
        <mi>x</mi><msub>n</msub><mo>-</mo><mover><mi>x</mi><mo>¯</mo></mover>
        <mo>)</mo>
      </mrow>
    </mrow>
  </mfrac>
</math>
</p>

<p><strong>x<sub>1</sub>, ... x<sub>n</sub></strong> - каждое из значений предиктора</p>

<p><strong>x̄</strong> - среднее арифметическое предиктора</p>

<p><strong>y<sub>1</sub>, ... y<sub>n</sub></strong> - каждое значение целевой переменной</p>

<p><strong>ȳ</strong> - среднее арифметическое целевой переменной</p>

<p><strong>n</strong> - количество наблюдений (в наших данных 7 наблюдений)</p>

<p>Свободный коэффициент (w<sub>0</sub>):</p>

<p>w<sub>0</sub> = ȳ - w<sub>1</sub> * x̄</p>

<p><strong>ȳ</strong> - среднее арифметическое целевой переменной</p>

<p><strong>w<sub>1</sub></strong> - коэффициент независимой переменной</p>

<p><strong>x̄</strong> - среднее арифметическое предиктора</p>
        </div>
    </div>
</div>

<p>Мы сконцертируемся на том, как обучить модель с помощью библиотеки <span class="code-chip">statsmodels.api</span>. Первое, что нам нужно сделать - импортировать библиотеку; при импорте дадим ей короткий псеводним <span class="code-chip">sm</span>:</p>

<pre class="line-numbers"><code class="language-python">import statsmodels.api as sm
</code></pre>

        <div class="accordion-container">
            <div class="accordion-item">
                <button class="accordion-button" style="width: 800px;">Ошибка <span class="code-chip" style="color: black;">ModuleNotFoundError: No module named 'statsmodels'</span>&nbsp;</button>
                <div class="accordion-content">
                    <p>Если при запуске кода вышла такая ошибка, это значит, что модуль Statsmodels еще не установлен на компьютере. Чтобы его установить, нужно перед импортом добавить строку:</p>
                    <pre class="line-numbers"><code class="language-python">!pip install statsmodels</code></pre>
                </div>
            </div>
        </div>


<p>В эту библиотеку уже зашиты формулы метода наименьших квадратов, поэтому нам не придется их учить, а нужно будет лишь написать несколько несложных команд, чтобы найти значения параметров:</p>

<ol>
    <li>Обозначаем целевую переменную:
        <p class="fake-code"><span class="code-line">Y = df['целевая']</span></p>
    </li>
    <li>Обозначем предиктор(ы) и добавляем константный признак с помощью функции <span class="code-chip">sm.add_constant()</span> для корректного рассчета коэффициентов регрессии:
        <p class="fake-code"><span class="code-line">X = sm.add_constant(df['предиктор'])  # однофакторная</span></p>
        или
        <p class="fake-code"><span class="code-line">X = sm.add_constant(df[['предиктор 1', 'предиктор 2', ...]]) # многофакторная</span></p>
    </li>
    <li>Обучаем (<span class="code-chip">.fit()</span>) линейную регрессию с помощью метода наименьших квадратов (<span class="code-chip">sm.OLS()</span>):
        <p class="fake-code"><span class="code-line">модель = sm.OLS(Y, X).fit()</span></p>
    </li>
    <li>Выводим параметры регрессии с помощью атрибута <span class="code-chip">.params</span>:
        <p class="fake-code"><span class="code-line">модель.params</span></p>
    </li>
</ol>

<div class="scrollable-table">
<table border="1" class="dataframe" style="width: 100%;">
    <tr>
        <th></th>
        <th>0</th>
        <th></th>
    </tr>
    <tr>
        <td><strong>const</strong></td>
        <td>w<sub>0</sub></td>
    </tr>
    <tr>
        <td><strong>предиктор 1</strong></td>
        <td>w<sub>1</sub></td>
    </tr>
    <tr>
        <td><strong>предиктор 2</strong></td>
        <td>w<sub>2</sub></td>
    </tr>
    <tr>
        <td>...</td>
        <td>...</td>
    </tr>
</table>
</div>

<p>Где w<sub>0</sub> - свободный коэффициент, а остальное - коэффициент независимой переменной</p>

<p>Для начала обучим однофакторную модель, которая только на основе рейтинга ресторана (<strong>rate</strong>) будет предсказывать средний размер чека (<strong>avg_receipt</strong>):</p>

<p>avg_receipt = w<sub>0</sub> + w<sub>1</sub> * rate</p>

<pre class="line-numbers"><code class="language-python">Y = df['avg_receipt']  # целевая перемменая
X1 = sm.add_constant(df['rate'])  # предиктор

model1 = sm.OLS(Y, X1).fit()  #обучаем модель
model1.params  # выводим параметры</code></pre>

<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>const</th>
            <td>33.333333</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>66.666667</td>
        </tr>
        </tbody>
    </table>
</div>

<p>avg_receipt = 33.33 + 66.67 * rate</p>

<p>Для обучения многофакторной регрессии, которая предскажет размер чека (<strong>avg_receipt</strong>) не только на основе рейтинга ресторана (<strong>rate</strong>), но и по местоположению (<strong>area</strong>), нужно написать следующий код:</p>

<p>avg_receipt = w<sub>0</sub> + w<sub>1</sub> * rate + w<sub>2</sub> * area</p>

<pre class="line-numbers"><code class="language-python">Y = df['avg_receipt']  # целевая перемменая
X2 = sm.add_constant(df[['rate', 'area']])  # предикторы

model2 = sm.OLS(Y, X2).fit()  #обучаем модель
model2.params  # выводим параметры
</code></pre>

<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>const</th>
            <td>100.438596</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>48.245614</td>
        </tr>
        <tr>
            <th>area</th>
            <td>-73.684211</td>
        </tr>
        </tbody>
    </table>
</div>

<p>avg_receipt = 100.44 + 48.25 * rate - 73.68 * area</p>

<div style="height: 30px;"></div>
<h2 id="chapter8-3">8.3 Как интерпретировать линейную регрессию?</h2>

<p>В прошлом разделе мы обучили линейную регрессию, а теперь нужно выяснить, что значат эти параметры.</p>

<h3>ГЕОМЕТРИЧЕСКАЯ ИНТЕРПРЕТАЦИЯ</h3>

<p>Рассмотрим уравнение однофакторной регрессии:</p>

<p>Ŷ = w<sub>0</sub> + w<sub>1</sub> * X</p>
<p>avg_receipt = 33.33 + 66.67 * rate</p>

<p>Такая регрессия на самом деле является уравнением прямой, которое вы наверняка проходили в школьном курсе геометрии. Если мы нанесем ее на диаграмму рассеяния, то она будет описывать тренд наших данных:</p>

<img src="picture/chapter8/28.svg" width="100%" alt="Рисунок 28">

<p>Свободный коэффициент w<sub>0</sub> (33.33) - это место, где прямая пересекает ось <strong>Y</strong>, т.е. ось целевой переменной (<strong>avg_receipt</strong>)</p>

<p>Коэффициент независимой переменной w<sub>1</sub> (66.67) регулирует угол наклона прямой. Если он положительный, как в нашем случае, это значит, признаки связаны прямой зависимостью, а если угол отрицательный, то обратной.</p>

<h3>ПРАКТИЧЕСКАЯ ИНТЕРПРЕТАЦИЯ</h3>

<p>Теперь рассмотрим, как можно объяснить практически полученные нами коэффициенты, и как можно интерепретировать регрессию в целом.</p>

<p>Для начала рассмотрим однофакторную регрессию:</p>
<p>avg_receipt = 33.33 + 66.67 * rate</p>

<ul>
    <li><p><strong>Интерпретация регрессии</strong></p></li>
</ul>

<p>Предположим, что в городе появился новый ресторан. Мы знаем, что его рейтинг <em>3.5 балла</em> (<strong>rate</strong>). И нам нужно выяснить, какой там средний размер чека. Все что нам нужно сделать, это вместо <strong>rate</strong> подставить 3.5 и посчитать:</p>

<pre class="line-numbers"><code class="language-python">33.33 + 66.67 * 3.5
</code></pre>
<p class="print_result">266.675</p>

<p>Получается, что в ресторане с рейтингом 3.5 (<strong>rate</strong>) средний размер чека (<strong>avg_receipt</strong>) будет составлять 266.675 у.е..</p>

<img src="picture/chapter8/29.svg" width="100%" alt="Рисунок 29">


<ul>
    <li><p><strong>Свободный коэффициент (w<sub>0</sub>)</strong></p></li>
</ul>

<p>В однофакторной регрессии свободный коэффициент (w<sub>0</sub>) показывает, чему будет равна целевая переменная (Ŷ), если предиктор (X) равен 0. В нашем случае – какой будет размер чека (<strong>avg_receipt</strong>) в ресторане с рейтингом (<strong>rate</strong>) 0. Согласно нашей модели, чек будет в среднем равен 33.33 у.е..</p>

<div class="important-card">
    <div class="important-text">
    Свободный коэффициент (w<sub>0</sub>) нельзя интепретировать в двух случачаях:
    <ul>
        <li>Если предиктор (X<sub>k</sub>) не может быть 0</li>
        <li>Если свободный коэффициент (w<sub>0</sub>) принимает недопустимые значения целевой переменной (Y)</li>
    </ul>
    <p><em>Пример</em>: Цена блюда = -10 + 0.5 * Вес</p>
    Вес блюда не может быть равным 0 (тогда блюда просто не будет существовать). Помимо этого, цена блюда не может быть отрицательной (тогда владельцам ресторана придется за него еще и доплачивать клиентам). Поэтому -10 здесь невозможно интерпретировать практически.
</div></div>

<ul>
    <li><p><strong>Коэффициент независимой переменной (w<sub>1</sub>)</strong></p></li>
</ul>

<p>Коэффициент независимой переменной (w<sub>1</sub>) показывает, как будет меняться целевая (Ŷ) при изменении предиктора (X). В нашей модели, предсказывающей размер чека на основе рейтинга, коэффициент независимой переменной равен 66.67. Это значит, что если рейтинг ресторана (<strong>rate</strong>) вырастет на 1 балл, это увеличит средний размер чека (<strong>avg_receipt</strong>) в нем на 66.67 у.е.. Если рейтинг (<strong>rate</strong>) вырастет на 2 балла, размер чека (<strong>avg_receipt</strong>) возрастет на 133.33 у.е., и так далее.</p>

<p>В случае, когда предиктор (X<sub>k</sub>) является <strong>количественным</strong>, как в нашем случае, то можно формализовать интепретацию его коэффициента (w<sub>k</sub>) следующим образом:</p>
<ul>
    <li>w<sub>k</sub> > 0
        <ul>
            <li>если X<sub>k</sub> увеличивается на n, Ŷ <strong>увеличится</strong> на w<sub>k</sub> * n</li>
        </ul>
    </li>
    <li>w<sub>k</sub> < 0
        <ul>
            <li>если X<sub>k</sub> увеличивается на n, Ŷ <strong>уменьшится</strong> на w<sub>k</sub> * n</li>
        </ul>
    </li>
    <li>w<sub>0</sub> = 0
        <ul>
            <li>X <strong>не оказывает влияние</strong> на Ŷ</li>
        </ul>
    </li>
</ul>

<p>Интерпретация многофакторной регрессии в целом имеет такую же логику, как и в простом варианте модели, но с несколькими нюансами. Давайте рассмотрим их на основе этой модели:</p>

<p>avg_receipt = 100.44 + 48.25 * rate - 73.68 * area</p>

<ul>
    <li><p><strong>Интерпретация регрессии</strong></p></li>
</ul>

<p>Мы знаем, что рейтинг нового ресторана <em>3.5</em>. Теперь нам стало известно, что он расположен не в центре города (<em>1</em>; <strong>area</strong>), тогда можно воспользоваться чуть более сложной моделью, которая даст нам более точный результат:</p>

<pre class="line-numbers"><code class="language-python">100.44 + 48.25 * 3.5 - 73.68 * 1
</code></pre>
<p class="print_result">195.635</p>

<p>Средний чек (<strong>avg_receipt</strong>) в ресторане с рейтингом 3.5 (<strong>rate</strong>), который расположен не в центре города (<em>1</em>; <strong>area</strong>), будет, составлять, примерно, 195.636 у.е.</p>

<p><strong>Свободный коэффициент</strong> (w<sub>0</sub>)</p>

<p>В многофакторной регрессии свободный коэффициент (w<sub>0</sub>) показывает, чему будет равна целевая переменная (Ŷ), если все предикторы (X<sub>1</sub>, ..., X<sub>k</sub>) равны 0.</p>

<p>В нашей модели, если рейтинг ресторана (<strong>rate</strong>) равен <em>0</em> и ресторан расположен в центре (<em>0</em>; <strong>area</strong>), то средний размер чека (<strong>avg_receipt</strong>) составляет 100.44 у.е..</p>

<p>Свободный коэффициент в многофакторных моделях также не всегда можно интерпретировать. Делать это можно только если все предикторы одновременно могут быть равны 0, и свободный коэффициент принимает допустимые значения целевой переменной. В нашем случае это возможно.</p>

<p><strong>Коэффициенты независимых переменных</strong> (w<sub>1</sub>, w<sub>2</sub>, ...)</p>

<p>Начнем с коэффициента перед предиктором рейтинг (<strong>rate</strong>), котороый равен 48.25. Рейтинг является <strong>количественной величиной</strong>, значит интерпретация следующая: если рейтинг (<strong>rate</strong>) <strong>увеличится</strong> на 1 балл, размер чека (<strong>avg_receipt</strong>) <strong>вырастет</strong> на 48.25 у.е., при прочих равных.</p>

<p>Второй предиктор модели – это расположение ресторана (<strong>area</strong>). Этот признак является <strong>бинарным</strong> и принимает только два значния: 0 - центр города, 1 - не центр города. Коэффициент перед этим предиктором равен -73.68, значит интепретация следующая: если ресторан расположен не в центре города (<em>1</em>; <strong>area</strong>), это <strong>снижает</strong> размер чека на 73.68 у.е., при прочих равных.</p>

<p>При интерпретации коэффициента (w<sub>k</sub>) <strong>бинарного</strong> предиктора (X<sub>k</sub>), закодированного 0 и 1, нужно пользоваться следущей логикой:</p>
<ul>
    <li>w<sub>k</sub> > 0
        <ul>
            <li>если X<sub>k</sub> равен 1, Ŷ <strong>увеличится</strong> на w<sub>1</sub></li>
            <li>если X<sub>k</sub> равен 0, Ŷ <strong>не увеличится</strong> на w<sub>1</sub></li>
        </ul>
    </li>
    <li>w<sub>k</sub> < 0
        <ul>
            <li>если X<sub>k</sub> равен 1, Ŷ <strong>уменьшится</strong> на w<sub>1</sub></li>
            <li>если X<sub>k</sub> равен 0, Ŷ <strong>не уменьшится</strong> на w<sub>1</sub></li>
        </ul>
    </li>
    <li>w<sub>0</sub> = 0
        <ul>
            <li>X<sub>k</sub> <strong>не оказывает влияние</strong> на Ŷ</li>
        </ul>
    </li>
</ul>

<p>Если <strong>бинарный</strong> предиктор (X<sub>k</sub>) закодирован не 0 и 1, а например 1 и 2, или какими-то другими двумя числами (назовем их переменными a и b), интерпретация коэффициента (w<sub>k</sub>) немного меняется:</p>
<ul>
    <li>w<sub>k</sub> > 0
        <ul>
            <li>если X<sub>k</sub> равен a, Ŷ <strong>увеличится</strong> на w<sub>1</sub>*a</li>
            <li>если X<sub>k</sub> равен b, Ŷ <strong>увеличится</strong> на w<sub>1</sub>*b</li>
        </ul>
    </li>
    <li>w<sub>k</sub> < 0
        <ul>
            <li>если X<sub>k</sub> равен a, Ŷ <strong>уменьшится</strong> на w<sub>1</sub>*a</li>
            <li>если X<sub>k</sub> равен b, Ŷ <strong>уменьшится</strong> на w<sub>1</sub>*b</li>
        </ul>
    </li>
    <li>w<sub>0</sub> = 0
        <ul>
            <li>X<sub>k</sub> <strong>не оказывает влияние</strong> на Ŷ</li>
        </ul>
    </li>
</ul>

<div class="scrollable-table">
        <table border="1" class="dataframe">
    <tr>
        <th colspan="3">Ŷ = w<sub>0</sub> + w<sub>1</sub> * X<sub>1</sub> - w<sub>2</sub> * X<sub>2</sub></th>
    </tr>
    <tr>
        <td><strong>Cвободный коэффициент</strong></td>
        <td>w<sub>0</sub></td>
        <td>Если все предикторы равны 0, то Ŷ равен w<sub>0</sub>. <br> <em>не всегда можно интерпретировать</em></td>
    </tr>
    <tr>
        <td colspan="3"><strong>Коэффициенты независимых <br> переменных</strong></td>
    </tr>
    <tr>
        <td><em>X<sub>1</sub> количественный</em></td>
        <td>w<sub>1</sub></td>
        <td>Если X<sub>1</sub> <strong>увеличится</strong> на n, Ŷ <strong>увеличится</strong> на w<sub>1</sub> * n</td>
    </tr>
    <tr>
        <td><em>X<sub>1</sub> бинарный <br>(принимает значения 0, 1)</em></td>
        <td>w<sub>1</sub></td>
        <td>Если X<sub>1</sub> равен 1, Ŷ <strong>увеличится</strong> на w<sub>1</sub>.<br>Если X<sub>1</sub> равен 0, Ŷ <strong>не увеличится</strong> на w<sub>1</sub>.</td>
    </tr>
    <tr>
        <td><em>X<sub>1</sub> бинарный <br>(принимает значения a, b)</em></td>
        <td>w<sub>1</sub></td>
        <td>Если X<sub>1</sub> равен a, Ŷ <strong>увеличится</strong> на w<sub>1</sub> * a.<br>Если X<sub>1</sub> равен b, Ŷ <strong>увеличится</strong> на w<sub>1</sub> * b.</td>
    </tr>
    <tr>
        <td><em>X<sub>2</sub> количественный</em></td>
        <td>-w<sub>2</sub></td>
        <td>Если X<sub>2</sub> <strong>увеличится</strong> на n, Ŷ <strong>снижается</strong> на w<sub>2</sub> * n</td>
    </tr>
    <tr>
        <td><em>X<sub>2</sub> бинарный <br>(принимает значения 0, 1)</em></td>
        <td>-w<sub>2</sub></td>
        <td>Если X<sub>2</sub> равен 1, Ŷ <strong>снижается</strong> на w<sub>2</sub>.<br>Если X<sub>2</sub> равен 0, Ŷ <strong>не снижается</strong> на w<sub>2</sub>.</td>
    </tr>
    <tr>
        <td><em>X<sub>2</sub> бинарный <br>(принимает значения a, b)</em></td>
        <td>-w<sub>2</sub></td>
        <td>Если X<sub>2</sub> равен a, Ŷ <strong>снижается</strong> на w<sub>2</sub> * a.<br>Если X<sub>2</sub> равен b, Ŷ <strong>снижается</strong> на w<sub>2</sub> * b.</td>
    </tr>
</table>
</div>

<div style="height: 30px;"></div>
<h2 id="chapter8-4">8.4 Как оценить качество линейной регрессии?</h2>

<p>Остается последний вопрос: как понять, хорошие модели мы построили или плохие? Чтобы получить ответ, нужно воспользоваться метриками оценки качества моделей. Мы рассмотрим три из них: коэффициент детерминации(R<sup>2</sup>), среднеквадратичную ошибку (MSE) и среднюю абсолютную ошибку (MAE).</p>

<h3>КОЭФФИЦИЕНТ ДЕТЕРМИНАЦИИ (R<sup>2</sup>)</h3>

<p>Это показатель, который демонстрирует, насколько точно построенная модель объясняет поведение интересующей нас переменной.</p>

<p>Представьте ситуацию: вы обучили модель линейной регрессии и наложили ее на диаграмму рассеяния ваших данных. Чем больше точки приближены к этой линии регрессии, тем точнее ваша модель описывает реальность. Именно коэффициент детерминации (R<sup>2</sup>) отражает долю вариации ваших данных, которую можно объяснить моделью.</p>

<p>Коэффициент детерминции меняется в диапазоне от <strong>0 до 1</strong>. Чем он ближе к 1, тем лучше наша модель.</p>

<p>Теоретически, если R<sup>2</sup> равен 1, это означает идеальную точность модели, но на практике это скорее будет свидетельствовать о том, что модель слишком усложнили, или совершили ошибки при ее разработке или обучении. Оптимальным показателем считается величина около 0.7–0.9, которая демонстрирует хорошую прогностическую способность и стабильность модели.</p>

<p>Если коэффициент детерминации получился не больше 0.5, значит построенной модели не стоит доверять, так как она описывает не более 50% изменений нашей целевой переменной.</p>

<img src="picture/chapter8/30.svg" width="100%" alt="Рисунок 30">


<p>Чтобы получить коэффициент детерминации (R<sup>2</sup>), нужно обратиться к атрибуту <span class="code-chip">.rsquared</span> обученной модели. Сравним коэффициент детерминации для однофакторной (<span class="code-chip">model1</span>) и многофакторной (<span class="code-chip">model2</span>) регрессий, которые мы построили:</p>

<pre class="line-numbers"><code class="language-python">model1.rsquared
</code></pre>
<p class="print_result">np.float64(0.6666666666666667)</p>

<pre class="line-numbers"><code class="language-python">model2.rsquared
</code></pre>
<p class="print_result">np.float64(0.712719298245614)</p>

<p>Однофакторная регрессия (<span class="code-chip">model1</span>) описывает 66.67% изменений размера чека (<strong>avg_receipt</strong>) в наших данных.</p>

<p>Многофакторная регрессия (<span class="code-chip">model2</span>) описывает 71.27% изменений размера чека (<strong>avg_receipt</strong>) в наших данных.</p>

<p>Обеим моделям можно доверять, но качество многофакторной регрессии немного лучше.</p>

<h3>СРЕДНЕКВАДРАТИЧНАЯ ОШИБКА (MSE) И СРЕДНЯЯ АБСОЛЮТНАЯ ОШИБКА (MAE)</h3>

<p>Качество модели можно оценить не только через долю данных, которые она описывает, но и через размер ошибки. Ошибкой модели называют отклонение реальных значений целевой переменной (Y) от предсказанных (Ŷ).</p>

<p>Рассмотрим нашу однофакторную регрессию:</p>
<p>avg_receipt = 33.33 + 66.67 * rate</p>

<p>Реальные значения – это признак <strong>avg_receipt</strong> (Y). Чтобы найти <strong>предсказанные значения</strong> (Ŷ), применим функцию <span class="code-chip">.predict()</span>:</p>

<p class="fake-code"><span class="code-line">модель.predict(предикторы)</span></p>

<pre class="line-numbers"><code class="language-python">df['pred_avg_receipt'] = model1.predict(X1)
df
</code></pre>

            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>avg_receipt</th>
                        <th>rate</th>
                        <th>area</th>
                        <th>pred_avg_receipt</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>0</strong></td>
                        <td>50</td>
                        <td>0.5</td>
                        <td>1</td>
                        <td>66.666667</td>
                    </tr>
                    <tr>
                        <td><strong>1</strong></td>
                        <td>100</td>
                        <td>1.5</td>
                        <td>1</td>
                        <td>133.333333</td>
                    </tr>
                    <tr>
                        <td><strong>2</strong></td>
                        <td>200</td>
                        <td>1.5</td>
                        <td>0</td>
                        <td>133.333333</td>
                    </tr>
                    <tr>
                        <td><strong>3</strong></td>
                        <td>200</td>
                        <td>2.5</td>
                        <td>0</td>
                        <td>200.000000</td>
                    </tr>
                    <tr>
                        <td><strong>4</strong></td>
                        <td>150</td>
                        <td>3.5</td>
                        <td>0</td>
                        <td>266.666667</td>
                    </tr>
                    <tr>
                        <td><strong>5</strong></td>
                        <td>350</td>
                        <td>3.5</td>
                        <td>0</td>
                        <td>266.666667</td>
                    </tr>
                    <tr>
                        <td><strong>6</strong></td>
                        <td>350</td>
                        <td>4.5</td>
                        <td>0</td>
                        <td>333.333333</td>
                    </tr>
                    </tbody>
                </table>
            </div>

<p>Этот метод взял каждое значение предиктора (<strong>rate</strong>), подставил его в уравнение регрессии (avg_receipt = 33.33 + 66.67 * rate) и нашел для них предсказанное значение целевой переменной (<strong>pred_avg_receipt</strong>).</p>

<p>Теперь мы можем найти <strong>ошибку</strong> на каждом наблюдении, просто найдя разность между реальными и предсказанными значениями целевой переменной:</p>
<p>e<sub>n</sub> = y - ŷ</p>

<pre class="line-numbers"><code class="language-python">df['error'] = df['avg_receipt'] - df['pred_avg_receipt']
df
</code></pre>

            <div class="scrollable-table">
                <table border="1" class="dataframe">
                    <thead>
                    <tr>
                        <th></th>
                        <th>avg_receipt</th>
                        <th>rate</th>
                        <th>area</th>
                        <th>pred_avg_receipt</th>
                        <th>error</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>0</strong></td>
                        <td>50</td>
                        <td>0.5</td>
                        <td>1</td>
                        <td>66.666667</td>
                        <td>-16.666667</td>
                    </tr>
                    <tr>
                        <td><strong>1</strong></td>
                        <td>100</td>
                        <td>1.5</td>
                        <td>1</td>
                        <td>133.333333</td>
                        <td>-33.333333</td>
                    </tr>
                    <tr>
                        <td><strong>2</strong></td>
                        <td>200</td>
                        <td>1.5</td>
                        <td>0</td>
                        <td>133.333333</td>
                        <td>66.666667</td>
                    </tr>
                    <tr>
                        <td><strong>3</strong></td>
                        <td>200</td>
                        <td>2.5</td>
                        <td>0</td>
                        <td>200.000000</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td><strong>4</strong></td>
                        <td>150</td>
                        <td>3.5</td>
                        <td>0</td>
                        <td>266.666667</td>
                        <td>-116.666667</td>
                    </tr>
                    <tr>
                        <td><strong>5</strong></td>
                        <td>350</td>
                        <td>3.5</td>
                        <td>0</td>
                        <td>266.666667</td>
                        <td>83.333333</td>
                    </tr>
                    <tr>
                        <td><strong>6</strong></td>
                        <td>350</td>
                        <td>4.5</td>
                        <td>0</td>
                        <td>333.333333</td>
                        <td>16.666667</td>
                    </tr>
                    </tbody>
                </table>
            </div>

<img src="picture/chapter8/31.svg" width="10%" alt="Рисунок 31">


<p>Расмотрим внимательнее ошибку (<strong>error</strong>):</p>
<ul>
    <li>Если e < 0, то реальное значение ниже, чем предсказание модели (модель завысила значение)</li>
    <li>Если e > 0, то реальное значение выше, чем предсказание модели (модель занизила значение на этом наблюдении)</li>
    <li>Если e =0, то реальное значение совпадает с предсказанным, то есть модель на этом наблюдении не ошибается</li>
</ul>

<p>Если мы хотим найти, на сколько в среднем ошибается модель, мы не можем просто сложить все ошибки и разделить на количество наблюдений, так как ошибка бывает положительной и отрицательной. Чтобы избавиться от знаков, можно взять квадрат ошибки или её модуль, и вот эту сумму квадратов или модулей разделить на количество наблюдений. Такие метрики называются <strong>среднеквадратичной ошибкой</strong> (MSE) и <strong>средней абсолютной ошибкой</strong> (MAE):</p>

<!-- MSE -->
<p>
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>MSE</mi>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mo>(</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>y</mi><mn>1</mn></msub>
          <mo>-</mo>
          <msub><mover><mi>y</mi><mo>^</mo></mover><mn>1</mn></msub>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mo>…</mo>
      <mo>+</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>y</mi><mi>n</mi></msub>
          <mo>-</mo>
          <msub><mover><mi>y</mi><mo>^</mo></mover><mi>n</mi></msub>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>)</mo>
    </mrow>
    <mi>n</mi>
  </mfrac>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mo>(</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>avg_receipt</mi><mn>1</mn></msub>
          <mo>-</mo>
          <msub><mover><mi>avg_receipt</mi><mo>^</mo></mover><mn>1</mn></msub>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mo>…</mo>
      <mo>+</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>avg_receipt</mi><mi>n</mi></msub>
          <mo>-</mo>
          <msub><mover><mi>avg_receipt</mi><mo>^</mo></mover><mi>n</mi></msub>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>)</mo>
    </mrow>
    <mi>n</mi>
  </mfrac>
</math>
</p>


<!-- MAE -->
 <p>
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mi>MAE</mi>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mo>(</mo>
      <mo>|</mo>
      <msub><mi>y</mi><mn>1</mn></msub>
      <mo>-</mo>
      <msub><mover><mi>y</mi><mo>^</mo></mover><mn>1</mn></msub>
      <mo>|</mo>
      <mo>+</mo>
      <mo>…</mo>
      <mo>+</mo>
      <mo>|</mo>
      <msub><mi>y</mi><mi>n</mi></msub>
      <mo>-</mo>
      <msub><mover><mi>y</mi><mo>^</mo></mover><mi>n</mi></msub>
      <mo>|</mo>
      <mo>)</mo>
    </mrow>
    <mi>n</mi>
  </mfrac>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mo>(</mo>
      <mo>|</mo>
      <msub><mi>avg_receipt</mi><mn>1</mn></msub>
      <mo>-</mo>
      <msub><mover><mi>avg_receipt</mi><mo>^</mo></mover><mn>1</mn></msub>
      <mo>|</mo>
      <mo>+</mo>
      <mo>…</mo>
      <mo>+</mo>
      <mo>|</mo>
      <msub><mi>avg_receipt</mi><mi>n</mi></msub>
      <mo>-</mo>
      <msub><mover><mi>avg_receipt</mi><mo>^</mo></mover><mi>n</mi></msub>
      <mo>|</mo>
      <mo>)</mo>
    </mrow>
    <mi>n</mi>
  </mfrac>
</math>
</p>

<p>y<sub>n</sub>, avg_receipt<sub>n</sub> - реальные значения целевой переменной</p>

<p>ŷ<sub>n</sub>, avĝ_receipt<sub>n</sub> - предсказанные значения целевой переменной</p>

<p>y<sub>n</sub> - ŷ<sub>n</sub>, avg_receipt<sub>n</sub> - avĝ_receipt<sub>n</sub> - ошибки модели</p>

<p>n - количество наблюдений</p>

<p>Обе эти метрики меняются в диапазоне от <strong>0 до +∞</strong>. Чем меньше значение этих метрик, тем лучше наша модель.</p>

<p>В теории, если оказалось, что MSE и MAE равны 0, это значит, что наша регрессия не ошибается, и мы построили идеальную модель. Но на практике, как и коэффициент детерминации (R<sup>2</sup>) равный 1, это сигнал для нас, что с моделью что-то не так.</p>

<p>При этом в отличии от коэффициента детерминации (R<sup>2</sup>), MSE и MAE не имеют никакой градации, они используются для сравнения моделей между собой. Лучше будет та модель, у которой эти метрики будут меньше.</p>

<img src="picture/chapter8/32.svg" width="100%" alt="Рисунок 32">


<p>Теперь рассчитаем среднеквадратичную (MSE) и среднюю абсолютную ошибку (MAE) для нашей модели:</p>

<pre class="line-numbers"><code class="language-python">(df['error']**2).sum() / 7  # MSE
</code></pre>
<p class="print_result">np.float64(3809.523809523809)</p>

<p>Усреднный квадрат ошибка модели равен 3809.52 у.е<sup>2</sup></p>

<pre class="line-numbers"><code class="language-python">abs(df['error']).sum() / 7  # MAE
</code></pre>
<p class="print_result">np.float64(47.619047619047606)</p>

<p>В среднем, модель ошибается на 47.62 у.е</p>

<p>Для рассчет этих метрик можно воспользоваться функциями из модуля <span class="code-chip">statsmodels.tools.eval_measures</span>. Для начала модуль и функции нужно импортировать:</p>

<pre class="line-numbers"><code class="language-python">from statsmodels.tools.eval_measures import mse, meanabs
</code></pre>

<p>Чтобы найти среднеквадратичную ошибку (MSE), нужно воспользоваться функцией <span class="code-chip">mse</span> со следующими параметрами:</p>
<p class="fake-code"><span class="code-line">mse(целевая, предсказанные значения)</span></p>

<p>Сравним среднеквадратичную ошибку (MSE) однофакторной и многофакторной модели:</p>

<pre class="line-numbers"><code class="language-python"># avg_receipt = 33.33 + 66.67 * rate
mse(Y, df['pred_avg_receipt'])
</code></pre>
<p class="print_result">np.float64(3809.523809523809)</p>

<pre class="line-numbers"><code class="language-python"># avg_receipt = 100.44 + 48.25 * rate − 73.68 * area
y_pred = model2.predict(X2)
mse(Y, y_pred)
</code></pre>
<p class="print_result">np.float64(3283.208020050126)</p>

<p>Как мы видим, среднеквадратичная модель в нашей многофакторной модели ниже, чем в однофакторной. Значит многофакторная модель лучшего качества.</p>

<p>Чтобы рассчитать среднюю абсолютную ошибку (MAE), воспользуемся функцией <span class="code-chip">meanabs</span>:</p>

<p class="fake-code"><span class="code-line">meanabs(целевая, предсказанные значения)</span></p>

<p>Теперь сравним среднюю абсолютную ошибку (MAE) моделей:</p>

<pre class="line-numbers"><code class="language-python"># avg_receipt = 33.33 + 66.67 * rate
meanabs(Y, df['pred_avg_receipt'])
</code></pre>
<p class="print_result">np.float64(47.619047619047606)</p>

<pre class="line-numbers"><code class="language-python"># avg_receipt = 100.44 + 48.25 * rate − 73.68 * area
y_pred = model2.predict(X2)
meanabs(Y, y_pred)
</code></pre>
<p class="print_result">np.float64(40.35087719298245)</p>

<p>Средняя абсолютная ошибка второй модели, также ниже. Значит вторая модель лучше.</p>





<div class="scrollable-table">
    <table border="1" class="dataframe">
    <tr>
        <th></th>
        <th>Предсказанные значения</th>
    </tr>
    <tr>
        <td><strong>Обозначение</strong></td>
        <td>Ŷ, ŷ<sub>i</sub></td>
    </tr>
    <tr>
        <td><strong>Рассчет</strong></td>
        <td><span class="code-chip">модель.predict(предиктор)<sup>*</sup></span></td>
    </tr>
</table>
</div>


<div style="height: 50px;"></div>


<div class="scrollable-table">
    <table border="1" class="dataframe">
    <tr>
        <th></th>
        <th>Коэффициент детерминации</th>
        <th>Среднеквадратичная ошибка</th>
        <th>Средняя абсолютная ошибка</th>
    </tr>
    <tr>
        <td><strong>Обозначение</strong></td>
        <td>R<sup>2</sup></td>
        <td>MSE</td>
        <td>MAE</td>
    </tr>
    <tr>
        <td><strong>Формула</strong></td>
        <td>
                <!-- 1-я формула: 1 - (RSS / TSS) -->
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mn>1</mn>
                <mo>-</mo>
                <mfrac>
                    <mrow>
                    <mo>(</mo>
                    <msup>
                        <mrow>
                        <mo>(</mo>
                        <msub><mi>y</mi><mn>1</mn></msub>
                        <mo>-</mo>
                        <msub><mover><mi>y</mi><mo>^</mo></mover><mn>1</mn></msub>
                        <mo>)</mo>
                        </mrow>
                        <mn>2</mn>
                    </msup>
                    <mo>+</mo>
                    <mo>…</mo>
                    <mo>+</mo>
                    <msup>
                        <mrow>
                        <mo>(</mo>
                        <msub><mi>y</mi><mi>n</mi></msub>
                        <mo>-</mo>
                        <msub><mover><mi>y</mi><mo>^</mo></mover><mi>n</mi></msub>
                        <mo>)</mo>
                        </mrow>
                        <mn>2</mn>
                    </msup>
                    <mo>)</mo>
                    </mrow>
                    <mrow>
                    <mo>(</mo>
                    <msup>
                        <mrow>
                        <mo>(</mo>
                        <msub><mi>y</mi><mn>1</mn></msub>
                        <mo>-</mo>
                        <msub><mover><mi>y</mi><mo>¯</mo></mover><mn>1</mn></msub>
                        <mo>)</mo>
                        </mrow>
                        <mn>2</mn>
                    </msup>
                    <mo>+</mo>
                    <mo>…</mo>
                    <mo>+</mo>
                    <msup>
                        <mrow>
                        <mo>(</mo>
                        <msub><mi>y</mi><mi>n</mi></msub>
                        <mo>-</mo>
                        <msub><mover><mi>y</mi><mo>¯</mo></mover><mi>n</mi></msub>
                        <mo>)</mo>
                        </mrow>
                        <mn>2</mn>
                    </msup>
                    <mo>)</mo>
                    </mrow>
                </mfrac>
                </math>

        </td><td>

                <!-- 2-я формула: MSE -->
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mfrac>
                    <mrow>
                    <mo>(</mo>
                    <msup>
                        <mrow>
                        <mo>(</mo>
                        <msub><mi>y</mi><mn>1</mn></msub>
                        <mo>-</mo>
                        <msub><mover><mi>y</mi><mo>^</mo></mover><mn>1</mn></msub>
                        <mo>)</mo>
                        </mrow>
                        <mn>2</mn>
                    </msup>
                    <mo>+</mo>
                    <mo>…</mo>
                    <mo>+</mo>
                    <msup>
                        <mrow>
                        <mo>(</mo>
                        <msub><mi>y</mi><mi>n</mi></msub>
                        <mo>-</mo>
                        <msub><mover><mi>y</mi><mo>^</mo></mover><mi>n</mi></msub>
                        <mo>)</mo>
                        </mrow>
                        <mn>2</mn>
                    </msup>
                    <mo>)</mo>
                    </mrow>
                    <mi>n</mi>
                </mfrac>
                </math>

        </td><td>

                <!-- 3-я формула: MAE -->
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mfrac>
                    <mrow>
                    <mo>(</mo>
                    <mo>|</mo>
                    <msub><mi>y</mi><mn>1</mn></msub>
                    <mo>-</mo>
                    <msub><mover><mi>y</mi><mo>^</mo></mover><mn>1</mn></msub>
                    <mo>|</mo>
                    <mo>+</mo>
                    <mo>…</mo>
                    <mo>+</mo>
                    <mo>|</mo>
                    <msub><mi>y</mi><mi>n</mi></msub>
                    <mo>-</mo>
                    <msub><mover><mi>y</mi><mo>^</mo></mover><mi>n</mi></msub>
                    <mo>|</mo>
                    <mo>)</mo>
                    </mrow>
                    <mi>n</mi>
                </mfrac>
                </math>    
        </td>
    </tr>
    <tr>
        <td><strong>Диапазон значений</strong></td>
        <td>от 0 до 1</td>
        <td>от 0 до +∞</td>
        <td>от 0 до +∞</td>
    </tr>
    <tr>
        <td><strong>Интерпретация</strong></td>
        <td>Чем ближе к 1, тем лучше</td>
        <td>Чем ближе к 0, тем лучше</td>
        <td>Чем ближе к 0, тем лучше</td>
    </tr>
    <tr>
        <td><strong>Расчет</strong></td>
        <td><span class="code-chip">модель.rsquared<sup>*</sup></span></td>
        <td><span class="code-chip">mse(целевая, предсказанные значения)<sup>**</sup></span></td>
        <td><span class="code-chip">meanabs(целевая, предсказанные значения)<sup>**</sup></span></td>
    </tr>
</table>
</div>

<p><sup>*</sup> для использования импортируйте <span class="code-chip">import statsmodels.api as sm</span></p>
<p><sup>**</sup> для использования импортируйте <span class="code-chip">from statsmodels.tools.eval_measures import mse, meanabs</span></p>

<h3>УЛУЧШЕНИЕ КАЧЕСТВА МОДЕЛИ</h3>





<p>Довольно часто, при работе с реальными данными, качество регрессии может быть настолько низким, что результатам моделирования просто нельзя верить. Тогда аналитику приходится проделать ряд шагов, чтобы улучшить модель. Для начала он <strong>удалит выбросы и заменит пропуски</strong>. Затем ему нужно понять какие предикторы стоит взять в модель. У него не так много наблюдений, а он знает, что <strong>каждый предиктор должен быть обеспечен минимум 100 наблюдениями</strong>. То есть для построения однофакторной модели хватит 100 наблюдений, но например если в модели 500 наблюдений в модель можно взять не более 5 предикторов. Чтобы понять какие предикторы стоит взять, он постоит гистограммы распределения и выделит <strong>унимодальные симметричные распределения</strong>. После чего он рассчитает корреляцию Пирсона для количественный данных и Спирмана для категориальных, выделив какие из признаков имеют <strong>самую сильную корреляцию с целевой переменной</strong>. При этом эти <strong>между самими предикторами</strong>, отобранными в модель, <strong>корреляция не должна превышать 0.7</strong>. Проделав эти шаги, качество регрессии, которую строит аналитик, будет значительно выше.</p>






<a href="https://edu.hse.ru/mod/quiz/view.php?id=1610943" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>&nbsp;<a href="https://edu.hse.ru/mod/quiz/view.php?id=1610944" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>

        </section>

</div>


<script>
    const toggleNav = document.getElementById('toggleNav');
    const sideNav = document.getElementById('sideNav');

    toggleNav.addEventListener('click', () => {
        sideNav.classList.toggle('open');
    });
</script>
<script>
    document.querySelectorAll('.accordion-button').forEach(button => {
        button.addEventListener('click', () => {
            button.classList.toggle('active');
            const content = button.nextElementSibling;

            if (button.classList.contains('active')) {
                content.style.maxHeight = content.scrollHeight + 'px';
            } else {
                content.style.maxHeight = '0';
            }
        });
    });
</script>

    </div>
</div>
