<!DOCTYPE html>
<html lang="ru" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Hack&display=swap" rel="stylesheet">
    <title>Глава 6</title>
    <link rel="stylesheet" href="chapter_1.css">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/pyodide"></script>
    <script src="libs/prism.js"></script>
</head>

<div class="logo-wrapper">
    <img src="picture/logo.svg" class="logo-top-right" alt="Логотип">
</div>
<div class="horizontal-accordion-wrapper">
    <div class="accordion-left">
        <button id="toggleNav" class="accordion-button-left" style="color: white; border-color: white;">☰</button>
    </div>
    <div id="sideNav" class="accordion-panel-right">
        <a href="#chapter6"><strong>Глава 6</strong></a>
        <a href="#chapter6-1">6.1 Описательные статистики</a>
        <a href="#chapter6-2">6.2 МЦТ</a>
        <a href="#chapter6-3">6.3 Квартили</a>
        <a href="#chapter6-4">6.4 Меры вариативности</a>
        <a href="#chapter6-5">6.5 Выбросы</a>
        <a href="#chapter6-6">6.6 Пропуски в данных</a>
    </div>

    <div class="main-content" style="padding-top: 10px;">


<section>
    <h1 style="font-size: 15px; text-align: center; color:#1e01da; ">Хендбук. Анализ данных. Начальный уровень</h1>
    <h1 style="font-size: 30px;" id="chapter6">Глава 6. Описательные статистики. Пропуски и выбросы</h1>
    <div style="height: 10px;"></div>
    
    <h2 id="chapter6-1">6.1 Что такое описательные статистики?</h2>

    <p style="display:inline">В предыдущих главах мы рассмотрели структуры продаж нашей пиццерии. Но чтобы уверенно двигаться вперёд и развивать бизнес, нужно выйти за пределы собственной компании и взглянуть шире — оценить обстановку на рынке общественного питания. Рассмотрим, как это сделать, на примере данных </p><a style="display:inline" href="https://google.com"><p style="display:inline">restaurants.csv:</p></a>

    <table border="1" class="dataframe_new" style="width: 100%;">
        <tr>
            <th>ПРИЗНАК</th>
            <th>ОПИСАНИЕ</th>
            <th>ФОРМАТ ДАННЫХ (.dtypes)</th>
        </tr>
        <tr>
            <td><strong>name</strong></td>
            <td>название ресторана</td>
            <td>object</td>
        </tr>
        <tr>
            <td><strong>restaurant_type</strong></td>
            <td>тип ресторана</td>
            <td>object</td>
        </tr>
        <tr>
            <td><strong>rate</strong></td>
            <td>рейтинг ресторана</td>
            <td>float64</td>
        </tr>
        <tr>
            <td><strong>votes</strong></td>
            <td>количество людей, поставивших оценку ресторана</td>
            <td>int64</td>
        </tr>
        <tr>
            <td><strong>avg_receipt</strong></td>
            <td>средний размер чека на двоих в ресторане</td>
            <td>float64</td>
        </tr>
        <tr>
            <td><strong>online_order</strong></td>
            <td>возможность сделать онлайн заказ (1 - есть, 0 - нет)</td>
            <td>int64</td>
        </tr>
        <tr>
            <td><strong>table_booking</strong></td>
            <td>возможность забронировать столик (1 - есть, 0 - нет)</td>
            <td>int64</td>
        </tr>
        <tr>
            <td><strong>cuisines_type</strong></td>
            <td>кухня в ресторане</td>
            <td>object</td>
        </tr>
        <tr>
            <td><strong>area</strong></td>
            <td>район, где расположен ресторан</td>
            <td>object</td>
        </tr>
    </table>

    <p>Одно <strong>наблюдение</strong> - это один <strong>ресторан</strong>.</p>

    <pre class="line-numbers"><code class="language-python">import pandas as pd

df = pd.read_csv('restaurants.csv')
df.head()</code></pre>

<div class="scrollable-table">
        <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>name</th>
            <th>restaurant_type</th>
            <th>rate</th>
            <th>votes</th>
            <th>avg_receipt</th>
            <th>online_order</th>
            <th>table_booking</th>
            <th>cuisines_type</th>
            <th>area</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>#FeelTheROLL</td>
            <td>Quick Bites</td>
            <td>3.4</td>
            <td>7.0</td>
            <td>200.0</td>
            <td>0</td>
            <td>0</td>
            <td>Fast Food</td>
            <td>Bellandur</td>
        </tr>
        <tr>
            <th>1</th>
            <td>#L-81 Cafe</td>
            <td>Quick Bites</td>
            <td>3.9</td>
            <td>48.0</td>
            <td>400.0</td>
            <td>1</td>
            <td>0</td>
            <td>Fast Food, Beverages</td>
            <td>Byresandra,Tavarekere,Madiwala</td>
        </tr>
        <tr>
            <th>2</th>
            <td>#refuel</td>
            <td>Cafe</td>
            <td>3.7</td>
            <td>NaN</td>
            <td>400.0</td>
            <td>1</td>
            <td>0</td>
            <td>Cafe, Beverages</td>
            <td>Bannerghatta Road</td>
        </tr>
        <tr>
            <th>3</th>
            <td>'@ Biryani Central</td>
            <td>Casual Dining</td>
            <td>2.7</td>
            <td>135.0</td>
            <td>550.0</td>
            <td>1</td>
            <td>0</td>
            <td>Biryani, ...</td>
            <td>Marathahalli</td>
        </tr>
        <tr>
            <th>4</th>
            <td>'@99</td>
            <td>Takeaway, Delivery</td>
            <td>3.4</td>
            <td>37.0</td>
            <td>200.0</td>
            <td>0</td>
            <td>0</td>
            <td>Mughlai, Biryani, ...</td>
            <td>Whitefield</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Для такого исследования нам потребуются <strong>описательные статистики</strong>. Чтобы охарактеризовать среднестатистический ресторан, будем использовать <strong>меры центральной тенденции</strong>, раскрывающие портрет <em>типичного</em> игрока индустрии. Чтобы изучить <em>разнообразие</em> рынка, рассчитаем <strong>меры вариативности</strong> – они покажут, насколько разнятся заведения по ключевым характеристикам. Наконец, чтобы заглянуть внутрь структуры рынка и <em>выявить слои</em> заведений различного уровня, задействуем <strong>квартили</strong>.</p>

    <img src="picture/chapter6/7.svg" width="100%" alt="Рисунок 1">

    <p>Чтобы автоматически рассчитать описательные статистики для столбцов типа <em>int64</em> и <em>float64</em>, нужно применить метод <span class="code-chip">.describe()</span> к нашему датафрейму:</p>

    <pre class="line-numbers"><code class="language-python">df.describe()</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>rate</th>
            <th>votes</th>
            <th>avg_receipt</th>
            <th>online_order</th>
            <th>table_booking</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>count</th>
            <td>6407.0</td>
            <td>6370.0</td>
            <td>6407.0</td>
            <td>6407.0</td>
            <td>6407.0</td>
        </tr>
        <tr>
            <th>mean</th>
            <td>3.584642</td>
            <td>204.234694</td>
            <td>555.880912</td>
            <td>0.537225</td>
            <td>0.113157</td>
        </tr>
        <tr>
            <th>std</th>
            <td>0.424497</td>
            <td>621.802723</td>
            <td>475.615400</td>
            <td>0.498651</td>
            <td>0.316810</td>
        </tr>
        <tr>
            <th>min</th>
            <td>2.0</td>
            <td>1.0</td>
            <td>40.0</td>
            <td>0.0</td>
            <td>0.0</td>
        </tr>
        <tr>
            <th>25%</th>
            <td>3.3</td>
            <td>13.0</td>
            <td>300.0</td>
            <td>0.0</td>
            <td>0.0</td>
        </tr>
        <tr>
            <th>50%</th>
            <td>3.6</td>
            <td>40.0</td>
            <td>400.0</td>
            <td>1.0</td>
            <td>0.0</td>
        </tr>
        <tr>
            <th>75%</th>
            <td>3.9</td>
            <td>149.0</td>
            <td>650.0</td>
            <td>1.0</td>
            <td>0.0</td>
        </tr>
        <tr>
            <th>max</th>
            <td>4.9</td>
            <td>16345.0</td>
            <td>6000.0</td>
            <td>1.0</td>
            <td>1.0</td>
        </tr>
        </tbody>
    </table>
</div>

    <ul>
        <li><strong>count</strong> - количество непропущенных значений (не NaN) в признаке, аналог метода <span class="code-chip">.count()</span></li>
        <li><strong>mean</strong> - среднее арифметическое (МЦТ)</li>
        <li><strong>std</strong> - стандартное отклонение (мера вариативности)</li>
        <li><strong>min</strong> - минимум (квартили)</li>
        <li><strong>25%</strong> - первый квартиль (квартили)</li>
        <li><strong>50%</strong> - медиана/второй квартиль (МЦТ/квартили)</li>
        <li><strong>75%</strong> - третий квартиль (квартили)</li>
        <li><strong>max</strong> - максимум (квартили)</li>
    </ul>

    <p>Если описательные статистики нужны по признакам в формате <em>object</em>, добавьте внутрь <span class="code-chip">.describe()</span> параметр <span class="code-chip">include='object'</span>:</p>

    <pre class="line-numbers"><code class="language-python">df.describe(include='object')</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>name</th>
            <th>restaurant_type</th>
            <th>cuisines_type</th>
            <th>area</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>count</th>
            <td>6407</td>
            <td>6387</td>
            <td>6407</td>
            <td>6407</td>
        </tr>
        <tr>
            <th>unique</th>
            <td>6407</td>
            <td>80</td>
            <td>2035</td>
            <td>30</td>
        </tr>
        <tr>
            <th>top</th>
            <td>Zyksha</td>
            <td>Quick Bites</td>
            <td>North Indian, Chinese</td>
            <td>Byresandra,Tavarekere,Madiwala</td>
        </tr>
        <tr>
            <th>freq</th>
            <td>1</td>
            <td>2467</td>
            <td>381</td>
            <td>735</td>
        </tr>
        </tbody>
    </table>
</div>

    <ul>
        <li><strong>count</strong> - количество непропущенных значений (не NaN) в признаке, аналог метода <span class="code-chip">.count()</span></li>
        <li><strong>unique</strong> - количество уникальных категорий, аналог метода <span class="code-chip">.nunique()</span> (мера вариативности)</li>
        <li><strong>top</strong> - самое часто встречаемое значение, мода (МЦТ)</li>
        <li><strong>freq</strong> - частота моды</li>
    </ul>

    <div style="height: 10px;"></div>
    <h2 id="chapter6-2">6.2 Какие бывают меры центральной тенденции?</h2>

    <p>Когда перед нами большой объём информации, сложно сразу определить основные особенности или характеристики признаков – в таком случае на помощь приходят <strong>меры центральной тенденции</strong> (МЦТ)</p>

    <div class="important-card">
        <div class="important-text">
        <strong>Меры центральной тенденции (МЦТ)</strong> - группа описательных статистик, необходимая для характеристики <em>типичного</em> наблюдения в данных.
    </div></div>

    <p>Мы рассмотрим три описательных статистики: среднее арифметическое, медиана и мода.</p>

    <h3>СРЕДНЕЕ АРИФМЕТИЧЕСКОЕ</h3>

    <p>Среднее арифметическое (также называемое средним значением) является наиболее распространённым способом выражения общей тенденции или основного уровня данных.  В математике среднее обозначается x̄. Если мы хотим рассчитать среднее для некоторого признака X, нужно найти сумму по нему и разделить на количество наблюдений:

x̄= (x<sub>1</sub> + x<sub>2</sub> + ... + x<sub>n</sub>) / n</p>

    <p>Среднее, как правило, рассчитывается для <strong>количественных признаков</strong>. Чтобы рассчитать среднее арифметическое в Python, нужно воспользоваться методом <span class="code-chip">.mean()</span>. Например, мы хотим узнать средний рейтинг ресторанов (<strong>rate</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].mean()</code></pre>
    <p class="print_result">np.float64(3.5846417980334015)</p>
    <p>Или хотим выяснить средний размер чека (<strong>avg_receipt</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].mean()</code></pre>
    <p class="print_result">np.float64(555.8809115030435)</p>
    <p>Помимо оценки количественных признаков, среднее арифметическое применяется к <strong>категориальным бинарным</strong> данным, закодированным в виде 1 и 0. Для таких данных среднее арифметическое показывает долю 1 в данных. В наших данных есть признак <strong>online_order</strong> - идентификатор того, есть ли в ресторане возможность сделать онлайн-заказ. Если такая возможность есть - 1, иначе 0. Если мы хотим найти долю ресторанов, в которых есть опция онлайн-заказа, напишем следующий код:</p>

    <pre class="line-numbers"><code class="language-python">df['online_order'].mean()</code></pre>
    <p class="print_result">np.float64(0.5372249102544092)</p>

    <p>Получается, доля ресторанов, в которых есть возможность заказать онлайн, составляет 0.53. Для удобства можно умножить значение на 100, чтобы перевести доли в проценты:</p>

    <pre class="line-numbers"><code class="language-python">df['online_order'].mean()*100</code></pre>
    <p class="print_result">np.float64(53.722491025440924)</p>

    <p>Кажется, что среднее арифметическое идеально подходит для описания типичного наблюдения в данных, однако у него есть серьезный недостаток — <strong>чувствительность к выбросам</strong>. <strong>Выбросы</strong> — это крайне высокие или низкие значения, резко отличающиеся от остальных данных. Например, если в вашем наборе данных преобладают недорогие заведения общепита с небольшими средними чеками, но присутствуют несколько элитных ресторанов с гораздо более высокими ценами, то среднее арифметическое размера чека будет заметно увеличено за счет этих дорогих заведений. Из-за этого средняя величина станет завышенной, и получится неверное представление о типичном размере чека в большинстве мест.</p>

    <h3>МЕДИАНА</h3>

    <p><strong>Медиана</strong> - это мера центральной тенденции, лежащая по центру распределения данных. В отличие от среднего, медиана <strong>к выбросам устойчива</strong>; это связано с методологией ее рассчета, в которой мы берем не все данные, а только те, что лежат посередине:</p>

    <ul>
        <li>Если количество наблюдений <strong>нечетное</strong>, медиана - это значение, стоящее посередине. Например, в <strong>[1, 2, 3, 4, 5]</strong> медиана равна <strong>3</strong>.</li>
        <li>Если количество наблюдений <strong>четное</strong>, медиана - это среднее значение двух центральных наблюдений. Например, в <strong>[1, 2, 3, 4]</strong> медиана равна <strong>2.5</strong>.</li>
    </ul>

    <p>Аналогично среднему арифметическому, медиана рассчитывается, как правило, для <strong>количественных признаков</strong>. Если мы хотим рассчитать медиану размера чека (<strong>avg_receipt</strong>), воспользуемся методом <span class="code-chip">.median()</span>:</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].median()</code></pre>
<p class="print_result">400.0</p>

    <p>Получается, в половине ресторанов размер чека меньше 400 у.е., а в другой половине больше</p>

    <h3>МОДА</h3>

    <p>Последняя мера центральной тенденции - <strong>мода</strong>. Она показывает <strong>самое частое (популярное) значение</strong> в данных. Если значения среднего и медианы может быть только одно, то мод в данных может быть несколько:</p>

    <p>Данные: <strong>F D A D B C</strong></p>
    <div class="scrollable-table">
    <table border="1" class="dataframe">
    <tr>
        <th>Значение</th>
        <th>Частота</th>
    </tr>
    <tr>
        <td>F</td>
        <td>1</td>
    </tr>
    <tr>
        <td>D</td>
        <td>2</td>
    </tr>
    <tr>
        <td>A</td>
        <td>1</td>
    </tr>
    <tr>
        <td>B</td>
        <td>1</td>
    </tr>
</table></div>
<p><strong>D</strong> встречается чаще всего, значит <strong>D - МОДА</strong>.</p>

    <p>Как правило, моду рассчитывают для <strong>категориальных признаков</strong>. Если мы хотим найти, какая кухня (<strong>cuisines_type</strong>) наиболее распространенная в наших данных, воспользуемся методом <span class="code-chip">.mode()</span>:</p>

    <pre class="line-numbers"><code class="language-python">df['cuisines_type'].mode()</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>cuisines_type</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>North Indian, Chinese</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Этот метод возвращает серию (<strong>Series</strong>). Если бы мод было несколько (какие-то значения встретились одинаково часто), то все они вывелись бы в этой таблице. Чтобы извлечь конкретное значение моды, к нему нужно обратиться по индексу:</p>

    <pre class="line-numbers"><code class="language-python">df['cuisines_type'].mode()[0]</code></pre>
<p class="print_result">North Indian, Chinese</p>

    <p>Моду <strong>количественного признака</strong> можно оценить по гистограмме распределения.</p>

    <h3>СРАВНЕНИЕ МЕР ЦЕНТРАЛЬНОЙ ТЕНДЕНЦИИ</h3>

    <p>Мы разобрали три основных МЦТ. У каждой из них есть особенности использования и интерпретации:</p>

    <table border="1" class="dataframe_new" style="width: 100%;">
        <tr>
            <th></th>
            <th>СРЕДНЕЕ АРИФМЕТИЧЕСКОЕ</th>
            <th>МЕДИАНА</th>
            <th>МОДА</th>
        </tr>
        <tr>
            <td><strong>Определение</strong></td>
            <td>Отношение суммы всех наблюдений к их количеству</td>
            <td>Срединная МЦТ</td>
            <td>Самые частые/популярные значения</td>
        </tr>
        <tr>
            <td><strong>Метод</strong></td>
            <td><span class="code-chip">.mean()</span></td>
            <td><span class="code-chip">.median()</span></td>
            <td><span class="code-chip">.mode()</span></td>
        </tr>
        <tr>
            <td><strong>Устойчивость к выбросам</strong></td>
            <td>✕</td>
            <td>✓</td>
            <td>-</td>
        </tr>
        <tr>
            <td><strong>Типы данных:</strong></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><em>количественные</em></td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
        </tr>
        <tr>
            <td><em>категориальные</em></td>
            <td>Бинарные, закодированные в виде 1 и 0 (доля 1 в данных)</td>
            <td>✕</td>
            <td>✓</td>
        </tr>
    </table>

    <p>Теперь посмотрим, как графически оценивать среднее, медиану и моду по гистограмме.</p>
    <p>Для начала рассмотрим <strong>симметричные распределения.</strong> Распределение можно назвать симметричным, если гистограмма зеркально-симметрична относительно центра графика. Для оценки мер центральной тенденции в таких распределениях нужно запомнить два правила:</p>
    <ul>
        <li>
            <p>Среднее и медиана совпадают (или почти совпадают) и находятся по центру</p>
        </li>
        <li>
            <p>Мода - это пик(и)</p>
        </li>
    </ul>

    <img src="picture/chapter6/10.svg" width="100%" alt="Рисунок 10">

    <p>Выбросов (они могут находится на хвостах распределения) нет – а если и есть, то они уравновешивают среднее арифметическое слева и справа, и оно остается по центру. Медиана просто делит данные пополам.</p>

    <p>Если в данных один пик, как на гистограмме слева, со средним и медианой будет совпадать также и мода, так как пик данных находится по центру. Когда в данных одна мода, такое распределение называются <strong>унимодальным</strong>.</p>

    <p>В данных может быть и несколько пиков, как на графике справа. Когда пиков два, такое распределение называется <strong>бимодальным</strong>, и в нем каждый из пиков будет модой. Среднее и медиана также будут находиться посередине.</p>

    <p>Построим гистограмму распределения рейтинга ресторанов (<strong>rate</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].plot(kind='hist', bins=15)</code></pre>
    <img src="picture/chapter6/img1.png" width="70%" alt="Рисунок 10">

    <p>В целом, полученное распределение практически симметрично. Давайте сравним среднее и медиану для него:</p>

    <pre class="line-numbers"><code class="language-python">round(df['rate'].mean(), 1)  # среднее</code></pre>
<p class="print_result">np.float64(3.6)</p>
    
    <pre class="line-numbers"><code class="language-python">round(df['rate'].median(), 1)  # медиана</code></pre>
<p class="print_result">3.6</p>

    <p>Мы видим, что среднее и медиана совпадают. Если мы мысленно проведем линию на гистограмме признака <strong>rate</strong> на значении 3.6, она окажется по середине графика.</p>

    <p>Из равенства среднего и медианы вытекает еще одно свойство:</p>

    <ul><li><p>
        если среднее и медиана совпадают (или практически совпадают), мы не можем утверждать, что в даннных есть экстремальные значения (выбросы)
    </p></li></ul>
    <p>Распределения также могут быть <strong>асимметричными</strong>, в которых относительно центра графика отсутвует какая-либо зеркальность. В таких распределениях для оценки мер центральной тенденции пользуемся следующими тремя правилами:</p>
    
    <ul>
        <li><p>
Среднее арифметическое тяготеет к тяжелым хвостам (к выбросам)
        </p></li>
        <li><p>
            Медиана тяготеет к основной группе данных (от выбросов)
        </p></li>
        <li><p>
            Мода - это пик(и)
        </p></li>
    </ul>

    <img src="picture/chapter6/11.svg" width="100%" alt="Рисунок 11">

    <p>Для определения моды мы пользуемся той же логикой, что и в симметричных распределениях: мода - там, где пик. Теперь разберемся со средним и медианой.</p>
    
    <p>На первой гистограмме тяжелый хвост находится справа. В этом тяжелом хвосте собраны <strong>экстремально высокие значения</strong> (выбросы), значительно отличающиеся от большей части наших данных. Из всех мер центральной тенденции среднее будет ближе всего к этому тяжелому хвосту, так как эта МЦТ не устойчива к выбросам и всегда тянется к экстремальным значениям. Медиана будет дальше от выбросов, чем среднее, так как эта МЦТ к выбросам устойчива. Из этого наблюдения у нас вытекает еще одна закономерность:</p>

    <ul><li><p>Если <strong>среднее значительно больше, чем медиана</strong>, это свидетельствует о том, что в данных есть <strong>экстремально высокие значения</strong></p></li></ul>

    <p>В тяжелом хвосте на второй гистограмме собрались <strong>экстремально низкие значения</strong> (выбросы). Логика определения среднего и медианы здесь точно такая же. Среднее не устойчиво к выбросам, а значит оно будет тяготеть к тяжелым хвостам и будет ближе всего к ним. Медиана к выбросам устойчива, а значит она будет дальше от экстремальных значений. На основании этого мы можем сделать еще один вывод:</p>

    <ul><li><p>Если <strong>среднее значительно меньше, чем медиана</strong>, это свидетельствует о том, что в данных есть <strong>экстремально низкие значения</strong></p></li></ul>

    <p>Построим гистограмму распределения размера чека (<strong>avg_receipt</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].plot(kind='hist', bins=15)</code></pre>

    <img src="picture/chapter6/img2.png" width="70%" alt="Рисунок 2">

    <p>Распределение размера чека асимметричное. В большей части ресторанов чек не превышает 2000 у.е., однако мы видим на гистограмме тяжелый хвост справа, там находятся рестораны с экстремально высоким размером чека. Значит мы можем предположить, что для данного признака среднее значение будет больше, чем медиана. Давайте это предположение проверим:</p>

    <pre class="line-numbers"><code class="language-python">round(df['avg_receipt'].mean(), 1)  # среднее</code></pre>
<p class="print_result">np.float64(555.9)</p>
    <pre class="line-numbers"><code class="language-python">round(df['avg_receipt'].median(), 1)  # медиана</code></pre>
<p class="print_result">400.0</p>
    <p>Как мы видим, среднее больше медианы почти на 156 у.е. Значит наши выводы на основе гистограммы оказались верны.</p>

    <div style="height: 10px;"></div>
    <h2 id="chapter6-3">6.3 Какие бывают квартили?</h2>

    <div class="important-card">
        <div class="important-text">
            <strong>Квартили</strong> — это специальные величины, позволяющие разделить весь набор данных на четыре равных части.
        </div>
    </div>

    <p>Квартили позволяют эффективно разделить данные на отдельные слои на основании некоторого <strong>количественного признака</strong>. В контексте ресторанного рынка использование квартилей помогает выделить различные сегменты заведений – например, проанализировав рейтинг мест общественного питания (<strong>rate</strong>).</p>

    <p>Выделяют пять основных квартилей:</p>

    <ul>
        <li>
            <p><strong>Нулевой квартиль (Q₀)</strong></p>
            <p>Это такое значение, меньше которого 0% данных. Это то же самое, что <strong>минимум</strong> в данных. Чтобы рассчитать нулевой квартиль, можно воспользоваться методом <span class="code-chip">.quantile(0)</span> или <span class="code-chip">.min()</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(0)</code></pre>
            <p class="print_result">np.float64(1.8)</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].min()</code></pre>
            <p class="print_result">1.8</p>
            <p>Самый низкий рейтинг ресторана – 1.8 звезд. Или, другими словами, 100% ресторанов имеют рейтинг не меньше 1.8.</p>
        </li>
        
        <li>
            <p><strong>Первый квартиль (Q₁)</strong></p>
            <p>Это значение, меньше которого 25% данных, или значение, больше которого 75% данных.</p>
            <p>Для рассчета первого квартиля используется метод <span class="code-chip">.quantile(0.25)</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(0.25)</code></pre>
            <p class="print_result">3.3</p>
            <p>25% ресторанов имеют рейтинг менее 3.3 звезд. Эти 25% ресторанов можно отнести к худшим ресторанам с самым низким рейтингом. У остальных 75% ресторанов рейтинг более 3.3 звезд.</p>
        </li>
        
        <li>
            <p><strong>Второй квартиль (Q₂)</strong></p>
            <p>Это то же самое, что <strong>медиана</strong>. Второй квартиль делит данные пополам: меньше него 50% данных и больше него тоже 50%.</p>
            <p>Для рассчета этого значения используется либо метод <span class="code-chip">.quantile(0.5)</span>, либо <span class="code-chip">.median()</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(0.5)</code></pre>
            <p class="print_result">np.float64(3.6)</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].median()</code></pre>
            <p class="print_result">3.6</p>
            <p>50% ресторанов имеют рейтинг менее (более) 3.6 звезд, или медиана рейтинга ресторана составляет 3.6 звезд</p>
        </li>
        
        <li>
            <p><strong>Третий квартиль (Q₃)</strong></p>
            <p>Это значение, меньше которого 75% данных. Или значение, больше которого 25% данных.</p>
            <p>Для рассчета третьего квартиля используется метод <span class="code-chip">.quantile(0.75)</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(0.75)</code></pre>
            <p class="print_result">np.float64(3.9)</p>
            <p>25% ресторанов имеют рейтинг более 3.9 звезд. Это сегмент ресторанов с самым высоким рейтингом. У остальных 75% ресторанов рейтинг меньше этого значения.</p>
        </li>
        
        <li>
            <p><strong>Четвертый квартиль (Q₄)</strong></p>
            <p>Это то же самое, что <strong>максимум</strong> данных. То есть, это такое значение, больше которого 0% данных.</p>
            <p>Для рассчета этого значения используется либо метод <span class="code-chip">.quantile(1)</span>, либо <span class="code-chip">.max()</span>:</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].quantile(1)</code></pre>
            <p class="print_result">np.float64(4.9)</p>
            <pre class="line-numbers"><code class="language-python">df['rate'].max()</code></pre>
            <p class="print_result">4.9</p>
        </li>
    </ul>

    <img src="picture/chapter6/12.svg" width="100%" alt="Рисунок 12">
<div class="scrollable-table">
    <table border="1" class="dataframe_new" style="width: 100%;">
        <tr>
            <th></th>
            <th>НУЛЕВОЙ КВАРТИЛЬ<br>(МИНИМУМ)</th>
            <th>ПЕРВЫЙ КВАРТИЛЬ</th>
            <th>ВТОРОЙ КВАРТИЛЬ<br>(МЕДИАНА)</th>
            <th>ТРЕТИЙ КВАРТИЛЬ</th>
            <th>ЧЕТВЕРТЫЙ КВАРТИЛЬ<br>(МАКСИМУМ)</th>
        </tr>
        <tr>
            <td><strong>Определение</strong></td>
            <td>100% значений не меньше чем Q₀</td>
            <td>75% значений больше чем Q₁</td>
            <td>50% значений больше чем Q₂</td>
            <td>25% значений больше чем Q₃</td>
            <td>100% значений не больше чем Q₄</td>
        </tr>
        <tr>
            <td></td>
            <td>Минимальное значение равно Q₀</td>
            <td>25% значений меньше чем Q₁</td>
            <td>50% значений меньше чем Q₂</td>
            <td>75% значений меньше чем Q₃</td>
            <td>Максимальное значение равно Q₄</td>
        </tr>
        <tr>
            <td><strong>Метод</strong></td>
            <td><span class="code-chip">.quantile(0)</span><br><span class="code-chip">.min()</span></td>
            <td><span class="code-chip">.quantile(0.25)</span></td>
            <td><span class="code-chip">.quantile(0.5)</span><br><span class="code-chip">.median()</span></td>
            <td><span class="code-chip">.quantile(0.75)</span></td>
            <td><span class="code-chip">.quantile(1)</span><br><span class="code-chip">.max()</span></td>
        </tr>
        <tr>
            <td><strong>Типы данных:</strong></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><em>количественные</em></td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
        </tr>
        <tr>
            <td><em>категориальные</em></td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
        </tr>
    </table>
</div>
<div style="height: 10px;"></div>
    <h2 id="chapter6-4">6.4 Какие бывают меры вариативности?</h2>

    <p>Мы описали типичный ресторан с помощью мер центральной тенденции. Затем мы провели сегментацию ресторанов по уровням популярности, используя квартили, выделяя верхние и нижние слои по качеству обслуживания и привлекательности для клиентов.</p>

    <p>Теперь, чтобы глубже разобраться в структуре рынка и выяснить, насколько сильно <em>различаются</em> рестораны друг от друга, нам необходимы <strong>меры вариативности</strong> (разброса).</p>

    <div class="important-card">
        <div class="important-text">
        <strong>Меры вариативности</strong> - это группа описательных статистик, которые используются для оценки <em>степени разброса</em> значений признака.
        </div>
    </div>

    <h3>РАЗМАХ</h3>

    <p>Если мы хотим узнать <em>амплитуду разброса</em> <strong>количественного признака</strong>, можно рассчитать <strong>размах</strong>. Чтобы его рассчитать, нужно найти разницу между максимальным и минимальным значением. Например, мы хотим найти размах размера чека (<strong>avg_receipt</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].max() - df['avg_receipt'].min()</code></pre>
<p class="print_result">5960.0</p>
    <p>Размер чека в местах общественного питания меняется в диапазоне 5960 у.е.. Это довольно большое число, говорящие о разнообразии мест, которые представленны в наших данных: у нас есть скромные места с небольшим чеком, но представлены и более изысканные дорогие заведения.</p>

    <p>У размаха есть большой недостаток – он <strong>не устойчив к экстремальным значениям</strong> (выбросам). То есть, если в данных только один дорогой ресторан, где средний размер чека составляет, к примеру, 7000 у.е., а во всех остальных ресторанах чек около 1000 у.е., по итоговому числу может показаться, что дорогих ресторанов очень много – это приведет к искажению общего понимания рынка.</p>

    <p>Этот недостаток связан с тем, что для рассчета размаха берутся крайние значения признака (максимум и минимум), а они зачастую могут оказаться выбросами, единичными искажениями в данных.</p>

    <img src="picture/chapter6/13.svg" width="100%" alt="Рисунок 13">

    <h3>ИНТЕРКВАРТИЛЬНЫЙ РАЗМАХ (IQR)</h3>

    <p>Если мы хотим оценить, в каком диапазоне меняется значение, но при этом нам нужна мера вариативности, устойчивая к выбросам, можно рассчитать <strong>интерквартильный размах</strong> (межквартильный диапазон). Довольно часто его сокращают как IQR (Interquartile Range). Чтобы его рассчитать, нужно из третьего квартиля (Q₃) вычесть первый квартиль (Q₁):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].quantile(0.75) - df['avg_receipt'].quantile(0.25)</code></pre>
<p class="print_result">np.float64(300.0)</p>
    <p>Устойчивость к выбросам этой метрики обусловлена способом ее расчета: берутся не крайние значения, которые могут оказаться выбросами, а Q₁ и Q₃, расположенные ближе к центру распределения. Между этими эти квартилями находится 50% наблюдений (в нашем случае – ресторанов), поэтому мы можем сказать, что диапазон разброса центральных 50% наблюдений по размеру чека составляет 300 у.е.</p>

    <img src="picture/chapter6/14.svg" width="100%" alt="Рисунок 14">

    <h3>ДИСПЕРСИЯ</h3>

    <p>Еще одна мера, позволяющая оценить разброс данных, это <strong>дисперсия</strong>. В математике она обозначается греческой буква сигма в квадрате -  σ<sup>2</sup> . Это мера показывает <em>усредненный квадрат отклонений</em> <strong>количественного</strong> признака от среднего арифметического:</p>

        <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msup><mi>σ</mi><mn>2</mn></msup>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mo>(</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>x</mi><mn>1</mn></msub>
          <mo>-</mo>
          <mover><mi>x</mi><mo>¯</mo></mover>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>x</mi><mn>2</mn></msub>
          <mo>-</mo>
          <mover><mi>x</mi><mo>¯</mo></mover>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mo>…</mo>
      <mo>+</mo>
      <msup>
        <mrow>
          <mo>(</mo>
          <msub><mi>x</mi><mi>n</mi></msub>
          <mo>-</mo>
          <mover><mi>x</mi><mo>¯</mo></mover>
          <mo>)</mo>
        </mrow>
        <mn>2</mn>
      </msup>
      <mo>)</mo>
    </mrow>
    <mi>n</mi>
  </mfrac>
</math>

    <p>x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>  - каждое наблюдение количественного признака</p>
    <p>x̄  - среднее арифметическое</p>
    <p>(x<sub>n</sub>−x̄)<sup>2</sup>  - квадрат отклонения данных от среднего арифметического. Квадрат берется, чтобы не появился минус, так как отклонение может быть как в большую, так и в меньшую сторону от среднего.</p>
    <p>n  - количество наблюдений. Делим на число наблюдений, чтобы найти усредненное значение.</p>


    <p>Для того чтобы рассчитать дисперсию в Python, нам не нужна формула, нужно лишь воспользоваться методом <span class="code-chip">.var()</span> (от слова variance, – англ. <em>дисперсия</em>)</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].var()</code></pre>
<p class="print_result">224698.25283148492</p>

    <p>Недостатком дисперсии как меры вариативности является ее зависимость от среднего арифметического, вследствие чего она <strong>крайне восприимчива к наличию выбросов</strong>. Более того, поскольку расчет основан на квадратах отклонений, итоговая величина оказывается неудобной для интуитивного осмысления, так как представляет собой квадратную меру первоначальной единицы измерения.</p>
    <p>Тем не менее, попробовать выразить смысл полученного результата можно следующим образом: усредненное квадратичное отклонение размера чека от среднего значения составило 224698.25  у.е<sup>2</sup>.</p>
    <p>Мы можем использовать дисперсию для сравнения степени разброса нескольких наборов данных. Чем больше дисперсия, тем больше разброс данных, и тем менее плотно наши данные собраны вокруг среднего и больше растянуты по числовой оси. С точки зрения гистограммы распределения это выглядит так:</p>
    <img src="picture/chapter6/15.svg" width="100%" alt="Рисунок 15">

    <h3>СТАНДАРТНОЕ ОТКЛОНЕНИЕ</h3>
    <p>Чтобы избавиться от квадрата в дисперсии, можно взять <em>корень</em>. Такая мера вариативности называется <strong>стандартным отклонением</strong> и обозначется  σ , но уже без квадрата:</p>

    <math xmlns="http://www.w3.org/1998/Math/MathML" style="font-size: 1.3em;">
  <mi>σ</mi>
  <mo>=</mo>
  <msqrt>
    <mfrac>
      <mrow>
        <mo>(</mo>
        <msup>
          <mrow>
            <mo>(</mo>
            <msub><mi>x</mi><mn>1</mn></msub>
            <mo>-</mo>
            <mover><mi>x</mi><mo>¯</mo></mover>
            <mo>)</mo>
          </mrow>
          <mn>2</mn>
        </msup>
        <mo>+</mo>
        <msup>
          <mrow>
            <mo>(</mo>
            <msub><mi>x</mi><mn>2</mn></msub>
            <mo>-</mo>
            <mover><mi>x</mi><mo>¯</mo></mover>
            <mo>)</mo>
          </mrow>
          <mn>2</mn>
        </msup>
        <mo>+</mo>
        <mo>…</mo>
        <mo>+</mo>
        <msup>
          <mrow>
            <mo>(</mo>
            <msub><mi>x</mi><mi>n</mi></msub>
            <mo>-</mo>
            <mover><mi>x</mi><mo>¯</mo></mover>
            <mo>)</mo>
          </mrow>
          <mn>2</mn>
        </msup>
        <mo>)</mo>
      </mrow>
      <mi>n</mi>
    </mfrac>
  </msqrt>
</math>

    <p>Чтобы рассчитать стандартное отклонение, воспользуемся методом <span class="code-chip">.std()</span> от англ. <em>standard deviation:</em></p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].std()</code></pre>
<p class="print_result">474.02347286973554</p>

    <p>Стандартное отклонение также <strong>чувствительно к выбросам</strong>, но гораздо удобнее в интерпретации: в среднем размер чека отличается от среднего арифметического на 474.02 у.е..</p>
    <p>Стандартное отклонение также можно использовать для сравнения разброса нескольких наборов данных. Логика такая же, как и с дисперсией: чем больше стандартное отклонение, тем больше вариативность данных, и тем больше данные растянуты по оси:</p>
    <img src="picture/chapter6/16.svg" width="100%" alt="Рисунок 16">

    <h3>КОЛИЧЕСТВО УНИКАЛЬНЫХ ЗНАЧЕНИЙ</h3>

    <p>Меры вариативности, которые мы рассмотрели выше, используется только для количественных признаков. Если мы хотим оценить разнообразие <strong>категориального признака</strong>, можно рассчитать количество уникальных значений с помощью метода <span class="code-chip">.nunique()</span>:</p>

    <pre class="line-numbers"><code class="language-python">df['cuisines_type'].nunique()</code></pre>
<p class="print_result">2045</p>

    <p>Другими словами, в вашем датасете содержится 2045 различных типов кухни.</p>
    <div class="scrollable-table">
    <table border="1" class="dataframe_new" style="width: 100%;">
        <tr>
            <th></th>
            <th>РАЗМАХ</th>
            <th>ИНТЕРКВАРТИЛЬНЫЙ РАЗМАХ</th>
            <th>ДИСПЕРСИЯ</th>
            <th>СТАНДАРТНОЕ ОТКЛОНЕНИЕ</th>
            <th>КОЛИЧЕСТВО УНИКАЛЬНЫХ ЗНАЧЕНИЙ</th>
        </tr>
        <tr>
            <td><strong>Определение</strong></td>
            <td>Амплитуда разброса данных</td>
            <td>Диапазон в котором лежит 50% центральных данных</td>
            <td>Усредненный квадрат отклонений данных от среднего</td>
            <td>Усредненное отклонение данных от среднего</td>
            <td>Количество категорий</td>
        </tr>
        <tr>
            <td><strong>Метод</strong></td>
            <td><span class="code-chip">.max()-.min()</span></td>
            <td><span class="code-chip">.quantile(0.75)-.quantile(0.25)</span></td>
            <td><span class="code-chip">.var()</span></td>
            <td><span class="code-chip">.std()</span></td>
            <td><span class="code-chip">.nunique()</span></td>
        </tr>
        <tr>
            <td><strong>Устойчивость к выбросам</strong></td>
            <td>✕</td>
            <td>✓</td>
            <td>✕</td>
            <td>✕</td>
            <td>-</td>
        </tr>
        <tr>
            <td><strong>Типы данных:</strong></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><em>количественные</em></td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
            <td>✓</td>
            <td>✕</td>
        </tr>
        <tr>
            <td><em>категориальные</em></td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
            <td>✕</td>
            <td>✓</td>
        </tr>
    </table>
    </div>

<a href="https://edu.hse.ru/mod/quiz/view.php?id=1610938" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самоопроверка</button></a>
<div style="height: 10px;"></div>
    <h2 id="chapter6-5">6.5 Как искать выбросы в данных?</h2>

    <p>В прошлых разделах мы уже затронули тему выбросов. А сейчас поговорим о них чуть подробнее.</p>

    <div class="important-card">
        <div class="important-text">
            <strong>Выбросы</strong> — это крайне высокие или низкие значения, резко отличающиеся от остальных данных.
        </div>
    </div>

    <p>В анализе выбросы принято удалять, так как с ними плохо работают классические методы, такие как корреляция и регрессия, о которых мы будем говорить дальше.</p>

    <p>Чтобы удалить выбросы, для начала нужно узнать их границы. Для этого используются два основных метода: <strong>метод N стандартных отклонений</strong> и <strong>метод 1.5 интерквартильных размахов</strong>.</p>

    <h3>МЕТОД N СТАНДАРТНЫХ ОТКЛОНЕНИЙ (STD)</h3>

    <p>Чтобы узнать границы выбросов методом N стандартных отклонений, нужно проделать следующие шаги:</p>

    <ol>
        <li>Рассчитать среднее арифметическое (<span class="code-chip">avg</span>):
            <p class="fake-code"><span class="code-line">avg = датафрейм['признак'].mean()</span></p>
        </li>
        <li>Рассчитать стандартное отклонение (<span class="code-chip">std</span>):
            <p class="fake-code"><span class="code-line">std = датафрейм['признак'].std()</span></p>
        </li>
        <li>Находим левую границу выбросов:
            <p class="fake-code"><span class="code-line">left = avg - N*std</span></p>
        </li>
        <li>Находим правую границу выбросов:
            <p class="fake-code"><span class="code-line">right = avg + N*std</span></p>
        </li>
    </ol>

    <p>Выбросами будут являться все те наблюдения, которые меньше левой границы и больше, чем правая граница. Если мы хотим оставить только чистые данные без выбросов, можно сделать следующую фильтрацию:</p>
    <p class="fake-code"><span class="code-line">df_clean = df[(датафрейм['признак'] >= left) & (датафрейм['признак'] <= right)]</span></p>
    <p>А если, наоборот, нужны только выбросы, делаем следующую фильтрацию:</p>
    <p class="fake-code"><span class="code-line">outliers = df[(датафрейм['признак'] < left) | (датафрейм['признак'] > right)]</span></p>

    <img src="picture/chapter6/17.svg" width="100%" alt="Рисунок 17">

    <p>Давайте рассчитаем границы выбросов для размера чека (<strong>avg_receipt</strong>). Будем считать, что выбросы – это все рестораны, в которых размер чека отличается от среднего более чем на 2 стандартных отклонения:</p>

    <pre class="line-numbers"><code class="language-python">avg = df['avg_receipt'].mean()
std = df['avg_receipt'].std()

left = avg - 2*std
right = avg + 2*std</code></pre>

    <p>Если мы хотим сохранить чистые данные без выбросов в отдельную переменную, чтобы в дальнейшем с ними работать, сделаем следующую фильтрацию:</p>

    <pre class="line-numbers"><code class="language-python">df_clean = df[(df['avg_receipt'] >= left) & (df['avg_receipt'] <= right)]
df_clean.shape[0]</code></pre>
<p class="print_result">5825</p>

    <p>В данных осталось 5825 ресторанов.</p>
    <p>Если мы хотим посчитать количество выбросов, сделаем обратную фильтрацию:</p>
    <pre class="line-numbers"><code class="language-python">df[(df['avg_receipt'] < left) | (df['avg_receipt'] > right)].shape[0]</code></pre>
    <p class="print_result">582</p>

    <p>Выбросами по размеру чека оказались 582 ресторана.</p>

    <h3>МЕТОД 1.5 ИНТЕРКВАРТИЛЬНЫХ РАЗМАХОВ (IQR)</h3>

    <p>Второй метод для нахождения границ выбросов основывается на квартилях. Алгоритм его использования следующий:</p>

    <ol>
        <li>Рассчитать первый квартиль (<span class="code-chip">q1</span>):
            <p class="fake-code"><span class="code-line">q1 = датафрейм['признак'].quantile(0.25)</span></p>
        </li>
        <li>Рассчитать третий квартиль (<span class="code-chip">q3</span>):
            <p class="fake-code"><span class="code-line">q3 = датафрейм['признак'].quantile(0.75)</span></p>
        </li>
        <li>Находим интерквартильный размах (<span class="code-chip">iqr</span>):
            <p class="fake-code"><span class="code-line">iqr = q3-q1</span></p>
        </li>
        <li>Находим левую границу выбросов:
            <p class="fake-code"><span class="code-line">left = q1 - 1.5*iqr</span></p>
        </li>
        <li>Находим правую границу выбросов:
            <p class="fake-code"><span class="code-line">right = q3 + 1.5*iqr</span></p>
        </li>
    </ol>

    <img src="picture/chapter6/18.svg" width="100%" alt="Рисунок 18">

    <p>Теперь давайте рассчитаем границы выбросов размера чека (<strong>avg_receipt</strong>) методом 1.5*IQR:</p>

    <pre class="line-numbers"><code class="language-python">q1 = df['avg_receipt'].quantile(0.25)
q3 = df['avg_receipt'].quantile(0.75)
iqr = q3 - q1

left = q1 - 1.5*iqr
right = q3 + 1.5*iqr</code></pre>

    <p>Сделаем фильтрацию и посчитаем, сколько ресторанов согласно этому методу не будут считаться выбросами:</p>

    <pre class="line-numbers"><code class="language-python">df[(df['avg_receipt'] >= left) & (df['avg_receipt'] <= right)].shape[0]</code></pre>

    <p class="print_result">5825</p>

    <p>Для нахождения количества выбросов сделаем следующую фильтрацию:</p>

    <pre class="line-numbers"><code class="language-python">df[(df['avg_receipt'] < left) | (df['avg_receipt'] > right)].shape[0]</code></pre>

    <p class="print_result">582</p>

    <p>Количество выбросов и чистых данных для обоих методов совпали, но на практике они могут отличаться, и это нормально.</p>

    <h3>ЯЩИК С УСАМИ</h3>

    <p>Мы уже с вами умеем строить ящик с усами. Теперь разберемся подробнее с тем, какую информацию он может нам дать.</p>

    <p>В первую очередь, с его помощью можно оценить наличие выбросов в данных.<strong>Выбросы</strong> на нем <strong>обозначаются кружками</strong> с левой и с правой стороны от "усов". <strong>Границы выбросов</strong> находятся в конце каждого из "усов" и рассчитываются по методу <strong>1.5*IQR</strong>.</p>

    <p><strong>Левая граница</strong> ящика - это <strong>первый квартиль</strong> (Q₁), а <strong>правая граница</strong> - это <strong>третий квартиль</strong> (Q₃). Линия <strong>посередине</strong> - <strong>медиана</strong> (второй квартиль, Q₂)</p>

    <img src="picture/chapter6/19.svg" width="100%" alt="Рисунок 19">

    <p>Ящик всегда показывает квартили, а вот границы "усов" могут рассчитываться по разному в зависимости от того, есть в данных выбросы или нет.</p>

    <p>Если в данных <strong>нет экстремально низких значений</strong>, то есть нет кружков слева:</p>
    <ul>
        <li><p>Левая граница: <strong>минимум</strong></p></li>
        <li><p>Правая граница: <strong>Q3+1.5∗IQR</strong></p></li>
    </ul>

    <p>Если в данных <strong>нет экстремально высоких значений</strong>, то есть нет кружков справа:</p>
    <ul>
        <li><p>Левая граница: <strong>Q1-1.5∗IQR</strong></p></li>
        <li><p>Правая граница: <strong>максимум</strong></p></li>
    </ul>

    <p>Если в данных <strong>нет экстремальных значений</strong>, то есть нет кружков вообще:</p>
    <ul>
        <li><p>Левая граница: <strong>минимум</strong></p></li>
        <li><p>Правая граница: <strong>максимум</strong></p></li>
    </ul>

    <img src="picture/chapter6/20.svg" width="100%" alt="Рисунок 20">

    <div class="important-card">
        <div class="important-text">
            На ящике с усами нет среднего арифметического, но мы можем оценить его положение. Если в данных есть экстремально низкие значения, то среднее будет левее медианы, а если в данных есть экстремально высокие значения, то среднее будет правее медианы.
        </div>
    </div>

    <p>Давайте построим ящик с усами для рейтинга ресторанов (<strong>rate</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].plot(kind='box', vert=False)</code></pre>

    <img src="picture/chapter6/img3.png" width="70%" alt="Рисунок 3">
    
    <p>Мы видим, что выбросы есть слева и справа. Значит если мы хотим узнать точные значения основных показателей, будем следовать следующему алгоритму:</p>

    <p>Самые крайние кружочки – это минимум и максимум:</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].min()  # левый кружок</code></pre>
<p class="print_result">2.0</p>

    <pre class="line-numbers"><code class="language-python">df['rate'].max()  # правый кружок</code></pre>
<p class="print_result">4.9</p>

    <p>Линия посередине ящика - это медиана:</p>
        <pre class="line-numbers"><code class="language-python">df['rate'].median()</code></pre>
<p class="print_result">3.6</p>

    <p>Левая граница ящика - это первый квартиль (<span class="code-chip">q1</span>), а правая граница - третий квартиль (<span class="code-chip">q3</span>):</p>

    <pre class="line-numbers"><code class="language-python">q1 = df['rate'].quantile(0.25)  # левая граница коробки
q1</code></pre>
<p class="print_result">np.float64(3.3)</p>

    <pre class="line-numbers"><code class="language-python">q3 = df['rate'].quantile(0.75)  # правая граница коробки
q3</code></pre>
<p class="print_result">np.float64(3.9)</p>

    <p>Теперь рассчитаем интерквартильный размах (<span class="code-chip">IQR</span>):</p>
    <pre class="line-numbers"><code class="language-python">iqr = q3 - q1
iqr</code></pre>
<p class="print_result">np.float64(0.6000000000000001)</p>

    <p>Теперь можем рассчитать значение левого и правого усов:</p>

    <pre class="line-numbers"><code class="language-python">q1 - 1.5*iqr  # левый ус</code></pre>
<p class="print_result">np.float64(2.3999999999999995)</p>

    <pre class="line-numbers"><code class="language-python">q3 + 1.5*iqr  # правый ус</code></pre>
<p class="print_result">np.float64(4.8)</p>

    <p>А теперь построим ящик с усами для среднего размера чека в ресторанах (<strong>avg_receipt</strong>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].plot(kind='box', vert=False)</code></pre>

    <img src="picture/chapter6/img4.png" width="70%" alt="Рисунок 4">

    <p>У данного признака нет экстремально низких значений, значит левый ус - это минимум, а самая крайна правая точка - это максимум:</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].min()  # левый ус</code></pre>
<p class="print_result">40.0</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].max()  # крайная правая точка</code></pre>
<p class="print_result">6000.0</p>

    <p>Ящик интерпретируется точно также: линия посередине - это медиана, левая граница - первый квартиль (<span class="code-chip">q1</span>), правая граница - третий квартиль (<span class="code-chip">q3</span>):</p>

    <pre class="line-numbers"><code class="language-python">df['avg_receipt'].median()  # линия по середине коробки</code></pre>
<p class="print_result">400.0</p>

    <p>На ящике с усами нет среднего арифметического, но мы можем оценить, какое оно. В данных есть экстремально высокие значения, среднее тянется к выбросам и будет ближе к ним, чем медиана, значит среднее арифметическое будет больше чем 400.</p>

    <pre class="line-numbers"><code class="language-python">q1 = df['avg_receipt'].quantile(0.25)  # левая граница коробки
q1</code></pre>
<p class="print_result">np.float64(300.0)</p>

    <pre class="line-numbers"><code class="language-python">q3 = df['avg_receipt'].quantile(0.75)  # правая граница коробки
q3</code></pre>
<p class="print_result">np.float64(650.0)</p>

    <p>Правый "ус" - это граница выбросов:</p>

    <pre class="line-numbers"><code class="language-python">iqr = q3 - q1  # интерквартильный размах
q3 + 1.5*iqr  # правый ус</code></pre>
<p class="print_result">np.float64(1175.0)</p>



    <a href="https://edu.hse.ru/mod/quiz/view.php?id=1610939" target="_blank" rel="noopener noreferrer"><button class="check_yourself">Самопроверка</button></a>
<div style="height: 10px;"></div>
    <h2 id="chapter6-6">6.6 Как обрабатывать пропуски в данных?</h2>

    <p>Теперь обсудим, как работать с пропусками в данных. Пропуск - это отсутствие информации, которое в Pandas обозначается как <span class="code-chip">NaN</span>.</p>

    <h3>ПОДСЧЕТ КОЛИЧЕСТВА ПРОПУСКОВ</h3>

    <p>Мы уже встречали метод агрегирования <span class="code-chip">.count()</span>, который возвращает количество непропущенных значений. Но если нам, наоборот, нужно количество пропусков, можно использоваться методом <span class="code-chip">.isna()</span>. Давайте применим его к нашему датафрейму по ресторанам и посмотрим, что он вернет:</p>

    <pre class="line-numbers"><code class="language-python">df.isna()</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>name</th>
            <th>restaurant_type</th>
            <th>rate</th>
            <th>votes</th>
            <th>avg_receipt</th>
            <th>online_order</th>
            <th>table_booking</th>
            <th>cuisines_type</th>
            <th>area</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>1</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>2</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>True</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>3</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>4</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>...</th>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
        </tr>
        <tr>
            <th>6402</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>6403</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>6404</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>6405</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        <tr>
            <th>6406</th>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
            <td>False</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Этот метод преобразует все значения датафрейма в <span class="code-chip">True</span> и <span class="code-chip">False</span>. <span class="code-chip">True</span> говорит о том, что значение пропущено (NaN), а <span class="code-chip">False</span> - что пропуска нет. По сути <span class="code-chip">True</span> - это 1, а <span class="code-chip">False</span> - это 0 Если мы хотим посчитать <strong>количество пропусков</strong> в каждом столбце, нам нужно просуммировать <span class="code-chip">True</span>. Для этого применим к <span class="code-chip">.isna()</span> еще и метод <span class="code-chip">.sum()</span>:</p>

    <p class="fake-code"><span class="code-line">датафрейм.isna().sum()</span></p>

    <pre class="line-numbers"><code class="language-python">df.isna().sum()</code></pre>

    <div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>20</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>37</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Мы видим 20 пропусков в признаке тип ресторана (<strong>restaurant_type</strong>) и 37 пропусков в количестве людей, поставивших оценку (<strong>votes</strong>). В остальных признаках пропусков нет.</p>

    
    <p>Для того чтобы получить не количество, а <strong>долю пропусков</strong>, применим к <span class="code-chip">.isna()</span> метод <span class="code-chip">.mean()</span>:</p>

    <p class="fake-code"><span class="code-line">датафрейм.isna().mean()</span></p>

    <pre class="line-numbers"><code class="language-python">df.isna().mean()</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>0.003122</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>0.005775</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0.0</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Такая команда возвращает долю пропусков, так как <span class="code-chip">.isna()</span> трансформирует признаки в бинарный формат, где каждый признак по факту 0 (<span class="code-chip">False</span>) и 1 (<span class="code-chip">True</span>), а среднее найденное по такому признаку будет показывать долю 1 в данных, то есть долю пропусков.</p>

    <p>При необходимости долю пропусков можно перевести в <strong>проценты</strong>, просто домножив на 100:</p>

    <p class="fake-code"><span class="code-line">датафрейм.isna().mean()*100</span></p>

    <pre class="line-numbers"><code class="language-python">df.isna().mean()*100</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>0.312159</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>0.577493</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0.0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0.0</td>
        </tr>
        </tbody>
    </table>
</div>


    <h3>ЗАМЕНА ПРОПУСКОВ</h3>

    <p>Пропуски в данных принято заменять на подходящую меру центральной тенденции. Пропуски в <strong>количественном</strong> признаке заменяют на <strong>медиану</strong>, а в <strong>категориальном</strong> - на <strong>моду</strong>. Заменить пропуски можно с помощью метода <span class="code-chip">.fillna()</span>:</p>

    <p class="fake-code"><span class="code-line">датафрейм['новый признак'] = датафрейм['признак'].fillna(на что заменяем)</span></p>

    <p>Этот метод работает следующим образом: если в <span class="code-chip">признаке</span> значение не пропущено, то <span class="code-chip">.fillna()</span> просто переносит его в <span class="code-chip">новый признак</span>, а если он видит <span class="code-chip">NaN</span>, то записывает вместо него в <span class="code-chip">новый признак</span> то, что мы указали в круглых скобках.</p>

    <p>Количестве людей, поставивших оценку (<strong>votes</strong>) является количественным признаком, поэтому заменим пропуски в нем на медиану, а чистый столбец без пропусков сохраним в новый признак (<strong>votes_clean</strong>):</p>

    <pre class="line-numbers"><code class="language-python">med = df['votes'].median()  # медиана
df['votes_clean'] = df['votes'].fillna(med)  # заменяем
df.isna().sum()  # проверяем</code></pre>

<div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>20</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>37</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes_clean</th>
            <td>0</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>В столбце <strong>votes</strong> пропуски остались на месте, а вот в <strong>votes_clean</strong> пропусков уже нет. В дальнейшем, если вам понадобится столбец с количеством людей, оценивших ресторан, мы будем работать уже с новым признаком <strong>votes_clean</strong>.</p>

    <p>Второй столбец с пропусками, <strong>restaurant_type</strong> - это тип ресторана. Столбец категориальный, поэтому пропуски в нем мы заменим на моду. Для начала рассчитаем моду для этого признака:</p>

    <pre class="line-numbers"><code class="language-python">df['restaurant_type'].mode()</code></pre>

    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>restaurant_type</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>0</th>
            <td>Quick Bites</td>
        </tr>
        </tbody>
    </table>


    <p>Напомним, что этот метод возвращает не просто значение, а Series таблицу. Чтобы извлечь значение моды, к нему нужно обратиться по индексу:</p>

    <pre class="line-numbers"><code class="language-python">md = df['restaurant_type'].mode()[0]
md</code></pre>

    <p>Теперь мы можем заменить пропуски в признаке на значение моды, а результаты сохраним в новый признак <strong>restaurant_type_clean</strong>:</p>

    <pre class="line-numbers"><code class="language-python">df['restaurant_type_clean'] = df['restaurant_type'].fillna(md)  # заменяем
df.isna().sum()  # проверяем</code></pre>

        <div class="scrollable-table">
    <table border="1" class="dataframe">
        <thead>
        <tr style="text-align: right;">
            <th></th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>name</th>
            <td>0</td>
        </tr>
        <tr>
            <th>restaurant_type</th>
            <td>20</td>
        </tr>
        <tr>
            <th>rate</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes</th>
            <td>37</td>
        </tr>
        <tr>
            <th>avg_receipt</th>
            <td>0</td>
        </tr>
        <tr>
            <th>online_order</th>
            <td>0</td>
        </tr>
        <tr>
            <th>table_booking</th>
            <td>0</td>
        </tr>
        <tr>
            <th>cuisines_type</th>
            <td>0</td>
        </tr>
        <tr>
            <th>area</th>
            <td>0</td>
        </tr>
        <tr>
            <th>votes_clean</th>
            <td>0</td>
        </tr>
        <tr>
            <th>restaurant_type_clean</th>
            <td>0</td>
        </tr>
        </tbody>
    </table>
</div>

    <p>Теперь в <strong>restaurant_type_clean</strong> пропусков нет.</p>

</section>

<section><a href="https://edu.hse.ru/mod/quiz/view.php?id=1610940" target="_blank" rel="noopener noreferrer"><button class="check">Практика</button></a>&nbsp;<a href="https://edu.hse.ru/course/view.php?id=236211" target="_blank" rel="noopener noreferrer"><button class="back_to_course">Вернуться к курсу</button></a>
    <div style="height: 50px;"></div>
</section>

    </div>
</div>

<script>
    const toggleNav = document.getElementById('toggleNav');
    const sideNav = document.getElementById('sideNav');

    toggleNav.addEventListener('click', () => {
        sideNav.classList.toggle('open');
    });
</script>

<script>
    document.querySelectorAll('.accordion-button').forEach(button => {
        button.addEventListener('click', () => {
            button.classList.toggle('active');
            const content = button.nextElementSibling;

            if (button.classList.contains('active')) {
                content.style.maxHeight = content.scrollHeight + 'px';
            } else {
                content.style.maxHeight = '0';
            }
        });
    });
</script>

</html>
